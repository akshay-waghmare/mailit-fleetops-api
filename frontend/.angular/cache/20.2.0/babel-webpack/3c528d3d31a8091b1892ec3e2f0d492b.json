{"ast":null,"code":"var dr = Object.create;\nvar Ie = Object.defineProperty;\nvar Tr = Object.getOwnPropertyDescriptor;\nvar gr = Object.getOwnPropertyNames;\nvar xr = Object.getPrototypeOf,\n  hr = Object.prototype.hasOwnProperty;\nvar r = (n, s) => Ie(n, \"name\", {\n  value: s,\n  configurable: !0\n});\nvar Jr = (n, s) => () => (s || n((s = {\n  exports: {}\n}).exports, s), s.exports);\nvar wr = (n, s, a, p) => {\n  if (s && typeof s == \"object\" || typeof s == \"function\") for (let c of gr(s)) !hr.call(n, c) && c !== a && Ie(n, c, {\n    get: () => s[c],\n    enumerable: !(p = Tr(s, c)) || p.enumerable\n  });\n  return n;\n};\nvar Pr = (n, s, a) => (a = n != null ? dr(xr(n)) : {}, wr(\n// If the importer is in node compatibility mode or this is not an ESM\n// file that has been converted to a CommonJS file using a Babel-\n// compatible transform (i.e. \"__esModule\" has not been set), then set\n// \"default\" to the CommonJS \"module.exports\" for node compatibility.\ns || !n || !n.__esModule ? Ie(a, \"default\", {\n  value: n,\n  enumerable: !0\n}) : a, n));\n\n// ../node_modules/jsdoc-type-pratt-parser/dist/index.js\nvar dt = Jr((fe, yt) => {\n  (function (n, s) {\n    typeof fe == \"object\" && typeof yt < \"u\" ? s(fe) : typeof define == \"function\" && define.amd ? define([\"exports\"], s) : (n = typeof globalThis < \"u\" ? globalThis : n || self, s(n.jtpp = {}));\n  })(fe, function (n) {\n    \"use strict\";\n\n    function s(e) {\n      return e.text !== void 0 && e.text !== \"\" ? `'${e.type}' with value '${e.text}'` : `'${e.type}'`;\n    }\n    r(s, \"tokenToString\");\n    let ne = class ne extends Error {\n      constructor(t) {\n        super(`No parslet found for token: ${s(t)}`), this.token = t, Object.setPrototypeOf(this, ne.prototype);\n      }\n      getToken() {\n        return this.token;\n      }\n    };\n    r(ne, \"NoParsletFoundError\");\n    let a = ne,\n      oe = class oe extends Error {\n        constructor(t) {\n          super(`The parsing ended early. The next token was: ${s(t)}`), this.token = t, Object.setPrototypeOf(this, oe.prototype);\n        }\n        getToken() {\n          return this.token;\n        }\n      };\n    r(oe, \"EarlyEndOfParseError\");\n    let p = oe,\n      se = class se extends Error {\n        constructor(t, o) {\n          let i = `Unexpected type: '${t.type}'.`;\n          o !== void 0 && (i += ` Message: ${o}`), super(i), Object.setPrototypeOf(this, se.prototype);\n        }\n      };\n    r(se, \"UnexpectedTypeError\");\n    let c = se;\n    function u(e) {\n      return t => t.startsWith(e) ? {\n        type: e,\n        text: e\n      } : null;\n    }\n    r(u, \"makePunctuationRule\");\n    function m(e) {\n      let t = 0,\n        o,\n        i = e[0],\n        l = !1;\n      if (i !== \"'\" && i !== '\"') return null;\n      for (; t < e.length;) {\n        if (t++, o = e[t], !l && o === i) {\n          t++;\n          break;\n        }\n        l = !l && o === \"\\\\\";\n      }\n      if (o !== i) throw new Error(\"Unterminated String\");\n      return e.slice(0, t);\n    }\n    r(m, \"getQuoted\");\n    let T = new RegExp(\"[$_\\\\p{ID_Start}]|\\\\\\\\u\\\\p{Hex_Digit}{4}|\\\\\\\\u\\\\{0*(?:\\\\p{Hex_Digit}{1,5}|10\\\\p{Hex_Digit}{4})\\\\}\", \"u\"),\n      g = new RegExp(\"[$\\\\-\\\\p{ID_Continue}\\\\u200C\\\\u200D]|\\\\\\\\u\\\\p{Hex_Digit}{4}|\\\\\\\\u\\\\{0*(?:\\\\p{Hex_Digit}{1,5}|10\\\\p{Hex_Digit}{4})\\\\}\", \"u\");\n    function P(e) {\n      let t = e[0];\n      if (!T.test(t)) return null;\n      let o = 1;\n      do {\n        if (t = e[o], !g.test(t)) break;\n        o++;\n      } while (o < e.length);\n      return e.slice(0, o);\n    }\n    r(P, \"getIdentifier\");\n    let b = /^(NaN|-?((\\d*\\.\\d+|\\d+)([Ee][+-]?\\d+)?|Infinity))/;\n    function de(e) {\n      var t, o;\n      return (o = (t = b.exec(e)) === null || t === void 0 ? void 0 : t[0]) !== null && o !== void 0 ? o : null;\n    }\n    r(de, \"getNumber\");\n    let q = /* @__PURE__ */r(e => {\n      let t = P(e);\n      return t == null ? null : {\n        type: \"Identifier\",\n        text: t\n      };\n    }, \"identifierRule\");\n    function S(e) {\n      return t => {\n        if (!t.startsWith(e)) return null;\n        let o = t[e.length];\n        return o !== void 0 && g.test(o) ? null : {\n          type: e,\n          text: e\n        };\n      };\n    }\n    r(S, \"makeKeyWordRule\");\n    let z = /* @__PURE__ */r(e => {\n        let t = m(e);\n        return t == null ? null : {\n          type: \"StringValue\",\n          text: t\n        };\n      }, \"stringValueRule\"),\n      Te = /* @__PURE__ */r(e => e.length > 0 ? null : {\n        type: \"EOF\",\n        text: \"\"\n      }, \"eofRule\"),\n      ge = /* @__PURE__ */r(e => {\n        let t = de(e);\n        return t === null ? null : {\n          type: \"Number\",\n          text: t\n        };\n      }, \"numberRule\"),\n      Rt = [Te, u(\"=>\"), u(\"(\"), u(\")\"), u(\"{\"), u(\"}\"), u(\"[\"), u(\"]\"), u(\"|\"), u(\"&\"), u(\"<\"), u(\">\"), u(\",\"), u(\";\"), u(\"*\"), u(\"?\"), u(\"!\"), u(\"=\"), u(\":\"), u(\"...\"), u(\".\"), u(\"#\"), u(\"~\"), u(\"/\"), u(\"@\"), S(\"undefined\"), S(\"null\"), S(\"function\"), S(\"this\"), S(\"new\"), S(\"module\"), S(\"event\"), S(\"external\"), S(\"typeof\"), S(\"keyof\"), S(\"readonly\"), S(\"import\"), S(\"is\"), S(\"in\"), S(\"asserts\"), ge, q, z],\n      jt = /^\\s*\\n\\s*/,\n      U = class U {\n        static create(t) {\n          let o = this.read(t);\n          t = o.text;\n          let i = this.read(t);\n          return t = i.text, new U(t, void 0, o.token, i.token);\n        }\n        constructor(t, o, i, l) {\n          this.text = \"\", this.text = t, this.previous = o, this.current = i, this.next = l;\n        }\n        static read(t, o = !1) {\n          o = o || jt.test(t), t = t.trim();\n          for (let i of Rt) {\n            let l = i(t);\n            if (l !== null) {\n              let f = Object.assign(Object.assign({}, l), {\n                startOfLine: o\n              });\n              return t = t.slice(f.text.length), {\n                text: t,\n                token: f\n              };\n            }\n          }\n          throw new Error(\"Unexpected Token \" + t);\n        }\n        advance() {\n          let t = U.read(this.text);\n          return new U(t.text, this.current, this.next, t.token);\n        }\n      };\n    r(U, \"Lexer\");\n    let xe = U;\n    function J(e) {\n      if (e === void 0) throw new Error(\"Unexpected undefined\");\n      if (e.type === \"JsdocTypeKeyValue\" || e.type === \"JsdocTypeParameterList\" || e.type === \"JsdocTypeProperty\" || e.type === \"JsdocTypeRe\\\nadonlyProperty\" || e.type === \"JsdocTypeObjectField\" || e.type === \"JsdocTypeJsdocObjectField\" || e.type === \"JsdocTypeIndexSignature\" || e.type === \"JsdocTypeMappedType\") throw new c(e);\n      return e;\n    }\n    r(J, \"assertRootResult\");\n    function he(e) {\n      return e.type === \"JsdocTypeKeyValue\" ? H(e) : J(e);\n    }\n    r(he, \"assertPlainKeyValueOrRootResult\");\n    function Ft(e) {\n      return e.type === \"JsdocTypeName\" ? e : H(e);\n    }\n    r(Ft, \"assertPlainKeyValueOrNameResult\");\n    function H(e) {\n      if (e.type !== \"JsdocTypeKeyValue\") throw new c(e);\n      return e;\n    }\n    r(H, \"assertPlainKeyValueResult\");\n    function _t(e) {\n      var t;\n      if (e.type === \"JsdocTypeVariadic\") {\n        if (((t = e.element) === null || t === void 0 ? void 0 : t.type) === \"JsdocTypeName\") return e;\n        throw new c(e);\n      }\n      if (e.type !== \"JsdocTypeNumber\" && e.type !== \"JsdocTypeName\") throw new c(e);\n      return e;\n    }\n    r(_t, \"assertNumberOrVariadicNameResult\");\n    function Je(e) {\n      return e.type === \"JsdocTypeIndexSignature\" || e.type === \"JsdocTypeMappedType\";\n    }\n    r(Je, \"isSquaredProperty\");\n    var y;\n    (function (e) {\n      e[e.ALL = 0] = \"ALL\", e[e.PARAMETER_LIST = 1] = \"PARAMETER_LIST\", e[e.OBJECT = 2] = \"OBJECT\", e[e.KEY_VALUE = 3] = \"KEY_VALUE\", e[e.INDEX_BRACKETS = 4] = \"INDEX_BRACKETS\", e[e.UNION = 5] = \"UNION\", e[e.INTERSECTION = 6] = \"INTERSECTION\", e[e.PREFIX = 7] = \"PREFIX\", e[e.INFIX = 8] = \"\\\nINFIX\", e[e.TUPLE = 9] = \"TUPLE\", e[e.SYMBOL = 10] = \"SYMBOL\", e[e.OPTIONAL = 11] = \"OPTIONAL\", e[e.NULLABLE = 12] = \"NULLABLE\", e[e.KEY_OF_TYPE_OF = 13] = \"KEY_OF_TYPE_OF\", e[e.FUNCTION = 14] = \"FUNCTION\", e[e.ARROW = 15] = \"ARROW\", e[e.ARRAY_BRACKETS = 16] = \"ARRAY_BRACKETS\", e[e.GENERIC = 17] = \"GENERIC\", e[e.NAME_PATH = 18] = \"NAME_PATH\", e[e.PARENTHESIS = 19] = \"PARENTHESIS\", e[e.SPECIAL_TYPES = 20] = \"SPECIAL_TYPES\";\n    })(y || (y = {}));\n    let Ae = class Ae {\n      constructor(t, o, i) {\n        this.grammar = t, typeof o == \"string\" ? this._lexer = xe.create(o) : this._lexer = o, this.baseParser = i;\n      }\n      get lexer() {\n        return this._lexer;\n      }\n      /**\n       * Parses a given string and throws an error if the parse ended before the end of the string.\n       */\n      parse() {\n        let t = this.parseType(y.ALL);\n        if (this.lexer.current.type !== \"EOF\") throw new p(this.lexer.current);\n        return t;\n      }\n      /**\n       * Parses with the current lexer and asserts that the result is a {@link RootResult}.\n       */\n      parseType(t) {\n        return J(this.parseIntermediateType(t));\n      }\n      /**\n       * The main parsing function. First it tries to parse the current state in the prefix step, and then it continues\n       * to parse the state in the infix step.\n       */\n      parseIntermediateType(t) {\n        let o = this.tryParslets(null, t);\n        if (o === null) throw new a(this.lexer.current);\n        return this.parseInfixIntermediateType(o, t);\n      }\n      /**\n       * In the infix parsing step the parser continues to parse the current state with all parslets until none returns\n       * a result.\n       */\n      parseInfixIntermediateType(t, o) {\n        let i = this.tryParslets(t, o);\n        for (; i !== null;) t = i, i = this.tryParslets(t, o);\n        return t;\n      }\n      /**\n       * Tries to parse the current state with all parslets in the grammar and returns the first non null result.\n       */\n      tryParslets(t, o) {\n        for (let i of this.grammar) {\n          let l = i(this, o, t);\n          if (l !== null) return l;\n        }\n        return null;\n      }\n      /**\n       * If the given type equals the current type of the {@link Lexer} advance the lexer. Return true if the lexer was\n       * advanced.\n       */\n      consume(t) {\n        return Array.isArray(t) || (t = [t]), t.includes(this.lexer.current.type) ? (this._lexer = this.lexer.advance(), !0) : !1;\n      }\n      acceptLexerState(t) {\n        this._lexer = t.lexer;\n      }\n    };\n    r(Ae, \"Parser\");\n    let I = Ae;\n    function Ye(e) {\n      return e === \"EOF\" || e === \"|\" || e === \",\" || e === \")\" || e === \">\";\n    }\n    r(Ye, \"isQuestionMarkUnknownType\");\n    let we = /* @__PURE__ */r((e, t, o) => {\n      let i = e.lexer.current.type,\n        l = e.lexer.next.type;\n      return o == null && i === \"?\" && !Ye(l) || o != null && i === \"?\" ? (e.consume(\"?\"), o == null ? {\n        type: \"JsdocTypeNullable\",\n        element: e.parseType(y.NULLABLE),\n        meta: {\n          position: \"prefix\"\n        }\n      } : {\n        type: \"JsdocTypeNullable\",\n        element: J(o),\n        meta: {\n          position: \"suffix\"\n        }\n      }) : null;\n    }, \"nullableParslet\");\n    function x(e) {\n      let t = /* @__PURE__ */r((o, i, l) => {\n        let f = o.lexer.current.type,\n          d = o.lexer.next.type;\n        if (l === null) {\n          if (\"parsePrefix\" in e && e.accept(f, d)) return e.parsePrefix(o);\n        } else if (\"parseInfix\" in e && e.precedence > i && e.accept(f, d)) return e.parseInfix(o, l);\n        return null;\n      }, \"parslet\");\n      return Object.defineProperty(t, \"name\", {\n        value: e.name\n      }), t;\n    }\n    r(x, \"composeParslet\");\n    let Q = x({\n        name: \"optionalParslet\",\n        accept: /* @__PURE__ */r(e => e === \"=\", \"accept\"),\n        precedence: y.OPTIONAL,\n        parsePrefix: /* @__PURE__ */r(e => (e.consume(\"=\"), {\n          type: \"JsdocTypeOptional\",\n          element: e.parseType(y.OPTIONAL),\n          meta: {\n            position: \"prefix\"\n          }\n        }), \"parsePrefix\"),\n        parseInfix: /* @__PURE__ */r((e, t) => (e.consume(\"=\"), {\n          type: \"JsdocTypeOptional\",\n          element: J(t),\n          meta: {\n            position: \"suffix\"\n          }\n        }), \"parseInfix\")\n      }),\n      Z = x({\n        name: \"numberParslet\",\n        accept: /* @__PURE__ */r(e => e === \"Number\", \"accept\"),\n        parsePrefix: /* @__PURE__ */r(e => {\n          let t = parseFloat(e.lexer.current.text);\n          return e.consume(\"Number\"), {\n            type: \"JsdocTypeNumber\",\n            value: t\n          };\n        }, \"parsePrefix\")\n      }),\n      Vt = x({\n        name: \"parenthesisParslet\",\n        accept: /* @__PURE__ */r(e => e === \"(\", \"accept\"),\n        parsePrefix: /* @__PURE__ */r(e => {\n          if (e.consume(\"(\"), e.consume(\")\")) return {\n            type: \"JsdocTypeParameterList\",\n            elements: []\n          };\n          let t = e.parseIntermediateType(y.ALL);\n          if (!e.consume(\")\")) throw new Error(\"Unterminated parenthesis\");\n          return t.type === \"JsdocTypeParameterList\" ? t : t.type === \"JsdocTypeKeyValue\" ? {\n            type: \"JsdocTypeParameterList\",\n            elements: [t]\n          } : {\n            type: \"JsdocTypeParenthesis\",\n            element: J(t)\n          };\n        }, \"parsePrefix\")\n      }),\n      Lt = x({\n        name: \"specialTypesParslet\",\n        accept: /* @__PURE__ */r((e, t) => e === \"?\" && Ye(t) || e === \"null\" || e === \"undefined\" || e === \"*\", \"accept\"),\n        parsePrefix: /* @__PURE__ */r(e => {\n          if (e.consume(\"null\")) return {\n            type: \"JsdocTypeNull\"\n          };\n          if (e.consume(\"undefined\")) return {\n            type: \"JsdocTypeUndefined\"\n          };\n          if (e.consume(\"*\")) return {\n            type: \"JsdocTypeAny\"\n          };\n          if (e.consume(\"?\")) return {\n            type: \"JsdocTypeUnknown\"\n          };\n          throw new Error(\"Unacceptable token: \" + e.lexer.current.text);\n        }, \"parsePrefix\")\n      }),\n      Ut = x({\n        name: \"notNullableParslet\",\n        accept: /* @__PURE__ */r(e => e === \"!\", \"accept\"),\n        precedence: y.NULLABLE,\n        parsePrefix: /* @__PURE__ */r(e => (e.consume(\"!\"), {\n          type: \"JsdocTypeNotNullable\",\n          element: e.parseType(y.NULLABLE),\n          meta: {\n            position: \"prefix\"\n          }\n        }), \"parsePrefix\"),\n        parseInfix: /* @__PURE__ */r((e, t) => (e.consume(\"!\"), {\n          type: \"JsdocTypeNotNullable\",\n          element: J(t),\n          meta: {\n            position: \"suffix\"\n          }\n        }), \"parseInfix\")\n      });\n    function Bt({\n      allowTrailingComma: e\n    }) {\n      return x({\n        name: \"parameterListParslet\",\n        accept: /* @__PURE__ */r(t => t === \",\", \"accept\"),\n        precedence: y.PARAMETER_LIST,\n        parseInfix: /* @__PURE__ */r((t, o) => {\n          let i = [he(o)];\n          t.consume(\",\");\n          do try {\n            let l = t.parseIntermediateType(y.PARAMETER_LIST);\n            i.push(he(l));\n          } catch (l) {\n            if (e && l instanceof a) break;\n            throw l;\n          } while (t.consume(\",\"));\n          if (i.length > 0 && i.slice(0, -1).some(l => l.type === \"JsdocTypeVariadic\")) throw new Error(\"Only the last parameter may be a rest parameter\");\n          return {\n            type: \"JsdocTypeParameterList\",\n            elements: i\n          };\n        }, \"parseInfix\")\n      });\n    }\n    r(Bt, \"createParameterListParslet\");\n    let Ct = x({\n        name: \"genericParslet\",\n        accept: /* @__PURE__ */r((e, t) => e === \"<\" || e === \".\" && t === \"<\", \"accept\"),\n        precedence: y.GENERIC,\n        parseInfix: /* @__PURE__ */r((e, t) => {\n          let o = e.consume(\".\");\n          e.consume(\"<\");\n          let i = [];\n          do i.push(e.parseType(y.PARAMETER_LIST)); while (e.consume(\",\"));\n          if (!e.consume(\">\")) throw new Error(\"Unterminated generic parameter list\");\n          return {\n            type: \"JsdocTypeGeneric\",\n            left: J(t),\n            elements: i,\n            meta: {\n              brackets: \"angle\",\n              dot: o\n            }\n          };\n        }, \"parseInfix\")\n      }),\n      Mt = x({\n        name: \"unionParslet\",\n        accept: /* @__PURE__ */r(e => e === \"|\", \"accept\"),\n        precedence: y.UNION,\n        parseInfix: /* @__PURE__ */r((e, t) => {\n          e.consume(\"|\");\n          let o = [];\n          do o.push(e.parseType(y.UNION)); while (e.consume(\"|\"));\n          return {\n            type: \"JsdocTypeUnion\",\n            elements: [J(t), ...o]\n          };\n        }, \"parseInfix\")\n      }),\n      Pe = [we, Q, Z, Vt, Lt, Ut, Bt({\n        allowTrailingComma: !0\n      }), Ct, Mt, Q];\n    function ee({\n      allowSquareBracketsOnAnyType: e,\n      allowJsdocNamePaths: t,\n      pathGrammar: o\n    }) {\n      return /* @__PURE__ */r(function (l, f, d) {\n        if (d == null || f >= y.NAME_PATH) return null;\n        let h = l.lexer.current.type,\n          D = l.lexer.next.type;\n        if (!(h === \".\" && D !== \"<\" || h === \"[\" && (e || d.type === \"JsdocTypeName\") || t && (h === \"~\" || h === \"#\"))) return null;\n        let O,\n          ae = !1;\n        l.consume(\".\") ? O = \"property\" : l.consume(\"[\") ? (O = \"property-brackets\", ae = !0) : l.consume(\"~\") ? O = \"inner\" : (l.consume(\"#\"), O = \"instance\");\n        let rt = o !== null ? new I(o, l.lexer, l) : l,\n          k = rt.parseIntermediateType(y.NAME_PATH);\n        l.acceptLexerState(rt);\n        let G;\n        switch (k.type) {\n          case \"JsdocTypeName\":\n            G = {\n              type: \"JsdocTypeProperty\",\n              value: k.value,\n              meta: {\n                quote: void 0\n              }\n            };\n            break;\n          case \"JsdocTypeNumber\":\n            G = {\n              type: \"JsdocTypeProperty\",\n              value: k.value.toString(10),\n              meta: {\n                quote: void 0\n              }\n            };\n            break;\n          case \"JsdocTypeStringValue\":\n            G = {\n              type: \"JsdocTypeProperty\",\n              value: k.value,\n              meta: {\n                quote: k.meta.quote\n              }\n            };\n            break;\n          case \"JsdocTypeSpecialNamePath\":\n            if (k.specialType === \"event\") G = k;else throw new c(k, \"Type 'JsdocTypeSpecialNamePath' is only allowed with specialType 'event'\");\n            break;\n          default:\n            throw new c(k, \"Expecting 'JsdocTypeName', 'JsdocTypeNumber', 'JsdocStringValue' or 'JsdocTypeSpecialNamePath'\");\n        }\n        if (ae && !l.consume(\"]\")) {\n          let nt = l.lexer.current;\n          throw new Error(`Unterminated square brackets. Next token is '${nt.type}' with text '${nt.text}'`);\n        }\n        return {\n          type: \"JsdocTypeNamePath\",\n          left: J(d),\n          right: G,\n          pathType: O\n        };\n      }, \"namePathParslet\");\n    }\n    r(ee, \"createNamePathParslet\");\n    function R({\n      allowedAdditionalTokens: e\n    }) {\n      return x({\n        name: \"nameParslet\",\n        accept: /* @__PURE__ */r(t => t === \"Identifier\" || t === \"this\" || t === \"new\" || e.includes(t), \"accept\"),\n        parsePrefix: /* @__PURE__ */r(t => {\n          let {\n            type: o,\n            text: i\n          } = t.lexer.current;\n          return t.consume(o), {\n            type: \"JsdocTypeName\",\n            value: i\n          };\n        }, \"parsePrefix\")\n      });\n    }\n    r(R, \"createNameParslet\");\n    let Y = x({\n      name: \"stringValueParslet\",\n      accept: /* @__PURE__ */r(e => e === \"StringValue\", \"accept\"),\n      parsePrefix: /* @__PURE__ */r(e => {\n        let t = e.lexer.current.text;\n        return e.consume(\"StringValue\"), {\n          type: \"JsdocTypeStringValue\",\n          value: t.slice(1, -1),\n          meta: {\n            quote: t[0] === \"'\" ? \"single\" : \"double\"\n          }\n        };\n      }, \"parsePrefix\")\n    });\n    function te({\n      pathGrammar: e,\n      allowedTypes: t\n    }) {\n      return x({\n        name: \"specialNamePathParslet\",\n        accept: /* @__PURE__ */r(o => t.includes(o), \"accept\"),\n        parsePrefix: /* @__PURE__ */r(o => {\n          let i = o.lexer.current.type;\n          if (o.consume(i), !o.consume(\":\")) return {\n            type: \"JsdocTypeName\",\n            value: i\n          };\n          let l,\n            f = o.lexer.current;\n          if (o.consume(\"StringValue\")) l = {\n            type: \"JsdocTypeSpecialNamePath\",\n            value: f.text.slice(1, -1),\n            specialType: i,\n            meta: {\n              quote: f.text[0] === \"'\" ? \"single\" : \"double\"\n            }\n          };else {\n            let D = \"\",\n              E = [\"Identifier\", \"@\", \"/\"];\n            for (; E.some(O => o.consume(O));) D += f.text, f = o.lexer.current;\n            l = {\n              type: \"JsdocTypeSpecialNamePath\",\n              value: D,\n              specialType: i,\n              meta: {\n                quote: void 0\n              }\n            };\n          }\n          let d = new I(e, o.lexer, o),\n            h = d.parseInfixIntermediateType(l, y.ALL);\n          return o.acceptLexerState(d), J(h);\n        }, \"parsePrefix\")\n      });\n    }\n    r(te, \"createSpecialNamePathParslet\");\n    let We = [R({\n        allowedAdditionalTokens: [\"external\", \"module\"]\n      }), Y, Z, ee({\n        allowSquareBracketsOnAnyType: !1,\n        allowJsdocNamePaths: !0,\n        pathGrammar: null\n      })],\n      L = [...We, te({\n        allowedTypes: [\"event\"],\n        pathGrammar: We\n      })];\n    function be(e) {\n      let t;\n      if (e.type === \"JsdocTypeParameterList\") t = e.elements;else if (e.type === \"JsdocTypeParenthesis\") t = [e.element];else throw new c(e);\n      return t.map(o => he(o));\n    }\n    r(be, \"getParameters\");\n    function Kt(e) {\n      let t = be(e);\n      if (t.some(o => o.type === \"JsdocTypeKeyValue\")) throw new Error(\"No parameter should be named\");\n      return t;\n    }\n    r(Kt, \"getUnnamedParameters\");\n    function Se({\n      allowNamedParameters: e,\n      allowNoReturnType: t,\n      allowWithoutParenthesis: o,\n      allowNewAsFunctionKeyword: i\n    }) {\n      return x({\n        name: \"functionParslet\",\n        accept: /* @__PURE__ */r((l, f) => l === \"function\" || i && l === \"new\" && f === \"(\", \"accept\"),\n        parsePrefix: /* @__PURE__ */r(l => {\n          let f = l.consume(\"new\");\n          l.consume(\"function\");\n          let d = l.lexer.current.type === \"(\";\n          if (!d) {\n            if (!o) throw new Error(\"function is missing parameter list\");\n            return {\n              type: \"JsdocTypeName\",\n              value: \"function\"\n            };\n          }\n          let h = {\n              type: \"JsdocTypeFunction\",\n              parameters: [],\n              arrow: !1,\n              constructor: f,\n              parenthesis: d\n            },\n            D = l.parseIntermediateType(y.FUNCTION);\n          if (e === void 0) h.parameters = Kt(D);else {\n            if (f && D.type === \"JsdocTypeFunction\" && D.arrow) return h = D, h.constructor = !0, h;\n            h.parameters = be(D);\n            for (let E of h.parameters) if (E.type === \"JsdocTypeKeyValue\" && !e.includes(E.key)) throw new Error(`only allowed named parameters are ${e.join(\", \")} but got ${E.type}`);\n          }\n          if (l.consume(\":\")) h.returnType = l.parseType(y.PREFIX);else if (!t) throw new Error(\"function is missing return type\");\n          return h;\n        }, \"parsePrefix\")\n      });\n    }\n    r(Se, \"createFunctionParslet\");\n    function Ee({\n      allowPostfix: e,\n      allowEnclosingBrackets: t\n    }) {\n      return x({\n        name: \"variadicParslet\",\n        accept: /* @__PURE__ */r(o => o === \"...\", \"accept\"),\n        precedence: y.PREFIX,\n        parsePrefix: /* @__PURE__ */r(o => {\n          o.consume(\"...\");\n          let i = t && o.consume(\"[\");\n          try {\n            let l = o.parseType(y.PREFIX);\n            if (i && !o.consume(\"]\")) throw new Error(\"Unterminated variadic type. Missing ']'\");\n            return {\n              type: \"JsdocTypeVariadic\",\n              element: J(l),\n              meta: {\n                position: \"prefix\",\n                squareBrackets: i\n              }\n            };\n          } catch (l) {\n            if (l instanceof a) {\n              if (i) throw new Error(\"Empty square brackets for variadic are not allowed.\");\n              return {\n                type: \"JsdocTypeVariadic\",\n                meta: {\n                  position: void 0,\n                  squareBrackets: !1\n                }\n              };\n            } else throw l;\n          }\n        }, \"parsePrefix\"),\n        parseInfix: e ? (o, i) => (o.consume(\"...\"), {\n          type: \"JsdocTypeVariadic\",\n          element: J(i),\n          meta: {\n            position: \"suffix\",\n            squareBrackets: !1\n          }\n        }) : void 0\n      });\n    }\n    r(Ee, \"createVariadicParslet\");\n    let Ge = x({\n        name: \"symbolParslet\",\n        accept: /* @__PURE__ */r(e => e === \"(\", \"accept\"),\n        precedence: y.SYMBOL,\n        parseInfix: /* @__PURE__ */r((e, t) => {\n          if (t.type !== \"JsdocTypeName\") throw new Error(\"Symbol expects a name on the left side. (Reacting on '(')\");\n          e.consume(\"(\");\n          let o = {\n            type: \"JsdocTypeSymbol\",\n            value: t.value\n          };\n          if (!e.consume(\")\")) {\n            let i = e.parseIntermediateType(y.SYMBOL);\n            if (o.element = _t(i), !e.consume(\")\")) throw new Error(\"Symbol does not end after value\");\n          }\n          return o;\n        }, \"parseInfix\")\n      }),\n      Xe = x({\n        name: \"arrayBracketsParslet\",\n        precedence: y.ARRAY_BRACKETS,\n        accept: /* @__PURE__ */r((e, t) => e === \"[\" && t === \"]\", \"accept\"),\n        parseInfix: /* @__PURE__ */r((e, t) => (e.consume(\"[\"), e.consume(\"]\"), {\n          type: \"JsdocTypeGeneric\",\n          left: {\n            type: \"JsdocTypeName\",\n            value: \"Array\"\n          },\n          elements: [J(t)],\n          meta: {\n            brackets: \"square\",\n            dot: !1\n          }\n        }), \"parseInfix\")\n      });\n    function Ne({\n      objectFieldGrammar: e,\n      allowKeyTypes: t\n    }) {\n      return x({\n        name: \"objectParslet\",\n        accept: /* @__PURE__ */r(o => o === \"{\", \"accept\"),\n        parsePrefix: /* @__PURE__ */r(o => {\n          o.consume(\"{\");\n          let i = {\n            type: \"JsdocTypeObject\",\n            meta: {\n              separator: \"comma\"\n            },\n            elements: []\n          };\n          if (!o.consume(\"}\")) {\n            let l,\n              f = new I(e, o.lexer, o);\n            for (;;) {\n              f.acceptLexerState(o);\n              let d = f.parseIntermediateType(y.OBJECT);\n              o.acceptLexerState(f), d === void 0 && t && (d = o.parseIntermediateType(y.OBJECT));\n              let h = !1;\n              if (d.type === \"JsdocTypeNullable\" && (h = !0, d = d.element), d.type === \"JsdocTypeNumber\" || d.type === \"JsdocTypeName\" || d.type === \"JsdocTypeStringValue\") {\n                let E;\n                d.type === \"JsdocTypeStringValue\" && (E = d.meta.quote), i.elements.push({\n                  type: \"JsdocTypeObjectField\",\n                  key: d.value.toString(),\n                  right: void 0,\n                  optional: h,\n                  readonly: !1,\n                  meta: {\n                    quote: E\n                  }\n                });\n              } else if (d.type === \"JsdocTypeObjectField\" || d.type === \"JsdocTypeJsdocObjectField\") i.elements.push(d);else throw new c(d);\n              if (o.lexer.current.startOfLine) l = \"linebreak\";else if (o.consume(\",\")) l = \"comma\";else if (o.consume(\";\")) l = \"semicolon\";else break;\n              if (o.lexer.current.type === \"}\") break;\n            }\n            if (i.meta.separator = l ?? \"comma\", !o.consume(\"}\")) throw new Error(\"Unterminated record type. Missing '}'\");\n          }\n          return i;\n        }, \"parsePrefix\")\n      });\n    }\n    r(Ne, \"createObjectParslet\");\n    function De({\n      allowSquaredProperties: e,\n      allowKeyTypes: t,\n      allowReadonly: o,\n      allowOptional: i\n    }) {\n      return x({\n        name: \"objectFieldParslet\",\n        precedence: y.KEY_VALUE,\n        accept: /* @__PURE__ */r(l => l === \":\", \"accept\"),\n        parseInfix: /* @__PURE__ */r((l, f) => {\n          var d;\n          let h = !1,\n            D = !1;\n          i && f.type === \"JsdocTypeNullable\" && (h = !0, f = f.element), o && f.type === \"JsdocTypeReadonlyProperty\" && (D = !0, f = f.element);\n          let E = (d = l.baseParser) !== null && d !== void 0 ? d : l;\n          if (E.acceptLexerState(l), f.type === \"JsdocTypeNumber\" || f.type === \"JsdocTypeName\" || f.type === \"JsdocTypeStringValue\" || Je(f)) {\n            if (Je(f) && !e) throw new c(f);\n            E.consume(\":\");\n            let O;\n            f.type === \"JsdocTypeStringValue\" && (O = f.meta.quote);\n            let ae = E.parseType(y.KEY_VALUE);\n            return l.acceptLexerState(E), {\n              type: \"JsdocTypeObjectField\",\n              key: Je(f) ? f : f.value.toString(),\n              right: ae,\n              optional: h,\n              readonly: D,\n              meta: {\n                quote: O\n              }\n            };\n          } else {\n            if (!t) throw new c(f);\n            E.consume(\":\");\n            let O = E.parseType(y.KEY_VALUE);\n            return l.acceptLexerState(E), {\n              type: \"JsdocTypeJsdocObjectField\",\n              left: J(f),\n              right: O\n            };\n          }\n        }, \"parseInfix\")\n      });\n    }\n    r(De, \"createObjectFieldParslet\");\n    function Oe({\n      allowOptional: e,\n      allowVariadic: t\n    }) {\n      return x({\n        name: \"keyValueParslet\",\n        precedence: y.KEY_VALUE,\n        accept: /* @__PURE__ */r(o => o === \":\", \"accept\"),\n        parseInfix: /* @__PURE__ */r((o, i) => {\n          let l = !1,\n            f = !1;\n          if (e && i.type === \"JsdocTypeNullable\" && (l = !0, i = i.element), t && i.type === \"JsdocTypeVariadic\" && i.element !== void 0 && (f = !0, i = i.element), i.type !== \"JsdocTypeName\") throw new c(i);\n          o.consume(\":\");\n          let d = o.parseType(y.KEY_VALUE);\n          return {\n            type: \"JsdocTypeKeyValue\",\n            key: i.value,\n            right: d,\n            optional: l,\n            variadic: f\n          };\n        }, \"parseInfix\")\n      });\n    }\n    r(Oe, \"createKeyValueParslet\");\n    let ze = [...Pe, Se({\n        allowWithoutParenthesis: !0,\n        allowNamedParameters: [\"this\", \"new\"],\n        allowNoReturnType: !0,\n        allowNewAsFunctionKeyword: !1\n      }), Y, te({\n        allowedTypes: [\"module\", \"external\", \"event\"],\n        pathGrammar: L\n      }), Ee({\n        allowEnclosingBrackets: !0,\n        allowPostfix: !0\n      }), R({\n        allowedAdditionalTokens: [\"keyof\"]\n      }), Ge, Xe, ee({\n        allowSquareBracketsOnAnyType: !1,\n        allowJsdocNamePaths: !0,\n        pathGrammar: L\n      })],\n      $t = [...ze, Ne({\n        // jsdoc syntax allows full types as keys, so we need to pull in the full grammar here\n        // we leave out the object type deliberately\n        objectFieldGrammar: [R({\n          allowedAdditionalTokens: [\"module\", \"in\"]\n        }), De({\n          allowSquaredProperties: !1,\n          allowKeyTypes: !0,\n          allowOptional: !1,\n          allowReadonly: !1\n        }), ...ze],\n        allowKeyTypes: !0\n      }), Oe({\n        allowOptional: !0,\n        allowVariadic: !0\n      })],\n      He = x({\n        name: \"typeOfParslet\",\n        accept: /* @__PURE__ */r(e => e === \"typeof\", \"accept\"),\n        parsePrefix: /* @__PURE__ */r(e => (e.consume(\"typeof\"), {\n          type: \"JsdocTypeTypeof\",\n          element: J(e.parseType(y.KEY_OF_TYPE_OF))\n        }), \"parsePrefix\")\n      }),\n      qt = [R({\n        allowedAdditionalTokens: [\"module\", \"keyof\", \"event\", \"external\", \"in\"]\n      }), we, Q, Y, Z, De({\n        allowSquaredProperties: !1,\n        allowKeyTypes: !1,\n        allowOptional: !1,\n        allowReadonly: !1\n      })],\n      Yt = [...Pe, Ne({\n        allowKeyTypes: !1,\n        objectFieldGrammar: qt\n      }), R({\n        allowedAdditionalTokens: [\"event\", \"external\", \"in\"]\n      }), He, Se({\n        allowWithoutParenthesis: !1,\n        allowNamedParameters: [\"this\", \"new\"],\n        allowNoReturnType: !0,\n        allowNewAsFunctionKeyword: !1\n      }), Ee({\n        allowEnclosingBrackets: !1,\n        allowPostfix: !1\n      }),\n      // additional name parslet is needed for some special cases\n      R({\n        allowedAdditionalTokens: [\"keyof\"]\n      }), te({\n        allowedTypes: [\"module\"],\n        pathGrammar: L\n      }), ee({\n        allowSquareBracketsOnAnyType: !1,\n        allowJsdocNamePaths: !0,\n        pathGrammar: L\n      }), Oe({\n        allowOptional: !1,\n        allowVariadic: !1\n      }), Ge],\n      Wt = x({\n        name: \"assertsParslet\",\n        accept: /* @__PURE__ */r(e => e === \"asserts\", \"accept\"),\n        parsePrefix: /* @__PURE__ */r(e => {\n          e.consume(\"asserts\");\n          let t = e.parseIntermediateType(y.SYMBOL);\n          if (t.type !== \"JsdocTypeName\") throw new c(t, \"A typescript asserts always has to have a name on the left side.\");\n          return e.consume(\"is\"), {\n            type: \"JsdocTypeAsserts\",\n            left: t,\n            right: J(e.parseIntermediateType(y.INFIX))\n          };\n        }, \"parsePrefix\")\n      });\n    function Gt({\n      allowQuestionMark: e\n    }) {\n      return x({\n        name: \"tupleParslet\",\n        accept: /* @__PURE__ */r(t => t === \"[\", \"accept\"),\n        parsePrefix: /* @__PURE__ */r(t => {\n          t.consume(\"[\");\n          let o = {\n            type: \"JsdocTypeTuple\",\n            elements: []\n          };\n          if (t.consume(\"]\")) return o;\n          let i = t.parseIntermediateType(y.ALL);\n          if (i.type === \"JsdocTypeParameterList\" ? i.elements[0].type === \"JsdocTypeKeyValue\" ? o.elements = i.elements.map(H) : o.elements = i.elements.map(J) : i.type === \"JsdocTypeKeyValue\" ? o.elements = [H(i)] : o.elements = [J(i)], !t.consume(\"]\")) throw new Error(\"Unterminated '['\");\n          if (!e && o.elements.some(l => l.type === \"JsdocTypeUnknown\")) throw new Error(\"Question mark in tuple not allowed\");\n          return o;\n        }, \"parsePrefix\")\n      });\n    }\n    r(Gt, \"createTupleParslet\");\n    let Xt = x({\n        name: \"keyOfParslet\",\n        accept: /* @__PURE__ */r(e => e === \"keyof\", \"accept\"),\n        parsePrefix: /* @__PURE__ */r(e => (e.consume(\"keyof\"), {\n          type: \"JsdocTypeKeyof\",\n          element: J(e.parseType(y.KEY_OF_TYPE_OF))\n        }), \"parsePrefix\")\n      }),\n      zt = x({\n        name: \"importParslet\",\n        accept: /* @__PURE__ */r(e => e === \"import\", \"accept\"),\n        parsePrefix: /* @__PURE__ */r(e => {\n          if (e.consume(\"import\"), !e.consume(\"(\")) throw new Error(\"Missing parenthesis after import keyword\");\n          let t = e.parseType(y.PREFIX);\n          if (t.type !== \"JsdocTypeStringValue\") throw new Error(\"Only string values are allowed as paths for imports\");\n          if (!e.consume(\")\")) throw new Error(\"Missing closing parenthesis after import keyword\");\n          return {\n            type: \"JsdocTypeImport\",\n            element: t\n          };\n        }, \"parsePrefix\")\n      }),\n      Ht = x({\n        name: \"readonlyPropertyParslet\",\n        accept: /* @__PURE__ */r(e => e === \"readonly\", \"accept\"),\n        parsePrefix: /* @__PURE__ */r(e => (e.consume(\"readonly\"), {\n          type: \"JsdocTypeReadonlyProperty\",\n          element: e.parseType(y.KEY_VALUE)\n        }), \"parsePrefix\")\n      }),\n      Qt = x({\n        name: \"arrowFunctionParslet\",\n        precedence: y.ARROW,\n        accept: /* @__PURE__ */r(e => e === \"=>\", \"accept\"),\n        parseInfix: /* @__PURE__ */r((e, t) => (e.consume(\"=>\"), {\n          type: \"JsdocTypeFunction\",\n          parameters: be(t).map(Ft),\n          arrow: !0,\n          constructor: !1,\n          parenthesis: !0,\n          returnType: e.parseType(y.OBJECT)\n        }), \"parseInfix\")\n      }),\n      Zt = x({\n        name: \"intersectionParslet\",\n        accept: /* @__PURE__ */r(e => e === \"&\", \"accept\"),\n        precedence: y.INTERSECTION,\n        parseInfix: /* @__PURE__ */r((e, t) => {\n          e.consume(\"&\");\n          let o = [];\n          do o.push(e.parseType(y.INTERSECTION)); while (e.consume(\"&\"));\n          return {\n            type: \"JsdocTypeIntersection\",\n            elements: [J(t), ...o]\n          };\n        }, \"parseInfix\")\n      }),\n      er = x({\n        name: \"predicateParslet\",\n        precedence: y.INFIX,\n        accept: /* @__PURE__ */r(e => e === \"is\", \"accept\"),\n        parseInfix: /* @__PURE__ */r((e, t) => {\n          if (t.type !== \"JsdocTypeName\") throw new c(t, \"A typescript predicate always has to have a name on the left side.\");\n          return e.consume(\"is\"), {\n            type: \"JsdocTypePredicate\",\n            left: t,\n            right: J(e.parseIntermediateType(y.INFIX))\n          };\n        }, \"parseInfix\")\n      }),\n      tr = x({\n        name: \"objectSquareBracketPropertyParslet\",\n        accept: /* @__PURE__ */r(e => e === \"[\", \"accept\"),\n        parsePrefix: /* @__PURE__ */r(e => {\n          if (e.baseParser === void 0) throw new Error(\"Only allowed inside object grammar\");\n          e.consume(\"[\");\n          let t = e.lexer.current.text;\n          e.consume(\"Identifier\");\n          let o;\n          if (e.consume(\":\")) {\n            let i = e.baseParser;\n            i.acceptLexerState(e), o = {\n              type: \"JsdocTypeIndexSignature\",\n              key: t,\n              right: i.parseType(y.INDEX_BRACKETS)\n            }, e.acceptLexerState(i);\n          } else if (e.consume(\"in\")) {\n            let i = e.baseParser;\n            i.acceptLexerState(e), o = {\n              type: \"JsdocTypeMappedType\",\n              key: t,\n              right: i.parseType(y.ARRAY_BRACKETS)\n            }, e.acceptLexerState(i);\n          } else throw new Error(\"Missing ':' or 'in' inside square bracketed property.\");\n          if (!e.consume(\"]\")) throw new Error(\"Unterminated square brackets\");\n          return o;\n        }, \"parsePrefix\")\n      }),\n      rr = [Ht, R({\n        allowedAdditionalTokens: [\"module\", \"event\", \"keyof\", \"event\", \"external\", \"in\"]\n      }), we, Q, Y, Z, De({\n        allowSquaredProperties: !0,\n        allowKeyTypes: !1,\n        allowOptional: !0,\n        allowReadonly: !0\n      }), tr],\n      nr = [...Pe, Ne({\n        allowKeyTypes: !1,\n        objectFieldGrammar: rr\n      }), He, Xt, zt, Y, Se({\n        allowWithoutParenthesis: !0,\n        allowNoReturnType: !1,\n        allowNamedParameters: [\"this\", \"new\", \"args\"],\n        allowNewAsFunctionKeyword: !0\n      }), Gt({\n        allowQuestionMark: !1\n      }), Ee({\n        allowEnclosingBrackets: !1,\n        allowPostfix: !1\n      }), Wt, R({\n        allowedAdditionalTokens: [\"event\", \"external\", \"in\"]\n      }), te({\n        allowedTypes: [\"module\"],\n        pathGrammar: L\n      }), Xe, Qt, ee({\n        allowSquareBracketsOnAnyType: !0,\n        allowJsdocNamePaths: !1,\n        pathGrammar: L\n      }), Zt, er, Oe({\n        allowVariadic: !0,\n        allowOptional: !0\n      })];\n    function Qe(e, t) {\n      switch (t) {\n        case \"closure\":\n          return new I(Yt, e).parse();\n        case \"jsdoc\":\n          return new I($t, e).parse();\n        case \"typescript\":\n          return new I(nr, e).parse();\n      }\n    }\n    r(Qe, \"parse\");\n    function or(e, t = [\"typescript\", \"closure\", \"jsdoc\"]) {\n      let o;\n      for (let i of t) try {\n        return Qe(e, i);\n      } catch (l) {\n        o = l;\n      }\n      throw o;\n    }\n    r(or, \"tryParse\");\n    function W(e, t) {\n      let o = e[t.type];\n      if (o === void 0) throw new Error(`In this set of transform rules exists no rule for type ${t.type}.`);\n      return o(t, i => W(e, i));\n    }\n    r(W, \"transform\");\n    function N(e) {\n      throw new Error(\"This transform is not available. Are you trying the correct parsing mode?\");\n    }\n    r(N, \"notAvailableTransform\");\n    function Ze(e) {\n      let t = {\n        params: []\n      };\n      for (let o of e.parameters) o.type === \"JsdocTypeKeyValue\" ? o.key === \"this\" ? t.this = o.right : o.key === \"new\" ? t.new = o.right : t.params.push(o) : t.params.push(o);\n      return t;\n    }\n    r(Ze, \"extractSpecialParams\");\n    function re(e, t, o) {\n      return e === \"prefix\" ? o + t : t + o;\n    }\n    r(re, \"applyPosition\");\n    function j(e, t) {\n      switch (t) {\n        case \"double\":\n          return `\"${e}\"`;\n        case \"single\":\n          return `'${e}'`;\n        case void 0:\n          return e;\n      }\n    }\n    r(j, \"quote\");\n    function et() {\n      return {\n        JsdocTypeParenthesis: /* @__PURE__ */r((e, t) => `(${e.element !== void 0 ? t(e.element) : \"\"})`, \"JsdocTypeParenthesis\"),\n        JsdocTypeKeyof: /* @__PURE__ */r((e, t) => `keyof ${t(e.element)}`, \"JsdocTypeKeyof\"),\n        JsdocTypeFunction: /* @__PURE__ */r((e, t) => {\n          if (e.arrow) {\n            if (e.returnType === void 0) throw new Error(\"Arrow function needs a return type.\");\n            let o = `(${e.parameters.map(t).join(\", \")}) => ${t(e.returnType)}`;\n            return e.constructor && (o = \"new \" + o), o;\n          } else {\n            let o = e.constructor ? \"new\" : \"function\";\n            return e.parenthesis && (o += `(${e.parameters.map(t).join(\", \")})`, e.returnType !== void 0 && (o += `: ${t(e.returnType)}`)), o;\n          }\n        }, \"JsdocTypeFunction\"),\n        JsdocTypeName: /* @__PURE__ */r(e => e.value, \"JsdocTypeName\"),\n        JsdocTypeTuple: /* @__PURE__ */r((e, t) => `[${e.elements.map(t).join(\", \")}]`, \"JsdocTypeTuple\"),\n        JsdocTypeVariadic: /* @__PURE__ */r((e, t) => e.meta.position === void 0 ? \"...\" : re(e.meta.position, t(e.element), \"...\"), \"Jsdoc\\\nTypeVariadic\"),\n        JsdocTypeNamePath: /* @__PURE__ */r((e, t) => {\n          let o = t(e.left),\n            i = t(e.right);\n          switch (e.pathType) {\n            case \"inner\":\n              return `${o}~${i}`;\n            case \"instance\":\n              return `${o}#${i}`;\n            case \"property\":\n              return `${o}.${i}`;\n            case \"property-brackets\":\n              return `${o}[${i}]`;\n          }\n        }, \"JsdocTypeNamePath\"),\n        JsdocTypeStringValue: /* @__PURE__ */r(e => j(e.value, e.meta.quote), \"JsdocTypeStringValue\"),\n        JsdocTypeAny: /* @__PURE__ */r(() => \"*\", \"JsdocTypeAny\"),\n        JsdocTypeGeneric: /* @__PURE__ */r((e, t) => {\n          if (e.meta.brackets === \"square\") {\n            let o = e.elements[0],\n              i = t(o);\n            return o.type === \"JsdocTypeUnion\" || o.type === \"JsdocTypeIntersection\" ? `(${i})[]` : `${i}[]`;\n          } else return `${t(e.left)}${e.meta.dot ? \".\" : \"\"}<${e.elements.map(t).join(\", \")}>`;\n        }, \"JsdocTypeGeneric\"),\n        JsdocTypeImport: /* @__PURE__ */r((e, t) => `import(${t(e.element)})`, \"JsdocTypeImport\"),\n        JsdocTypeObjectField: /* @__PURE__ */r((e, t) => {\n          let o = \"\";\n          return e.readonly && (o += \"readonly \"), typeof e.key == \"string\" ? o += j(e.key, e.meta.quote) : o += t(e.key), e.optional && (o += \"?\"), e.right === void 0 ? o : o + `: ${t(e.right)}`;\n        }, \"JsdocTypeObjectField\"),\n        JsdocTypeJsdocObjectField: /* @__PURE__ */r((e, t) => `${t(e.left)}: ${t(e.right)}`, \"JsdocTypeJsdocObjectField\"),\n        JsdocTypeKeyValue: /* @__PURE__ */r((e, t) => {\n          let o = e.key;\n          return e.optional && (o += \"?\"), e.variadic && (o = \"...\" + o), e.right === void 0 ? o : o + `: ${t(e.right)}`;\n        }, \"JsdocTypeKeyValue\"),\n        JsdocTypeSpecialNamePath: /* @__PURE__ */r(e => `${e.specialType}:${j(e.value, e.meta.quote)}`, \"JsdocTypeSpecialNamePath\"),\n        JsdocTypeNotNullable: /* @__PURE__ */r((e, t) => re(e.meta.position, t(e.element), \"!\"), \"JsdocTypeNotNullable\"),\n        JsdocTypeNull: /* @__PURE__ */r(() => \"null\", \"JsdocTypeNull\"),\n        JsdocTypeNullable: /* @__PURE__ */r((e, t) => re(e.meta.position, t(e.element), \"?\"), \"JsdocTypeNullable\"),\n        JsdocTypeNumber: /* @__PURE__ */r(e => e.value.toString(), \"JsdocTypeNumber\"),\n        JsdocTypeObject: /* @__PURE__ */r((e, t) => `{${e.elements.map(t).join((e.meta.separator === \"comma\" ? \",\" : \";\") + \" \")}}`, \"Jsdoc\\\nTypeObject\"),\n        JsdocTypeOptional: /* @__PURE__ */r((e, t) => re(e.meta.position, t(e.element), \"=\"), \"JsdocTypeOptional\"),\n        JsdocTypeSymbol: /* @__PURE__ */r((e, t) => `${e.value}(${e.element !== void 0 ? t(e.element) : \"\"})`, \"JsdocTypeSymbol\"),\n        JsdocTypeTypeof: /* @__PURE__ */r((e, t) => `typeof ${t(e.element)}`, \"JsdocTypeTypeof\"),\n        JsdocTypeUndefined: /* @__PURE__ */r(() => \"undefined\", \"JsdocTypeUndefined\"),\n        JsdocTypeUnion: /* @__PURE__ */r((e, t) => e.elements.map(t).join(\" | \"), \"JsdocTypeUnion\"),\n        JsdocTypeUnknown: /* @__PURE__ */r(() => \"?\", \"JsdocTypeUnknown\"),\n        JsdocTypeIntersection: /* @__PURE__ */r((e, t) => e.elements.map(t).join(\" & \"), \"JsdocTypeIntersection\"),\n        JsdocTypeProperty: /* @__PURE__ */r(e => j(e.value, e.meta.quote), \"JsdocTypeProperty\"),\n        JsdocTypePredicate: /* @__PURE__ */r((e, t) => `${t(e.left)} is ${t(e.right)}`, \"JsdocTypePredicate\"),\n        JsdocTypeIndexSignature: /* @__PURE__ */r((e, t) => `[${e.key}: ${t(e.right)}]`, \"JsdocTypeIndexSignature\"),\n        JsdocTypeMappedType: /* @__PURE__ */r((e, t) => `[${e.key} in ${t(e.right)}]`, \"JsdocTypeMappedType\"),\n        JsdocTypeAsserts: /* @__PURE__ */r((e, t) => `asserts ${t(e.left)} is ${t(e.right)}`, \"JsdocTypeAsserts\")\n      };\n    }\n    r(et, \"stringifyRules\");\n    let sr = et();\n    function ar(e) {\n      return W(sr, e);\n    }\n    r(ar, \"stringify\");\n    let ir = [\"null\", \"true\", \"false\", \"break\", \"case\", \"catch\", \"class\", \"const\", \"continue\", \"debugger\", \"default\", \"delete\", \"do\", \"else\", \"export\", \"extends\", \"finally\", \"for\", \"function\", \"if\", \"import\", \"in\", \"instanceof\", \"new\", \"return\", \"super\", \"switch\", \"this\", \"throw\", \"try\", \"typeof\", \"var\", \"void\", \"while\", \"with\", \"yield\"];\n    function F(e) {\n      let t = {\n        type: \"NameExpression\",\n        name: e\n      };\n      return ir.includes(e) && (t.reservedWord = !0), t;\n    }\n    r(F, \"makeName\");\n    let pr = {\n      JsdocTypeOptional: /* @__PURE__ */r((e, t) => {\n        let o = t(e.element);\n        return o.optional = !0, o;\n      }, \"JsdocTypeOptional\"),\n      JsdocTypeNullable: /* @__PURE__ */r((e, t) => {\n        let o = t(e.element);\n        return o.nullable = !0, o;\n      }, \"JsdocTypeNullable\"),\n      JsdocTypeNotNullable: /* @__PURE__ */r((e, t) => {\n        let o = t(e.element);\n        return o.nullable = !1, o;\n      }, \"JsdocTypeNotNullable\"),\n      JsdocTypeVariadic: /* @__PURE__ */r((e, t) => {\n        if (e.element === void 0) throw new Error(\"dots without value are not allowed in catharsis mode\");\n        let o = t(e.element);\n        return o.repeatable = !0, o;\n      }, \"JsdocTypeVariadic\"),\n      JsdocTypeAny: /* @__PURE__ */r(() => ({\n        type: \"AllLiteral\"\n      }), \"JsdocTypeAny\"),\n      JsdocTypeNull: /* @__PURE__ */r(() => ({\n        type: \"NullLiteral\"\n      }), \"JsdocTypeNull\"),\n      JsdocTypeStringValue: /* @__PURE__ */r(e => F(j(e.value, e.meta.quote)), \"JsdocTypeStringValue\"),\n      JsdocTypeUndefined: /* @__PURE__ */r(() => ({\n        type: \"UndefinedLiteral\"\n      }), \"JsdocTypeUndefined\"),\n      JsdocTypeUnknown: /* @__PURE__ */r(() => ({\n        type: \"UnknownLiteral\"\n      }), \"JsdocTypeUnknown\"),\n      JsdocTypeFunction: /* @__PURE__ */r((e, t) => {\n        let o = Ze(e),\n          i = {\n            type: \"FunctionType\",\n            params: o.params.map(t)\n          };\n        return o.this !== void 0 && (i.this = t(o.this)), o.new !== void 0 && (i.new = t(o.new)), e.returnType !== void 0 && (i.result = t(e.returnType)), i;\n      }, \"JsdocTypeFunction\"),\n      JsdocTypeGeneric: /* @__PURE__ */r((e, t) => ({\n        type: \"TypeApplication\",\n        applications: e.elements.map(o => t(o)),\n        expression: t(e.left)\n      }), \"JsdocTypeGeneric\"),\n      JsdocTypeSpecialNamePath: /* @__PURE__ */r(e => F(e.specialType + \":\" + j(e.value, e.meta.quote)), \"JsdocTypeSpecialNamePath\"),\n      JsdocTypeName: /* @__PURE__ */r(e => e.value !== \"function\" ? F(e.value) : {\n        type: \"FunctionType\",\n        params: []\n      }, \"JsdocTypeName\"),\n      JsdocTypeNumber: /* @__PURE__ */r(e => F(e.value.toString()), \"JsdocTypeNumber\"),\n      JsdocTypeObject: /* @__PURE__ */r((e, t) => {\n        let o = {\n          type: \"RecordType\",\n          fields: []\n        };\n        for (let i of e.elements) i.type !== \"JsdocTypeObjectField\" && i.type !== \"JsdocTypeJsdocObjectField\" ? o.fields.push({\n          type: \"FieldType\",\n          key: t(i),\n          value: void 0\n        }) : o.fields.push(t(i));\n        return o;\n      }, \"JsdocTypeObject\"),\n      JsdocTypeObjectField: /* @__PURE__ */r((e, t) => {\n        if (typeof e.key != \"string\") throw new Error(\"Index signatures and mapped types are not supported\");\n        return {\n          type: \"FieldType\",\n          key: F(j(e.key, e.meta.quote)),\n          value: e.right === void 0 ? void 0 : t(e.right)\n        };\n      }, \"JsdocTypeObjectField\"),\n      JsdocTypeJsdocObjectField: /* @__PURE__ */r((e, t) => ({\n        type: \"FieldType\",\n        key: t(e.left),\n        value: t(e.right)\n      }), \"JsdocTypeJsdocObjectField\"),\n      JsdocTypeUnion: /* @__PURE__ */r((e, t) => ({\n        type: \"TypeUnion\",\n        elements: e.elements.map(o => t(o))\n      }), \"JsdocTypeUnion\"),\n      JsdocTypeKeyValue: /* @__PURE__ */r((e, t) => ({\n        type: \"FieldType\",\n        key: F(e.key),\n        value: e.right === void 0 ? void 0 : t(e.right)\n      }), \"JsdocTypeKeyValue\"),\n      JsdocTypeNamePath: /* @__PURE__ */r((e, t) => {\n        let o = t(e.left),\n          i;\n        e.right.type === \"JsdocTypeSpecialNamePath\" ? i = t(e.right).name : i = j(e.right.value, e.right.meta.quote);\n        let l = e.pathType === \"inner\" ? \"~\" : e.pathType === \"instance\" ? \"#\" : \".\";\n        return F(`${o.name}${l}${i}`);\n      }, \"JsdocTypeNamePath\"),\n      JsdocTypeSymbol: /* @__PURE__ */r(e => {\n        let t = \"\",\n          o = e.element,\n          i = !1;\n        return o?.type === \"JsdocTypeVariadic\" && (o.meta.position === \"prefix\" ? t = \"...\" : i = !0, o = o.element), o?.type === \"JsdocType\\\nName\" ? t += o.value : o?.type === \"JsdocTypeNumber\" && (t += o.value.toString()), i && (t += \"...\"), F(`${e.value}(${t})`);\n      }, \"JsdocTypeSymbol\"),\n      JsdocTypeParenthesis: /* @__PURE__ */r((e, t) => t(J(e.element)), \"JsdocTypeParenthesis\"),\n      JsdocTypeMappedType: N,\n      JsdocTypeIndexSignature: N,\n      JsdocTypeImport: N,\n      JsdocTypeKeyof: N,\n      JsdocTypeTuple: N,\n      JsdocTypeTypeof: N,\n      JsdocTypeIntersection: N,\n      JsdocTypeProperty: N,\n      JsdocTypePredicate: N,\n      JsdocTypeAsserts: N\n    };\n    function cr(e) {\n      return W(pr, e);\n    }\n    r(cr, \"catharsisTransform\");\n    function V(e) {\n      switch (e) {\n        case void 0:\n          return \"none\";\n        case \"single\":\n          return \"single\";\n        case \"double\":\n          return \"double\";\n      }\n    }\n    r(V, \"getQuoteStyle\");\n    function lr(e) {\n      switch (e) {\n        case \"inner\":\n          return \"INNER_MEMBER\";\n        case \"instance\":\n          return \"INSTANCE_MEMBER\";\n        case \"property\":\n          return \"MEMBER\";\n        case \"property-brackets\":\n          return \"MEMBER\";\n      }\n    }\n    r(lr, \"getMemberType\");\n    function ve(e, t) {\n      return t.length === 2 ? {\n        type: e,\n        left: t[0],\n        right: t[1]\n      } : {\n        type: e,\n        left: t[0],\n        right: ve(e, t.slice(1))\n      };\n    }\n    r(ve, \"nestResults\");\n    let ur = {\n      JsdocTypeOptional: /* @__PURE__ */r((e, t) => ({\n        type: \"OPTIONAL\",\n        value: t(e.element),\n        meta: {\n          syntax: e.meta.position === \"prefix\" ? \"PREFIX_EQUAL_SIGN\" : \"SUFFIX_EQUALS_SIGN\"\n        }\n      }), \"JsdocTypeOptional\"),\n      JsdocTypeNullable: /* @__PURE__ */r((e, t) => ({\n        type: \"NULLABLE\",\n        value: t(e.element),\n        meta: {\n          syntax: e.meta.position === \"prefix\" ? \"PREFIX_QUESTION_MARK\" : \"SUFFIX_QUESTION_MARK\"\n        }\n      }), \"JsdocTypeNullable\"),\n      JsdocTypeNotNullable: /* @__PURE__ */r((e, t) => ({\n        type: \"NOT_NULLABLE\",\n        value: t(e.element),\n        meta: {\n          syntax: e.meta.position === \"prefix\" ? \"PREFIX_BANG\" : \"SUFFIX_BANG\"\n        }\n      }), \"JsdocTypeNotNullable\"),\n      JsdocTypeVariadic: /* @__PURE__ */r((e, t) => {\n        let o = {\n          type: \"VARIADIC\",\n          meta: {\n            syntax: e.meta.position === \"prefix\" ? \"PREFIX_DOTS\" : e.meta.position === \"suffix\" ? \"SUFFIX_DOTS\" : \"ONLY_DOTS\"\n          }\n        };\n        return e.element !== void 0 && (o.value = t(e.element)), o;\n      }, \"JsdocTypeVariadic\"),\n      JsdocTypeName: /* @__PURE__ */r(e => ({\n        type: \"NAME\",\n        name: e.value\n      }), \"JsdocTypeName\"),\n      JsdocTypeTypeof: /* @__PURE__ */r((e, t) => ({\n        type: \"TYPE_QUERY\",\n        name: t(e.element)\n      }), \"JsdocTypeTypeof\"),\n      JsdocTypeTuple: /* @__PURE__ */r((e, t) => ({\n        type: \"TUPLE\",\n        entries: e.elements.map(t)\n      }), \"JsdocTypeTuple\"),\n      JsdocTypeKeyof: /* @__PURE__ */r((e, t) => ({\n        type: \"KEY_QUERY\",\n        value: t(e.element)\n      }), \"JsdocTypeKeyof\"),\n      JsdocTypeImport: /* @__PURE__ */r(e => ({\n        type: \"IMPORT\",\n        path: {\n          type: \"STRING_VALUE\",\n          quoteStyle: V(e.element.meta.quote),\n          string: e.element.value\n        }\n      }), \"JsdocTypeImport\"),\n      JsdocTypeUndefined: /* @__PURE__ */r(() => ({\n        type: \"NAME\",\n        name: \"undefined\"\n      }), \"JsdocTypeUndefined\"),\n      JsdocTypeAny: /* @__PURE__ */r(() => ({\n        type: \"ANY\"\n      }), \"JsdocTypeAny\"),\n      JsdocTypeFunction: /* @__PURE__ */r((e, t) => {\n        let o = Ze(e),\n          i = {\n            type: e.arrow ? \"ARROW\" : \"FUNCTION\",\n            params: o.params.map(l => {\n              if (l.type === \"JsdocTypeKeyValue\") {\n                if (l.right === void 0) throw new Error(\"Function parameter without ':' is not expected to be 'KEY_VALUE'\");\n                return {\n                  type: \"NAMED_PARAMETER\",\n                  name: l.key,\n                  typeName: t(l.right)\n                };\n              } else return t(l);\n            }),\n            new: null,\n            returns: null\n          };\n        return o.this !== void 0 ? i.this = t(o.this) : e.arrow || (i.this = null), o.new !== void 0 && (i.new = t(o.new)), e.returnType !== void 0 && (i.returns = t(e.returnType)), i;\n      }, \"JsdocTypeFunction\"),\n      JsdocTypeGeneric: /* @__PURE__ */r((e, t) => {\n        let o = {\n          type: \"GENERIC\",\n          subject: t(e.left),\n          objects: e.elements.map(t),\n          meta: {\n            syntax: e.meta.brackets === \"square\" ? \"SQUARE_BRACKET\" : e.meta.dot ? \"ANGLE_BRACKET_WITH_DOT\" : \"ANGLE_BRACKET\"\n          }\n        };\n        return e.meta.brackets === \"square\" && e.elements[0].type === \"JsdocTypeFunction\" && !e.elements[0].parenthesis && (o.objects[0] = {\n          type: \"NAME\",\n          name: \"function\"\n        }), o;\n      }, \"JsdocTypeGeneric\"),\n      JsdocTypeObjectField: /* @__PURE__ */r((e, t) => {\n        if (typeof e.key != \"string\") throw new Error(\"Index signatures and mapped types are not supported\");\n        if (e.right === void 0) return {\n          type: \"RECORD_ENTRY\",\n          key: e.key,\n          quoteStyle: V(e.meta.quote),\n          value: null,\n          readonly: !1\n        };\n        let o = t(e.right);\n        return e.optional && (o = {\n          type: \"OPTIONAL\",\n          value: o,\n          meta: {\n            syntax: \"SUFFIX_KEY_QUESTION_MARK\"\n          }\n        }), {\n          type: \"RECORD_ENTRY\",\n          key: e.key.toString(),\n          quoteStyle: V(e.meta.quote),\n          value: o,\n          readonly: !1\n        };\n      }, \"JsdocTypeObjectField\"),\n      JsdocTypeJsdocObjectField: /* @__PURE__ */r(() => {\n        throw new Error(\"Keys may not be typed in jsdoctypeparser.\");\n      }, \"JsdocTypeJsdocObjectField\"),\n      JsdocTypeKeyValue: /* @__PURE__ */r((e, t) => {\n        if (e.right === void 0) return {\n          type: \"RECORD_ENTRY\",\n          key: e.key,\n          quoteStyle: \"none\",\n          value: null,\n          readonly: !1\n        };\n        let o = t(e.right);\n        return e.optional && (o = {\n          type: \"OPTIONAL\",\n          value: o,\n          meta: {\n            syntax: \"SUFFIX_KEY_QUESTION_MARK\"\n          }\n        }), {\n          type: \"RECORD_ENTRY\",\n          key: e.key,\n          quoteStyle: \"none\",\n          value: o,\n          readonly: !1\n        };\n      }, \"JsdocTypeKeyValue\"),\n      JsdocTypeObject: /* @__PURE__ */r((e, t) => {\n        let o = [];\n        for (let i of e.elements) (i.type === \"JsdocTypeObjectField\" || i.type === \"JsdocTypeJsdocObjectField\") && o.push(t(i));\n        return {\n          type: \"RECORD\",\n          entries: o\n        };\n      }, \"JsdocTypeObject\"),\n      JsdocTypeSpecialNamePath: /* @__PURE__ */r(e => {\n        if (e.specialType !== \"module\") throw new Error(`jsdoctypeparser does not support type ${e.specialType} at this point.`);\n        return {\n          type: \"MODULE\",\n          value: {\n            type: \"FILE_PATH\",\n            quoteStyle: V(e.meta.quote),\n            path: e.value\n          }\n        };\n      }, \"JsdocTypeSpecialNamePath\"),\n      JsdocTypeNamePath: /* @__PURE__ */r((e, t) => {\n        let o = !1,\n          i,\n          l;\n        e.right.type === \"JsdocTypeSpecialNamePath\" && e.right.specialType === \"event\" ? (o = !0, i = e.right.value, l = V(e.right.meta.quote)) : (i = e.right.value, l = V(e.right.meta.quote));\n        let f = {\n          type: lr(e.pathType),\n          owner: t(e.left),\n          name: i,\n          quoteStyle: l,\n          hasEventPrefix: o\n        };\n        if (f.owner.type === \"MODULE\") {\n          let d = f.owner;\n          return f.owner = f.owner.value, d.value = f, d;\n        } else return f;\n      }, \"JsdocTypeNamePath\"),\n      JsdocTypeUnion: /* @__PURE__ */r((e, t) => ve(\"UNION\", e.elements.map(t)), \"JsdocTypeUnion\"),\n      JsdocTypeParenthesis: /* @__PURE__ */r((e, t) => ({\n        type: \"PARENTHESIS\",\n        value: t(J(e.element))\n      }), \"JsdocTypeParenthesis\"),\n      JsdocTypeNull: /* @__PURE__ */r(() => ({\n        type: \"NAME\",\n        name: \"null\"\n      }), \"JsdocTypeNull\"),\n      JsdocTypeUnknown: /* @__PURE__ */r(() => ({\n        type: \"UNKNOWN\"\n      }), \"JsdocTypeUnknown\"),\n      JsdocTypeStringValue: /* @__PURE__ */r(e => ({\n        type: \"STRING_VALUE\",\n        quoteStyle: V(e.meta.quote),\n        string: e.value\n      }), \"JsdocTypeStringValue\"),\n      JsdocTypeIntersection: /* @__PURE__ */r((e, t) => ve(\"INTERSECTION\", e.elements.map(t)), \"JsdocTypeIntersection\"),\n      JsdocTypeNumber: /* @__PURE__ */r(e => ({\n        type: \"NUMBER_VALUE\",\n        number: e.value.toString()\n      }), \"JsdocTypeNumber\"),\n      JsdocTypeSymbol: N,\n      JsdocTypeProperty: N,\n      JsdocTypePredicate: N,\n      JsdocTypeMappedType: N,\n      JsdocTypeIndexSignature: N,\n      JsdocTypeAsserts: N\n    };\n    function mr(e) {\n      return W(ur, e);\n    }\n    r(mr, \"jtpTransform\");\n    function fr() {\n      return {\n        JsdocTypeIntersection: /* @__PURE__ */r((e, t) => ({\n          type: \"JsdocTypeIntersection\",\n          elements: e.elements.map(t)\n        }), \"JsdocTypeIntersection\"),\n        JsdocTypeGeneric: /* @__PURE__ */r((e, t) => ({\n          type: \"JsdocTypeGeneric\",\n          left: t(e.left),\n          elements: e.elements.map(t),\n          meta: {\n            dot: e.meta.dot,\n            brackets: e.meta.brackets\n          }\n        }), \"JsdocTypeGeneric\"),\n        JsdocTypeNullable: /* @__PURE__ */r(e => e, \"JsdocTypeNullable\"),\n        JsdocTypeUnion: /* @__PURE__ */r((e, t) => ({\n          type: \"JsdocTypeUnion\",\n          elements: e.elements.map(t)\n        }), \"JsdocTypeUnion\"),\n        JsdocTypeUnknown: /* @__PURE__ */r(e => e, \"JsdocTypeUnknown\"),\n        JsdocTypeUndefined: /* @__PURE__ */r(e => e, \"JsdocTypeUndefined\"),\n        JsdocTypeTypeof: /* @__PURE__ */r((e, t) => ({\n          type: \"JsdocTypeTypeof\",\n          element: t(e.element)\n        }), \"JsdocTypeTypeof\"),\n        JsdocTypeSymbol: /* @__PURE__ */r((e, t) => {\n          let o = {\n            type: \"JsdocTypeSymbol\",\n            value: e.value\n          };\n          return e.element !== void 0 && (o.element = t(e.element)), o;\n        }, \"JsdocTypeSymbol\"),\n        JsdocTypeOptional: /* @__PURE__ */r((e, t) => ({\n          type: \"JsdocTypeOptional\",\n          element: t(e.element),\n          meta: {\n            position: e.meta.position\n          }\n        }), \"JsdocTypeOptional\"),\n        JsdocTypeObject: /* @__PURE__ */r((e, t) => ({\n          type: \"JsdocTypeObject\",\n          meta: {\n            separator: \"comma\"\n          },\n          elements: e.elements.map(t)\n        }), \"JsdocTypeObject\"),\n        JsdocTypeNumber: /* @__PURE__ */r(e => e, \"JsdocTypeNumber\"),\n        JsdocTypeNull: /* @__PURE__ */r(e => e, \"JsdocTypeNull\"),\n        JsdocTypeNotNullable: /* @__PURE__ */r((e, t) => ({\n          type: \"JsdocTypeNotNullable\",\n          element: t(e.element),\n          meta: {\n            position: e.meta.position\n          }\n        }), \"JsdocTypeNotNullable\"),\n        JsdocTypeSpecialNamePath: /* @__PURE__ */r(e => e, \"JsdocTypeSpecialNamePath\"),\n        JsdocTypeObjectField: /* @__PURE__ */r((e, t) => ({\n          type: \"JsdocTypeObjectField\",\n          key: e.key,\n          right: e.right === void 0 ? void 0 : t(e.right),\n          optional: e.optional,\n          readonly: e.readonly,\n          meta: e.meta\n        }), \"JsdocTypeObjectField\"),\n        JsdocTypeJsdocObjectField: /* @__PURE__ */r((e, t) => ({\n          type: \"JsdocTypeJsdocObjectField\",\n          left: t(e.left),\n          right: t(e.right)\n        }), \"JsdocTypeJsdocObjectField\"),\n        JsdocTypeKeyValue: /* @__PURE__ */r((e, t) => ({\n          type: \"JsdocTypeKeyValue\",\n          key: e.key,\n          right: e.right === void 0 ? void 0 : t(e.right),\n          optional: e.optional,\n          variadic: e.variadic\n        }), \"JsdocTypeKeyValue\"),\n        JsdocTypeImport: /* @__PURE__ */r((e, t) => ({\n          type: \"JsdocTypeImport\",\n          element: t(e.element)\n        }), \"JsdocTypeImport\"),\n        JsdocTypeAny: /* @__PURE__ */r(e => e, \"JsdocTypeAny\"),\n        JsdocTypeStringValue: /* @__PURE__ */r(e => e, \"JsdocTypeStringValue\"),\n        JsdocTypeNamePath: /* @__PURE__ */r(e => e, \"JsdocTypeNamePath\"),\n        JsdocTypeVariadic: /* @__PURE__ */r((e, t) => {\n          let o = {\n            type: \"JsdocTypeVariadic\",\n            meta: {\n              position: e.meta.position,\n              squareBrackets: e.meta.squareBrackets\n            }\n          };\n          return e.element !== void 0 && (o.element = t(e.element)), o;\n        }, \"JsdocTypeVariadic\"),\n        JsdocTypeTuple: /* @__PURE__ */r((e, t) => ({\n          type: \"JsdocTypeTuple\",\n          elements: e.elements.map(t)\n        }), \"JsdocTypeTuple\"),\n        JsdocTypeName: /* @__PURE__ */r(e => e, \"JsdocTypeName\"),\n        JsdocTypeFunction: /* @__PURE__ */r((e, t) => {\n          let o = {\n            type: \"JsdocTypeFunction\",\n            arrow: e.arrow,\n            parameters: e.parameters.map(t),\n            constructor: e.constructor,\n            parenthesis: e.parenthesis\n          };\n          return e.returnType !== void 0 && (o.returnType = t(e.returnType)), o;\n        }, \"JsdocTypeFunction\"),\n        JsdocTypeKeyof: /* @__PURE__ */r((e, t) => ({\n          type: \"JsdocTypeKeyof\",\n          element: t(e.element)\n        }), \"JsdocTypeKeyof\"),\n        JsdocTypeParenthesis: /* @__PURE__ */r((e, t) => ({\n          type: \"JsdocTypeParenthesis\",\n          element: t(e.element)\n        }), \"JsdocTypeParenthesis\"),\n        JsdocTypeProperty: /* @__PURE__ */r(e => e, \"JsdocTypeProperty\"),\n        JsdocTypePredicate: /* @__PURE__ */r((e, t) => ({\n          type: \"JsdocTypePredicate\",\n          left: t(e.left),\n          right: t(e.right)\n        }), \"JsdocTypePredicate\"),\n        JsdocTypeIndexSignature: /* @__PURE__ */r((e, t) => ({\n          type: \"JsdocTypeIndexSignature\",\n          key: e.key,\n          right: t(e.right)\n        }), \"JsdocTypeIndexSignature\"),\n        JsdocTypeMappedType: /* @__PURE__ */r((e, t) => ({\n          type: \"JsdocTypeMappedType\",\n          key: e.key,\n          right: t(e.right)\n        }), \"JsdocTypeMappedType\"),\n        JsdocTypeAsserts: /* @__PURE__ */r((e, t) => ({\n          type: \"JsdocTypeAsserts\",\n          left: t(e.left),\n          right: t(e.right)\n        }), \"JsdocTypeAsserts\")\n      };\n    }\n    r(fr, \"identityTransformRules\");\n    let tt = {\n      JsdocTypeAny: [],\n      JsdocTypeFunction: [\"parameters\", \"returnType\"],\n      JsdocTypeGeneric: [\"left\", \"elements\"],\n      JsdocTypeImport: [],\n      JsdocTypeIndexSignature: [\"right\"],\n      JsdocTypeIntersection: [\"elements\"],\n      JsdocTypeKeyof: [\"element\"],\n      JsdocTypeKeyValue: [\"right\"],\n      JsdocTypeMappedType: [\"right\"],\n      JsdocTypeName: [],\n      JsdocTypeNamePath: [\"left\", \"right\"],\n      JsdocTypeNotNullable: [\"element\"],\n      JsdocTypeNull: [],\n      JsdocTypeNullable: [\"element\"],\n      JsdocTypeNumber: [],\n      JsdocTypeObject: [\"elements\"],\n      JsdocTypeObjectField: [\"right\"],\n      JsdocTypeJsdocObjectField: [\"left\", \"right\"],\n      JsdocTypeOptional: [\"element\"],\n      JsdocTypeParenthesis: [\"element\"],\n      JsdocTypeSpecialNamePath: [],\n      JsdocTypeStringValue: [],\n      JsdocTypeSymbol: [\"element\"],\n      JsdocTypeTuple: [\"elements\"],\n      JsdocTypeTypeof: [\"element\"],\n      JsdocTypeUndefined: [],\n      JsdocTypeUnion: [\"elements\"],\n      JsdocTypeUnknown: [],\n      JsdocTypeVariadic: [\"element\"],\n      JsdocTypeProperty: [],\n      JsdocTypePredicate: [\"left\", \"right\"],\n      JsdocTypeAsserts: [\"left\", \"right\"]\n    };\n    function ke(e, t, o, i, l) {\n      i?.(e, t, o);\n      let f = tt[e.type];\n      for (let d of f) {\n        let h = e[d];\n        if (h !== void 0) if (Array.isArray(h)) for (let D of h) ke(D, e, d, i, l);else ke(h, e, d, i, l);\n      }\n      l?.(e, t, o);\n    }\n    r(ke, \"_traverse\");\n    function yr(e, t, o) {\n      ke(e, void 0, void 0, t, o);\n    }\n    r(yr, \"traverse\"), n.catharsisTransform = cr, n.identityTransformRules = fr, n.jtpTransform = mr, n.parse = Qe, n.stringify = ar, n.stringifyRules = et, n.transform = W, n.traverse = yr, n.tryParse = or, n.visitorKeys = tt;\n  });\n});\n\n// src/docs-tools/argTypes/convert/flow/convert.ts\nimport { UnknownArgTypesError as br } from \"storybook/internal/preview-errors\";\nvar Sr = /* @__PURE__ */r(n => n.name === \"literal\", \"isLiteral\"),\n  Er = /* @__PURE__ */r(n => n.value.replace(/['|\"]/g, \"\"), \"toEnumOp\\\ntion\"),\n  Nr = /* @__PURE__ */r(n => {\n    switch (n.type) {\n      case \"function\":\n        return {\n          name: \"function\"\n        };\n      case \"object\":\n        let s = {};\n        return n.signature.properties.forEach(a => {\n          s[a.key] = B(a.value);\n        }), {\n          name: \"object\",\n          value: s\n        };\n      default:\n        throw new br({\n          type: n,\n          language: \"Flow\"\n        });\n    }\n  }, \"convertSig\"),\n  B = /* @__PURE__ */r(n => {\n    let {\n        name: s,\n        raw: a\n      } = n,\n      p = {};\n    switch (typeof a < \"u\" && (p.raw = a), n.name) {\n      case \"literal\":\n        return {\n          ...p,\n          name: \"other\",\n          value: n.value\n        };\n      case \"string\":\n      case \"number\":\n      case \"symbol\":\n      case \"boolean\":\n        return {\n          ...p,\n          name: s\n        };\n      case \"Array\":\n        return {\n          ...p,\n          name: \"array\",\n          value: n.elements.map(B)\n        };\n      case \"signature\":\n        return {\n          ...p,\n          ...Nr(n)\n        };\n      case \"union\":\n        return n.elements?.every(Sr) ? {\n          ...p,\n          name: \"enum\",\n          value: n.elements?.map(Er)\n        } : {\n          ...p,\n          name: s,\n          value: n.elements?.map(B)\n        };\n      case \"intersection\":\n        return {\n          ...p,\n          name: s,\n          value: n.elements?.map(B)\n        };\n      default:\n        return {\n          ...p,\n          name: \"other\",\n          value: s\n        };\n    }\n  }, \"convert\");\n\n// ../node_modules/es-toolkit/dist/predicate/isPlainObject.mjs\nfunction X(n) {\n  if (!n || typeof n != \"object\") return !1;\n  let s = Object.getPrototypeOf(n);\n  return s === null || s === Object.prototype || Object.getPrototypeOf(s) === null ? Object.prototype.toString.call(n) === \"[object Object]\" : !1;\n}\nr(X, \"isPlainObject\");\n\n// ../node_modules/es-toolkit/dist/object/mapValues.mjs\nfunction Re(n, s) {\n  let a = {},\n    p = Object.keys(n);\n  for (let c = 0; c < p.length; c++) {\n    let u = p[c],\n      m = n[u];\n    a[u] = s(m, u, n);\n  }\n  return a;\n}\nr(Re, \"mapValues\");\n\n// src/docs-tools/argTypes/convert/utils.ts\nvar ot = /^['\"]|['\"]$/g,\n  Dr = /* @__PURE__ */r(n => n.replace(ot, \"\"), \"trimQuotes\"),\n  Or = /* @__PURE__ */r(n => ot.test(n), \"includes\\\nQuotes\"),\n  ie = /* @__PURE__ */r(n => {\n    let s = Dr(n);\n    return Or(n) || Number.isNaN(Number(s)) ? s : Number(s);\n  }, \"parseLiteral\");\n\n// src/docs-tools/argTypes/convert/proptypes/convert.ts\nvar vr = /^\\(.*\\) => /,\n  C = /* @__PURE__ */r(n => {\n    let {\n        name: s,\n        raw: a,\n        computed: p,\n        value: c\n      } = n,\n      u = {};\n    switch (typeof a < \"u\" && (u.raw = a), s) {\n      case \"enum\":\n        {\n          let T = p ? c : c.map(g => ie(g.value));\n          return {\n            ...u,\n            name: s,\n            value: T\n          };\n        }\n      case \"string\":\n      case \"number\":\n      case \"symbol\":\n        return {\n          ...u,\n          name: s\n        };\n      case \"func\":\n        return {\n          ...u,\n          name: \"function\"\n        };\n      case \"bool\":\n      case \"boolean\":\n        return {\n          ...u,\n          name: \"boolean\"\n        };\n      case \"arrayOf\":\n      case \"array\":\n        return {\n          ...u,\n          name: \"array\",\n          value: c && C(c)\n        };\n      case \"object\":\n        return {\n          ...u,\n          name: s\n        };\n      case \"objectOf\":\n        return {\n          ...u,\n          name: s,\n          value: C(c)\n        };\n      case \"shape\":\n      case \"exact\":\n        let m = Re(c, T => C(T));\n        return {\n          ...u,\n          name: \"object\",\n          value: m\n        };\n      case \"union\":\n        return {\n          ...u,\n          name: \"union\",\n          value: c.map(T => C(T))\n        };\n      case \"instanceOf\":\n      case \"element\":\n      case \"elementType\":\n      default:\n        {\n          if (s?.indexOf(\"|\") > 0) try {\n            let P = s.split(\"|\").map(b => JSON.parse(b));\n            return {\n              ...u,\n              name: \"enum\",\n              value: P\n            };\n          } catch {}\n          let T = c ? `${s}(${c})` : s,\n            g = vr.test(s) ? \"function\" : \"other\";\n          return {\n            ...u,\n            name: g,\n            value: T\n          };\n        }\n    }\n  }, \"convert\");\n\n// src/docs-tools/argTypes/convert/typescript/convert.ts\nimport { UnknownArgTypesError as kr } from \"storybook/internal/preview-errors\";\nvar Ar = /* @__PURE__ */r(n => {\n    switch (n.type) {\n      case \"function\":\n        return {\n          name: \"function\"\n        };\n      case \"object\":\n        let s = {};\n        return n.signature.properties.forEach(a => {\n          s[a.key] = M(a.value);\n        }), {\n          name: \"object\",\n          value: s\n        };\n      default:\n        throw new kr({\n          type: n,\n          language: \"Typescript\"\n        });\n    }\n  }, \"convertSig\"),\n  M = /* @__PURE__ */r(n => {\n    let {\n        name: s,\n        raw: a\n      } = n,\n      p = {};\n    switch (typeof a < \"u\" && (p.raw = a), n.name) {\n      case \"string\":\n      case \"number\":\n      case \"symbol\":\n      case \"boolean\":\n        return {\n          ...p,\n          name: s\n        };\n      case \"Array\":\n        return {\n          ...p,\n          name: \"array\",\n          value: n.elements.map(M)\n        };\n      case \"signature\":\n        return {\n          ...p,\n          ...Ar(n)\n        };\n      case \"union\":\n        let c;\n        return n.elements?.every(u => u.name === \"literal\") ? c = {\n          ...p,\n          name: \"enum\",\n          // @ts-expect-error fix types\n          value: n.elements?.map(u => ie(u.value))\n        } : c = {\n          ...p,\n          name: s,\n          value: n.elements?.map(M)\n        }, c;\n      case \"intersection\":\n        return {\n          ...p,\n          name: s,\n          value: n.elements?.map(M)\n        };\n      default:\n        return {\n          ...p,\n          name: \"other\",\n          value: s\n        };\n    }\n  }, \"convert\");\n\n// src/docs-tools/argTypes/convert/index.ts\nvar pe = /* @__PURE__ */r(n => {\n  let {\n    type: s,\n    tsType: a,\n    flowType: p\n  } = n;\n  try {\n    if (s != null) return C(s);\n    if (a != null) return M(a);\n    if (p != null) return B(p);\n  } catch (c) {\n    console.error(c);\n  }\n  return null;\n}, \"convert\");\n\n// src/docs-tools/argTypes/docgen/types.ts\nvar Ir = /* @__PURE__ */(c => (c.JAVASCRIPT = \"JavaScript\", c.FLOW = \"Flow\", c.TYPESCRIPT = \"TypeScript\", c.UNKNOWN = \"Unknown\", c))(Ir || {});\n\n// src/docs-tools/argTypes/docgen/utils/defaultValue.ts\nvar Rr = [\"null\", \"undefined\"];\nfunction K(n) {\n  return Rr.some(s => s === n);\n}\nr(K, \"isDefaultValueBlacklisted\");\n\n// src/docs-tools/argTypes/docgen/utils/string.ts\nvar st = /* @__PURE__ */r(n => {\n  if (!n) return \"\";\n  if (typeof n == \"string\") return n;\n  throw new Error(`Description: expected string, got: ${JSON.stringify(n)}`);\n}, \"str\");\n\n// src/docs-tools/argTypes/docgen/utils/docgenInfo.ts\nfunction at(n) {\n  return !!n.__docgenInfo;\n}\nr(at, \"hasDocgen\");\nfunction it(n) {\n  return n != null && Object.keys(n).length > 0;\n}\nr(it, \"isValidDocgenSection\");\nfunction pt(n, s) {\n  return at(n) ? n.__docgenInfo[s] : null;\n}\nr(pt, \"getDocgenSection\");\nfunction ct(n) {\n  return at(n) ? st(n.__docgenInfo.description) : \"\";\n}\nr(ct, \"getDocgenDescription\");\n\n// ../node_modules/comment-parser/es6/primitives.js\nvar v;\n(function (n) {\n  n.start = \"/**\", n.nostart = \"/***\", n.delim = \"*\", n.end = \"*/\";\n})(v = v || (v = {}));\n\n// ../node_modules/comment-parser/es6/util.js\nfunction je(n) {\n  return /^\\s+$/.test(n);\n}\nr(je, \"isSpace\");\nfunction lt(n) {\n  let s = n.match(/\\r+$/);\n  return s == null ? [\"\", n] : [n.slice(-s[0].length), n.slice(0, -s[0].length)];\n}\nr(lt, \"splitCR\");\nfunction A(n) {\n  let s = n.match(/^\\s+/);\n  return s == null ? [\"\", n] : [n.slice(0, s[0].length), n.slice(s[0].length)];\n}\nr(A, \"splitSpace\");\nfunction ut(n) {\n  return n.split(/\\n/);\n}\nr(ut, \"splitLines\");\nfunction mt(n = {}) {\n  return Object.assign({\n    tag: \"\",\n    name: \"\",\n    type: \"\",\n    optional: !1,\n    description: \"\",\n    problems: [],\n    source: []\n  }, n);\n}\nr(mt, \"seedSpec\");\nfunction Fe(n = {}) {\n  return Object.assign({\n    start: \"\",\n    delimiter: \"\",\n    postDelimiter: \"\",\n    tag: \"\",\n    postTag: \"\",\n    name: \"\",\n    postName: \"\",\n    type: \"\",\n    postType: \"\",\n    description: \"\",\n    end: \"\",\n    lineEnd: \"\"\n  }, n);\n}\nr(Fe, \"seedTokens\");\n\n// ../node_modules/comment-parser/es6/parser/block-parser.js\nvar jr = /^@\\S+/;\nfunction _e({\n  fence: n = \"```\"\n} = {}) {\n  let s = Fr(n),\n    a = /* @__PURE__ */r((p, c) => s(p) ? !c : c, \"toggleFence\");\n  return /* @__PURE__ */r(function (c) {\n    let u = [[]],\n      m = !1;\n    for (let T of c) jr.test(T.tokens.description) && !m ? u.push([T]) : u[u.length - 1].push(T), m = a(T.tokens.description, m);\n    return u;\n  }, \"parseBlock\");\n}\nr(_e, \"getParser\");\nfunction Fr(n) {\n  return typeof n == \"string\" ? s => s.split(n).length % 2 === 0 : n;\n}\nr(Fr, \"getFencer\");\n\n// ../node_modules/comment-parser/es6/parser/source-parser.js\nfunction Ve({\n  startLine: n = 0,\n  markers: s = v\n} = {}) {\n  let a = null,\n    p = n;\n  return /* @__PURE__ */r(function (u) {\n    let m = u,\n      T = Fe();\n    if ([T.lineEnd, m] = lt(m), [T.start, m] = A(m), a === null && m.startsWith(s.start) && !m.startsWith(s.nostart) && (a = [], T.delimiter = m.slice(0, s.start.length), m = m.slice(s.start.length), [T.postDelimiter, m] = A(m)), a === null) return p++, null;\n    let g = m.trimRight().endsWith(s.end);\n    if (T.delimiter === \"\" && m.startsWith(s.delim) && !m.startsWith(s.end) && (T.delimiter = s.delim, m = m.slice(s.delim.length), [T.postDelimiter, m] = A(m)), g) {\n      let P = m.trimRight();\n      T.end = m.slice(P.length - s.end.length), m = P.slice(0, -s.end.length);\n    }\n    if (T.description = m, a.push({\n      number: p,\n      source: u,\n      tokens: T\n    }), p++, g) {\n      let P = a.slice();\n      return a = null, P;\n    }\n    return null;\n  }, \"parseSource\");\n}\nr(Ve, \"getParser\");\n\n// ../node_modules/comment-parser/es6/parser/spec-parser.js\nfunction Le({\n  tokenizers: n\n}) {\n  return /* @__PURE__ */r(function (a) {\n    var p;\n    let c = mt({\n      source: a\n    });\n    for (let u of n) if (c = u(c), !((p = c.problems[c.problems.length - 1]) === null || p === void 0) && p.critical) break;\n    return c;\n  }, \"parseSpec\");\n}\nr(Le, \"getParser\");\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/tag.js\nfunction ce() {\n  return n => {\n    let {\n        tokens: s\n      } = n.source[0],\n      a = s.description.match(/\\s*(@(\\S+))(\\s*)/);\n    return a === null ? (n.problems.push({\n      code: \"spec:tag:prefix\",\n      message: 'tag should start with \"@\" symbol',\n      line: n.source[0].number,\n      critical: !0\n    }), n) : (s.tag = a[1], s.postTag = a[3], s.description = s.description.slice(a[0].length), n.tag = a[2], n);\n  };\n}\nr(ce, \"tagTokenizer\");\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/type.js\nfunction le(n = \"compact\") {\n  let s = Vr(n);\n  return a => {\n    let p = 0,\n      c = [];\n    for (let [T, {\n      tokens: g\n    }] of a.source.entries()) {\n      let P = \"\";\n      if (T === 0 && g.description[0] !== \"{\") return a;\n      for (let b of g.description) if (b === \"{\" && p++, b === \"}\" && p--, P += b, p === 0) break;\n      if (c.push([g, P]), p === 0) break;\n    }\n    if (p !== 0) return a.problems.push({\n      code: \"spec:type:unpaired-curlies\",\n      message: \"unpaired curlies\",\n      line: a.source[0].number,\n      critical: !0\n    }), a;\n    let u = [],\n      m = c[0][0].postDelimiter.length;\n    for (let [T, [g, P]] of c.entries()) g.type = P, T > 0 && (g.type = g.postDelimiter.slice(m) + P, g.postDelimiter = g.postDelimiter.slice(0, m)), [g.postType, g.description] = A(g.description.slice(P.length)), u.push(g.type);\n    return u[0] = u[0].slice(1), u[u.length - 1] = u[u.length - 1].slice(0, -1), a.type = s(u), a;\n  };\n}\nr(le, \"typeTokenizer\");\nvar _r = /* @__PURE__ */r(n => n.trim(), \"trim\");\nfunction Vr(n) {\n  return n === \"compact\" ? s => s.map(_r).join(\"\") : n === \"preserve\" ? s => s.join(`\n`) : n;\n}\nr(Vr, \"getJoiner\");\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/name.js\nvar Lr = /* @__PURE__ */r(n => n && n.startsWith('\"') && n.endsWith('\"'), \"isQuoted\");\nfunction ue() {\n  let n = /* @__PURE__ */r((s, {\n    tokens: a\n  }, p) => a.type === \"\" ? s : p, \"typeEnd\");\n  return s => {\n    let {\n        tokens: a\n      } = s.source[s.source.reduce(n, 0)],\n      p = a.description.trimLeft(),\n      c = p.split('\"');\n    if (c.length > 1 && c[0] === \"\" && c.length % 2 === 1) return s.name = c[1], a.name = `\"${c[1]}\"`, [a.postName, a.description] = A(p.slice(a.name.length)), s;\n    let u = 0,\n      m = \"\",\n      T = !1,\n      g;\n    for (let b of p) {\n      if (u === 0 && je(b)) break;\n      b === \"[\" && u++, b === \"]\" && u--, m += b;\n    }\n    if (u !== 0) return s.problems.push({\n      code: \"spec:name:unpaired-brackets\",\n      message: \"unpaired brackets\",\n      line: s.source[0].number,\n      critical: !0\n    }), s;\n    let P = m;\n    if (m[0] === \"[\" && m[m.length - 1] === \"]\") {\n      T = !0, m = m.slice(1, -1);\n      let b = m.split(\"=\");\n      if (m = b[0].trim(), b[1] !== void 0 && (g = b.slice(1).join(\"=\").trim()), m === \"\") return s.problems.push({\n        code: \"spec:name:empty-name\",\n        message: \"empty name\",\n        line: s.source[0].number,\n        critical: !0\n      }), s;\n      if (g === \"\") return s.problems.push({\n        code: \"spec:name:empty-default\",\n        message: \"empty default value\",\n        line: s.source[0].number,\n        critical: !0\n      }), s;\n      if (!Lr(g) && /=(?!>)/.test(g)) return s.problems.push({\n        code: \"spec:name:invalid-default\",\n        message: \"invalid default value syntax\",\n        line: s.source[0].number,\n        critical: !0\n      }), s;\n    }\n    return s.optional = T, s.name = m, a.name = P, g !== void 0 && (s.default = g), [a.postName, a.description] = A(p.slice(a.name.length)), s;\n  };\n}\nr(ue, \"nameTokenizer\");\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/description.js\nfunction me(n = \"compact\", s = v) {\n  let a = Ue(n);\n  return p => (p.description = a(p.source, s), p);\n}\nr(me, \"descriptionTokenizer\");\nfunction Ue(n) {\n  return n === \"compact\" ? Ur : n === \"preserve\" ? Mr : n;\n}\nr(Ue, \"getJoiner\");\nfunction Ur(n, s = v) {\n  return n.map(({\n    tokens: {\n      description: a\n    }\n  }) => a.trim()).filter(a => a !== \"\").join(\" \");\n}\nr(Ur, \"compactJoiner\");\nvar Br = /* @__PURE__ */r((n, {\n    tokens: s\n  }, a) => s.type === \"\" ? n : a, \"lineNo\"),\n  Cr = /* @__PURE__ */r(({\n    tokens: n\n  }) => (n.delimiter === \"\" ? n.start : n.postDelimiter.slice(1)) + n.description, \"getDescription\");\nfunction Mr(n, s = v) {\n  if (n.length === 0) return \"\";\n  n[0].tokens.description === \"\" && n[0].tokens.delimiter === s.start && (n = n.slice(1));\n  let a = n[n.length - 1];\n  return a !== void 0 && a.tokens.description === \"\" && a.tokens.end.endsWith(s.end) && (n = n.slice(0, -1)), n = n.slice(n.reduce(Br, 0)), n.map(Cr).join(`\n`);\n}\nr(Mr, \"preserveJoiner\");\n\n// ../node_modules/comment-parser/es6/parser/index.js\nfunction Be({\n  startLine: n = 0,\n  fence: s = \"```\",\n  spacing: a = \"compact\",\n  markers: p = v,\n  tokenizers: c = [ce(), le(a), ue(), me(a)]\n} = {}) {\n  if (n < 0 || n % 1 > 0) throw new Error(\"Invalid startLine\");\n  let u = Ve({\n      startLine: n,\n      markers: p\n    }),\n    m = _e({\n      fence: s\n    }),\n    T = Le({\n      tokenizers: c\n    }),\n    g = Ue(a);\n  return function (P) {\n    let b = [];\n    for (let de of ut(P)) {\n      let q = u(de);\n      if (q === null) continue;\n      let S = m(q),\n        z = S.slice(1).map(T);\n      b.push({\n        description: g(S[0], p),\n        tags: z,\n        source: q,\n        problems: z.reduce((Te, ge) => Te.concat(ge.problems), [])\n      });\n    }\n    return b;\n  };\n}\nr(Be, \"getParser\");\n\n// ../node_modules/comment-parser/es6/stringifier/index.js\nfunction Kr(n) {\n  return n.start + n.delimiter + n.postDelimiter + n.tag + n.postTag + n.type + n.postType + n.name + n.postName + n.description + n.end + n.lineEnd;\n}\nr(Kr, \"join\");\nfunction Ce() {\n  return n => n.source.map(({\n    tokens: s\n  }) => Kr(s)).join(`\n`);\n}\nr(Ce, \"getStringifier\");\n\n// ../node_modules/comment-parser/es6/stringifier/inspect.js\nvar $r = {\n  line: 0,\n  start: 0,\n  delimiter: 0,\n  postDelimiter: 0,\n  tag: 0,\n  postTag: 0,\n  name: 0,\n  postName: 0,\n  type: 0,\n  postType: 0,\n  description: 0,\n  end: 0,\n  lineEnd: 0\n};\nvar Wo = Object.keys($r);\n\n// ../node_modules/comment-parser/es6/index.js\nfunction ft(n, s = {}) {\n  return Be(s)(n);\n}\nr(ft, \"parse\");\nvar ys = Ce();\n\n// src/docs-tools/argTypes/jsdocParser.ts\nvar $ = Pr(dt(), 1);\nfunction qr(n) {\n  return n != null && n.includes(\"@\");\n}\nr(qr, \"containsJsDoc\");\nfunction Yr(n) {\n  let p = `/**\n` + (n ?? \"\").split(`\n`).map(u => ` * ${u}`).join(`\n`) + `\n*/`,\n    c = ft(p, {\n      spacing: \"preserve\"\n    });\n  if (!c || c.length === 0) throw new Error(\"Cannot parse JSDoc tags.\");\n  return c[0];\n}\nr(Yr, \"parse\");\nvar Wr = {\n    tags: [\"param\", \"arg\", \"argument\", \"returns\", \"ignore\", \"deprecated\"]\n  },\n  Tt = /* @__PURE__ */r((n, s = Wr) => {\n    if (!qr(n)) return {\n      includesJsDoc: !1,\n      ignore: !1\n    };\n    let a = Yr(n),\n      p = Gr(a, s.tags);\n    return p.ignore ? {\n      includesJsDoc: !0,\n      ignore: !0\n    } : {\n      includesJsDoc: !0,\n      ignore: !1,\n      // Always use the parsed description to ensure JSDoc is removed from the description.\n      description: a.description.trim(),\n      extractedTags: p\n    };\n  }, \"parseJsDoc\");\nfunction Gr(n, s) {\n  let a = {\n    params: null,\n    deprecated: null,\n    returns: null,\n    ignore: !1\n  };\n  for (let p of n.tags) if (!(s !== void 0 && !s.includes(p.tag))) if (p.tag === \"ignore\") {\n    a.ignore = !0;\n    break;\n  } else switch (p.tag) {\n    // arg & argument are aliases for param.\n    case \"param\":\n    case \"arg\":\n    case \"argument\":\n      {\n        let c = zr(p);\n        c != null && (a.params == null && (a.params = []), a.params.push(c));\n        break;\n      }\n    case \"deprecated\":\n      {\n        let c = Hr(p);\n        c != null && (a.deprecated = c);\n        break;\n      }\n    case \"returns\":\n      {\n        let c = Qr(p);\n        c != null && (a.returns = c);\n        break;\n      }\n    default:\n      break;\n  }\n  return a;\n}\nr(Gr, \"extractJsDocTags\");\nfunction Xr(n) {\n  return n.replace(/[\\.-]$/, \"\");\n}\nr(Xr, \"normaliseParamName\");\nfunction zr(n) {\n  if (!n.name || n.name === \"-\") return null;\n  let s = ht(n.type);\n  return {\n    name: n.name,\n    type: s,\n    description: xt(n.description),\n    getPrettyName: /* @__PURE__ */r(() => Xr(n.name), \"getPrettyName\"),\n    getTypeName: /* @__PURE__ */r(() => s ? Jt(s) : null, \"getTypeName\")\n  };\n}\nr(zr, \"extractParam\");\nfunction Hr(n) {\n  return n.name ? gt(n.name, n.description) : null;\n}\nr(Hr, \"extractDeprecated\");\nfunction gt(n, s) {\n  let a = n === \"\" ? s : `${n} ${s}`;\n  return xt(a);\n}\nr(gt, \"joinNameAndDescription\");\nfunction xt(n) {\n  let s = n.replace(/^- /g, \"\").trim();\n  return s === \"\" ? null : s;\n}\nr(xt, \"normaliseDescription\");\nfunction Qr(n) {\n  let s = ht(n.type);\n  return s ? {\n    type: s,\n    description: gt(n.name, n.description),\n    getTypeName: /* @__PURE__ */r(() => Jt(s), \"getTypeName\")\n  } : null;\n}\nr(Qr, \"extractReturns\");\nvar _ = (0, $.stringifyRules)(),\n  Zr = _.JsdocTypeObject;\n_.JsdocTypeAny = () => \"any\";\n_.JsdocTypeObject = (n, s) => `(${Zr(n, s)})`;\n_.JsdocTypeOptional = (n, s) => s(n.element);\n_.JsdocTypeNullable = (n, s) => s(n.element);\n_.JsdocTypeNotNullable = (n, s) => s(n.element);\n_.JsdocTypeUnion = (n, s) => n.elements.map(s).join(\"|\");\nfunction ht(n) {\n  try {\n    return (0, $.parse)(n, \"typescript\");\n  } catch {\n    return null;\n  }\n}\nr(ht, \"extractType\");\nfunction Jt(n) {\n  return (0, $.transform)(_, n);\n}\nr(Jt, \"extractTypeName\");\n\n// src/docs-tools/argTypes/utils.ts\nvar bs = 90,\n  Ss = 50;\nfunction Ke(n) {\n  return n.length > 90;\n}\nr(Ke, \"isTooLongForTypeSummary\");\nfunction wt(n) {\n  return n.length > 50;\n}\nr(wt, \"isTooLongForDefaultValueSummary\");\nfunction w(n, s) {\n  return n === s ? {\n    summary: n\n  } : {\n    summary: n,\n    detail: s\n  };\n}\nr(w, \"createSummaryValue\");\nvar Es = /* @__PURE__ */r(n => n.replace(/\\\\r\\\\n/g, \"\\\\n\"), \"normalizeNewlines\");\n\n// src/docs-tools/argTypes/docgen/flow/createDefaultValue.ts\nfunction Pt(n, s) {\n  if (n != null) {\n    let {\n      value: a\n    } = n;\n    if (!K(a)) return wt(a) ? w(s?.name, a) : w(a);\n  }\n  return null;\n}\nr(Pt, \"createDefaultValue\");\n\n// src/docs-tools/argTypes/docgen/flow/createType.ts\nfunction bt({\n  name: n,\n  value: s,\n  elements: a,\n  raw: p\n}) {\n  return s ?? (a != null ? a.map(bt).join(\" | \") : p ?? n);\n}\nr(bt, \"generateUnionElement\");\nfunction en({\n  name: n,\n  raw: s,\n  elements: a\n}) {\n  return a != null ? w(a.map(bt).join(\" | \")) : s != null ? w(s.replace(/^\\|\\s*/, \"\")) : w(n);\n}\nr(en, \"generateUnion\");\nfunction tn({\n  type: n,\n  raw: s\n}) {\n  return s != null ? w(s) : w(n);\n}\nr(tn, \"generateFuncSignature\");\nfunction rn({\n  type: n,\n  raw: s\n}) {\n  return s != null ? Ke(s) ? w(n, s) : w(s) : w(n);\n}\nr(rn, \"generateObjectSignature\");\nfunction nn(n) {\n  let {\n    type: s\n  } = n;\n  return s === \"object\" ? rn(n) : tn(n);\n}\nr(nn, \"generateSignature\");\nfunction on({\n  name: n,\n  raw: s\n}) {\n  return s != null ? Ke(s) ? w(n, s) : w(s) : w(n);\n}\nr(on, \"generateDefault\");\nfunction St(n) {\n  if (n == null) return null;\n  switch (n.name) {\n    case \"union\":\n      return en(n);\n    case \"signature\":\n      return nn(n);\n    default:\n      return on(n);\n  }\n}\nr(St, \"createType\");\n\n// src/docs-tools/argTypes/docgen/flow/createPropDef.ts\nvar Et = /* @__PURE__ */r((n, s) => {\n  let {\n    flowType: a,\n    description: p,\n    required: c,\n    defaultValue: u\n  } = s;\n  return {\n    name: n,\n    type: St(a),\n    required: c,\n    description: p,\n    defaultValue: Pt(u ?? null, a ?? null)\n  };\n}, \"createFlowPropDef\");\n\n// src/docs-tools/argTypes/docgen/typeScript/createDefaultValue.ts\nfunction Nt({\n  defaultValue: n\n}) {\n  if (n != null) {\n    let {\n      value: s\n    } = n;\n    if (!K(s)) return w(s);\n  }\n  return null;\n}\nr(Nt, \"createDefaultValue\");\n\n// src/docs-tools/argTypes/docgen/typeScript/createType.ts\nfunction Dt({\n  tsType: n,\n  required: s\n}) {\n  if (n == null) return null;\n  let a = n.name;\n  return s || (a = a.replace(\" | undefined\", \"\")), w([\"Array\", \"Record\", \"signature\"].includes(n.name) ? n.raw : a);\n}\nr(Dt, \"createType\");\n\n// src/docs-tools/argTypes/docgen/typeScript/createPropDef.ts\nvar Ot = /* @__PURE__ */r((n, s) => {\n  let {\n    description: a,\n    required: p\n  } = s;\n  return {\n    name: n,\n    type: Dt(s),\n    required: p,\n    description: a,\n    defaultValue: Nt(s)\n  };\n}, \"createTsPropDef\");\n\n// src/docs-tools/argTypes/docgen/createPropDef.ts\nfunction sn(n) {\n  return n != null ? w(n.name) : null;\n}\nr(sn, \"createType\");\nfunction an(n) {\n  let {\n    computed: s,\n    func: a\n  } = n;\n  return typeof s > \"u\" && typeof a > \"u\";\n}\nr(an, \"isReactDocgenTypescript\");\nfunction pn(n) {\n  return n ? n.name === \"string\" ? !0 : n.name === \"enum\" ? Array.isArray(n.value) && n.value.every(({\n    value: s\n  }) => typeof s == \"string\" && s[0] === '\"' && s[s.length - 1] === '\"') : !1 : !1;\n}\nr(pn, \"isStringValued\");\nfunction cn(n, s) {\n  if (n != null) {\n    let {\n      value: a\n    } = n;\n    if (!K(a)) return an(n) && pn(s) ? w(JSON.stringify(a)) : w(a);\n  }\n  return null;\n}\nr(cn, \"createDefaultValue\");\nfunction vt(n, s, a) {\n  let {\n    description: p,\n    required: c,\n    defaultValue: u\n  } = a;\n  return {\n    name: n,\n    type: sn(s),\n    required: c,\n    description: p,\n    defaultValue: cn(u, s)\n  };\n}\nr(vt, \"createBasicPropDef\");\nfunction ye(n, s) {\n  if (s?.includesJsDoc) {\n    let {\n      description: a,\n      extractedTags: p\n    } = s;\n    a != null && (n.description = s.description);\n    let c = {\n      ...p,\n      params: p?.params?.map(u => ({\n        name: u.getPrettyName(),\n        description: u.description\n      }))\n    };\n    Object.values(c).filter(Boolean).length > 0 && (n.jsDocTags = c);\n  }\n  return n;\n}\nr(ye, \"applyJsDocResult\");\nvar ln = /* @__PURE__ */r((n, s, a) => {\n    let p = vt(n, s.type, s);\n    return p.sbType = pe(s), ye(p, a);\n  }, \"javaScriptFactory\"),\n  un = /* @__PURE__ */r((n, s, a) => {\n    let p = Ot(n, s);\n    return p.sbType = pe(s), ye(p, a);\n  }, \"tsFactory\"),\n  mn = /* @__PURE__ */r((n, s, a) => {\n    let p = Et(n, s);\n    return p.sbType = pe(s), ye(p, a);\n  }, \"flowFactory\"),\n  fn = /* @__PURE__ */r((n, s, a) => {\n    let p = vt(n, {\n      name: \"unknown\"\n    }, s);\n    return ye(p, a);\n  }, \"unknownFactory\"),\n  $e = /* @__PURE__ */r(n => {\n    switch (n) {\n      case \"JavaScript\":\n        return ln;\n      case \"TypeScript\":\n        return un;\n      case \"Flow\":\n        return mn;\n      default:\n        return fn;\n    }\n  }, \"getPropDefFactory\");\n\n// src/docs-tools/argTypes/docgen/extractDocgenProps.ts\nvar kt = /* @__PURE__ */r(n => n.type != null ? \"JavaScript\" : n.flowType != null ? \"Flow\" : n.tsType != null ? \"TypeScript\" : \"Unknown\", \"getTypeSystem\"),\n  yn = /* @__PURE__ */r(n => {\n    let s = kt(n[0]),\n      a = $e(s);\n    return n.map(p => {\n      let c = p;\n      return p.type?.elements && (c = {\n        ...p,\n        type: {\n          ...p.type,\n          value: p.type.elements\n        }\n      }), At(c.name, c, s, a);\n    });\n  }, \"extractComponentSectionArray\"),\n  dn = /* @__PURE__ */r(n => {\n    let s = Object.keys(n),\n      a = kt(n[s[0]]),\n      p = $e(a);\n    return s.map(c => {\n      let u = n[c];\n      return u != null ? At(c, u, a, p) : null;\n    }).filter(Boolean);\n  }, \"extractComponentSectionObject\"),\n  aa = /* @__PURE__ */r((n, s) => {\n    let a = pt(n, s);\n    return it(a) ? Array.isArray(a) ? yn(a) : dn(a) : [];\n  }, \"extractComponentProps\");\nfunction At(n, s, a, p) {\n  let c = Tt(s.description);\n  return c.includesJsDoc && c.ignore ? null : {\n    propDef: p(n, s, c),\n    jsDocTags: c.extractedTags,\n    docgenInfo: s,\n    typeSystem: a\n  };\n}\nr(At, \"extractProp\");\nfunction ia(n) {\n  return n != null ? ct(n) : \"\";\n}\nr(ia, \"extractComponentDescription\");\n\n// src/preview-api/modules/store/parameters.ts\nvar qe = /* @__PURE__ */r((...n) => {\n  let s = {},\n    a = n.filter(Boolean),\n    p = a.reduce((c, u) => (Object.entries(u).forEach(([m, T]) => {\n      let g = c[m];\n      Array.isArray(T) || typeof g > \"u\" ? c[m] = T : X(T) && X(g) ? s[m] = !0 : typeof T < \"u\" && (c[m] = T);\n    }), c), {});\n  return Object.keys(s).forEach(c => {\n    let u = a.filter(Boolean).map(m => m[c]).filter(m => typeof m < \"u\");\n    u.every(m => X(m)) ? p[c] = qe(...u) : p[c] = u[u.length - 1];\n  }), p;\n}, \"combineParameters\");\n\n// src/docs-tools/argTypes/enhanceArgTypes.ts\nvar ya = /* @__PURE__ */r(n => {\n  let {\n      component: s,\n      argTypes: a,\n      parameters: {\n        docs: p = {}\n      }\n    } = n,\n    {\n      extractArgTypes: c\n    } = p;\n  if (!c || !s) return a;\n  let u = c(s);\n  return u ? qe(u, a) : a;\n}, \"enhanceArgTypes\");\n\n// src/docs-tools/shared.ts\nvar It = \"storybook/docs\",\n  ga = `${It}/panel`,\n  xa = \"docs\",\n  ha = `${It}/snippet-rendered`,\n  Tn = /* @__PURE__ */(p => (p.AUTO = \"auto\", p.CODE = \"code\", p.DYNAMIC = \"dynamic\", p))(Tn || {});\nexport { It as ADDON_ID, Ss as MAX_DEFAULT_VALUE_SUMMARY_LENGTH, bs as MAX_TYPE_SUMMARY_LENGTH, ga as PANEL_ID, xa as PARAM_KEY, ha as SNIPPET_RENDERED, Tn as SourceType, Ir as TypeSystem, pe as convert, w as createSummaryValue, ya as enhanceArgTypes, ia as extractComponentDescription, aa as extractComponentProps, yn as extractComponentSectionArray, dn as extractComponentSectionObject, ct as getDocgenDescription, pt as getDocgenSection, at as hasDocgen, K as isDefaultValueBlacklisted, wt as isTooLongForDefaultValueSummary, Ke as isTooLongForTypeSummary, it as isValidDocgenSection, Es as normalizeNewlines, Tt as parseJsDoc, st as str };","map":{"version":3,"names":["dr","Object","create","Ie","defineProperty","Tr","getOwnPropertyDescriptor","gr","getOwnPropertyNames","xr","getPrototypeOf","hr","prototype","hasOwnProperty","r","n","s","value","configurable","Jr","exports","wr","a","p","c","call","get","enumerable","Pr","__esModule","dt","fe","yt","define","amd","globalThis","self","jtpp","e","text","type","ne","Error","constructor","t","token","setPrototypeOf","getToken","oe","se","o","i","u","startsWith","m","l","length","slice","T","RegExp","g","P","test","b","de","exec","q","S","z","Te","ge","Rt","jt","U","read","previous","current","next","trim","f","assign","startOfLine","advance","xe","J","he","H","Ft","_t","element","Je","y","ALL","PARAMETER_LIST","OBJECT","KEY_VALUE","INDEX_BRACKETS","UNION","INTERSECTION","PREFIX","INFIX","TUPLE","SYMBOL","OPTIONAL","NULLABLE","KEY_OF_TYPE_OF","FUNCTION","ARROW","ARRAY_BRACKETS","GENERIC","NAME_PATH","PARENTHESIS","SPECIAL_TYPES","Ae","grammar","_lexer","baseParser","lexer","parse","parseType","parseIntermediateType","tryParslets","parseInfixIntermediateType","consume","Array","isArray","includes","acceptLexerState","I","Ye","we","meta","position","x","d","accept","parsePrefix","precedence","parseInfix","name","Q","Z","parseFloat","Vt","elements","Lt","Ut","Bt","allowTrailingComma","push","some","Ct","left","brackets","dot","Mt","Pe","ee","allowSquareBracketsOnAnyType","allowJsdocNamePaths","pathGrammar","h","D","O","ae","rt","k","G","quote","toString","specialType","nt","right","pathType","R","allowedAdditionalTokens","Y","te","allowedTypes","E","We","L","be","map","Kt","Se","allowNamedParameters","allowNoReturnType","allowWithoutParenthesis","allowNewAsFunctionKeyword","parameters","arrow","parenthesis","key","join","returnType","Ee","allowPostfix","allowEnclosingBrackets","squareBrackets","Ge","Xe","Ne","objectFieldGrammar","allowKeyTypes","separator","optional","readonly","De","allowSquaredProperties","allowReadonly","allowOptional","Oe","allowVariadic","variadic","ze","$t","He","qt","Yt","Wt","Gt","allowQuestionMark","Xt","zt","Ht","Qt","Zt","er","tr","rr","nr","Qe","or","W","N","Ze","params","this","new","re","j","et","JsdocTypeParenthesis","JsdocTypeKeyof","JsdocTypeFunction","JsdocTypeName","JsdocTypeTuple","JsdocTypeVariadic","JsdocTypeNamePath","JsdocTypeStringValue","JsdocTypeAny","JsdocTypeGeneric","JsdocTypeImport","JsdocTypeObjectField","JsdocTypeJsdocObjectField","JsdocTypeKeyValue","JsdocTypeSpecialNamePath","JsdocTypeNotNullable","JsdocTypeNull","JsdocTypeNullable","JsdocTypeNumber","JsdocTypeObject","JsdocTypeOptional","JsdocTypeSymbol","JsdocTypeTypeof","JsdocTypeUndefined","JsdocTypeUnion","JsdocTypeUnknown","JsdocTypeIntersection","JsdocTypeProperty","JsdocTypePredicate","JsdocTypeIndexSignature","JsdocTypeMappedType","JsdocTypeAsserts","sr","ar","ir","F","reservedWord","pr","nullable","repeatable","result","applications","expression","fields","cr","V","lr","ve","ur","syntax","entries","path","quoteStyle","string","typeName","returns","subject","objects","owner","hasEventPrefix","number","mr","fr","tt","ke","yr","catharsisTransform","identityTransformRules","jtpTransform","stringify","stringifyRules","transform","traverse","tryParse","visitorKeys","UnknownArgTypesError","br","Sr","Er","replace","Nr","signature","properties","forEach","B","language","raw","every","X","Re","keys","ot","Dr","Or","ie","Number","isNaN","vr","C","computed","indexOf","split","JSON","kr","Ar","M","pe","tsType","flowType","console","error","Ir","JAVASCRIPT","FLOW","TYPESCRIPT","UNKNOWN","Rr","K","st","at","__docgenInfo","it","pt","ct","description","v","start","nostart","delim","end","je","lt","match","A","ut","mt","tag","problems","source","Fe","delimiter","postDelimiter","postTag","postName","postType","lineEnd","jr","_e","fence","Fr","tokens","Ve","startLine","markers","trimRight","endsWith","Le","tokenizers","critical","ce","code","message","line","le","Vr","_r","Lr","ue","reduce","trimLeft","default","me","Ue","Ur","Mr","filter","Br","Cr","Be","spacing","tags","concat","Kr","Ce","$r","Wo","ft","ys","$","qr","Yr","Wr","Tt","includesJsDoc","ignore","Gr","extractedTags","deprecated","zr","Hr","Qr","Xr","ht","xt","getPrettyName","getTypeName","Jt","gt","_","Zr","bs","Ss","Ke","wt","w","summary","detail","Es","Pt","bt","en","tn","rn","nn","on","St","Et","required","defaultValue","Nt","Dt","Ot","sn","an","func","pn","cn","vt","ye","values","Boolean","jsDocTags","ln","sbType","un","mn","fn","$e","kt","yn","At","dn","aa","propDef","docgenInfo","typeSystem","ia","qe","ya","component","argTypes","docs","extractArgTypes","It","ga","xa","ha","Tn","AUTO","CODE","DYNAMIC","ADDON_ID","MAX_DEFAULT_VALUE_SUMMARY_LENGTH","MAX_TYPE_SUMMARY_LENGTH","PANEL_ID","PARAM_KEY","SNIPPET_RENDERED","SourceType","TypeSystem","convert","createSummaryValue","enhanceArgTypes","extractComponentDescription","extractComponentProps","extractComponentSectionArray","extractComponentSectionObject","getDocgenDescription","getDocgenSection","hasDocgen","isDefaultValueBlacklisted","isTooLongForDefaultValueSummary","isTooLongForTypeSummary","isValidDocgenSection","normalizeNewlines","parseJsDoc","str"],"sources":["E:/Project/mailit-postal-project-backend/frontend/node_modules/storybook/dist/docs-tools/index.js"],"sourcesContent":["var dr = Object.create;\nvar Ie = Object.defineProperty;\nvar Tr = Object.getOwnPropertyDescriptor;\nvar gr = Object.getOwnPropertyNames;\nvar xr = Object.getPrototypeOf, hr = Object.prototype.hasOwnProperty;\nvar r = (n, s) => Ie(n, \"name\", { value: s, configurable: !0 });\nvar Jr = (n, s) => () => (s || n((s = { exports: {} }).exports, s), s.exports);\nvar wr = (n, s, a, p) => {\n  if (s && typeof s == \"object\" || typeof s == \"function\")\n    for (let c of gr(s))\n      !hr.call(n, c) && c !== a && Ie(n, c, { get: () => s[c], enumerable: !(p = Tr(s, c)) || p.enumerable });\n  return n;\n};\nvar Pr = (n, s, a) => (a = n != null ? dr(xr(n)) : {}, wr(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  s || !n || !n.__esModule ? Ie(a, \"default\", { value: n, enumerable: !0 }) : a,\n  n\n));\n\n// ../node_modules/jsdoc-type-pratt-parser/dist/index.js\nvar dt = Jr((fe, yt) => {\n  (function(n, s) {\n    typeof fe == \"object\" && typeof yt < \"u\" ? s(fe) : typeof define == \"function\" && define.amd ? define([\"exports\"], s) : (n = typeof globalThis <\n    \"u\" ? globalThis : n || self, s(n.jtpp = {}));\n  })(fe, function(n) {\n    \"use strict\";\n    function s(e) {\n      return e.text !== void 0 && e.text !== \"\" ? `'${e.type}' with value '${e.text}'` : `'${e.type}'`;\n    }\n    r(s, \"tokenToString\");\n    let ne = class ne extends Error {\n      constructor(t) {\n        super(`No parslet found for token: ${s(t)}`), this.token = t, Object.setPrototypeOf(this, ne.prototype);\n      }\n      getToken() {\n        return this.token;\n      }\n    };\n    r(ne, \"NoParsletFoundError\");\n    let a = ne, oe = class oe extends Error {\n      constructor(t) {\n        super(`The parsing ended early. The next token was: ${s(t)}`), this.token = t, Object.setPrototypeOf(this, oe.prototype);\n      }\n      getToken() {\n        return this.token;\n      }\n    };\n    r(oe, \"EarlyEndOfParseError\");\n    let p = oe, se = class se extends Error {\n      constructor(t, o) {\n        let i = `Unexpected type: '${t.type}'.`;\n        o !== void 0 && (i += ` Message: ${o}`), super(i), Object.setPrototypeOf(this, se.prototype);\n      }\n    };\n    r(se, \"UnexpectedTypeError\");\n    let c = se;\n    function u(e) {\n      return (t) => t.startsWith(e) ? { type: e, text: e } : null;\n    }\n    r(u, \"makePunctuationRule\");\n    function m(e) {\n      let t = 0, o, i = e[0], l = !1;\n      if (i !== \"'\" && i !== '\"')\n        return null;\n      for (; t < e.length; ) {\n        if (t++, o = e[t], !l && o === i) {\n          t++;\n          break;\n        }\n        l = !l && o === \"\\\\\";\n      }\n      if (o !== i)\n        throw new Error(\"Unterminated String\");\n      return e.slice(0, t);\n    }\n    r(m, \"getQuoted\");\n    let T = new RegExp(\"[$_\\\\p{ID_Start}]|\\\\\\\\u\\\\p{Hex_Digit}{4}|\\\\\\\\u\\\\{0*(?:\\\\p{Hex_Digit}{1,5}|10\\\\p{Hex_Digit}{4})\\\\}\", \"u\"), g = new RegExp(\n    \"[$\\\\-\\\\p{ID_Continue}\\\\u200C\\\\u200D]|\\\\\\\\u\\\\p{Hex_Digit}{4}|\\\\\\\\u\\\\{0*(?:\\\\p{Hex_Digit}{1,5}|10\\\\p{Hex_Digit}{4})\\\\}\", \"u\");\n    function P(e) {\n      let t = e[0];\n      if (!T.test(t))\n        return null;\n      let o = 1;\n      do {\n        if (t = e[o], !g.test(t))\n          break;\n        o++;\n      } while (o < e.length);\n      return e.slice(0, o);\n    }\n    r(P, \"getIdentifier\");\n    let b = /^(NaN|-?((\\d*\\.\\d+|\\d+)([Ee][+-]?\\d+)?|Infinity))/;\n    function de(e) {\n      var t, o;\n      return (o = (t = b.exec(e)) === null || t === void 0 ? void 0 : t[0]) !== null && o !== void 0 ? o : null;\n    }\n    r(de, \"getNumber\");\n    let q = /* @__PURE__ */ r((e) => {\n      let t = P(e);\n      return t == null ? null : {\n        type: \"Identifier\",\n        text: t\n      };\n    }, \"identifierRule\");\n    function S(e) {\n      return (t) => {\n        if (!t.startsWith(e))\n          return null;\n        let o = t[e.length];\n        return o !== void 0 && g.test(o) ? null : {\n          type: e,\n          text: e\n        };\n      };\n    }\n    r(S, \"makeKeyWordRule\");\n    let z = /* @__PURE__ */ r((e) => {\n      let t = m(e);\n      return t == null ? null : {\n        type: \"StringValue\",\n        text: t\n      };\n    }, \"stringValueRule\"), Te = /* @__PURE__ */ r((e) => e.length > 0 ? null : {\n      type: \"EOF\",\n      text: \"\"\n    }, \"eofRule\"), ge = /* @__PURE__ */ r((e) => {\n      let t = de(e);\n      return t === null ? null : {\n        type: \"Number\",\n        text: t\n      };\n    }, \"numberRule\"), Rt = [\n      Te,\n      u(\"=>\"),\n      u(\"(\"),\n      u(\")\"),\n      u(\"{\"),\n      u(\"}\"),\n      u(\"[\"),\n      u(\"]\"),\n      u(\"|\"),\n      u(\"&\"),\n      u(\"<\"),\n      u(\">\"),\n      u(\",\"),\n      u(\";\"),\n      u(\"*\"),\n      u(\"?\"),\n      u(\"!\"),\n      u(\"=\"),\n      u(\":\"),\n      u(\"...\"),\n      u(\".\"),\n      u(\"#\"),\n      u(\"~\"),\n      u(\"/\"),\n      u(\"@\"),\n      S(\"undefined\"),\n      S(\"null\"),\n      S(\"function\"),\n      S(\"this\"),\n      S(\"new\"),\n      S(\"module\"),\n      S(\"event\"),\n      S(\"external\"),\n      S(\"typeof\"),\n      S(\"keyof\"),\n      S(\"readonly\"),\n      S(\"import\"),\n      S(\"is\"),\n      S(\"in\"),\n      S(\"asserts\"),\n      ge,\n      q,\n      z\n    ], jt = /^\\s*\\n\\s*/, U = class U {\n      static create(t) {\n        let o = this.read(t);\n        t = o.text;\n        let i = this.read(t);\n        return t = i.text, new U(t, void 0, o.token, i.token);\n      }\n      constructor(t, o, i, l) {\n        this.text = \"\", this.text = t, this.previous = o, this.current = i, this.next = l;\n      }\n      static read(t, o = !1) {\n        o = o || jt.test(t), t = t.trim();\n        for (let i of Rt) {\n          let l = i(t);\n          if (l !== null) {\n            let f = Object.assign(Object.assign({}, l), { startOfLine: o });\n            return t = t.slice(f.text.length), { text: t, token: f };\n          }\n        }\n        throw new Error(\"Unexpected Token \" + t);\n      }\n      advance() {\n        let t = U.read(this.text);\n        return new U(t.text, this.current, this.next, t.token);\n      }\n    };\n    r(U, \"Lexer\");\n    let xe = U;\n    function J(e) {\n      if (e === void 0)\n        throw new Error(\"Unexpected undefined\");\n      if (e.type === \"JsdocTypeKeyValue\" || e.type === \"JsdocTypeParameterList\" || e.type === \"JsdocTypeProperty\" || e.type === \"JsdocTypeRe\\\nadonlyProperty\" || e.type === \"JsdocTypeObjectField\" || e.type === \"JsdocTypeJsdocObjectField\" || e.type === \"JsdocTypeIndexSignature\" || e.\n      type === \"JsdocTypeMappedType\")\n        throw new c(e);\n      return e;\n    }\n    r(J, \"assertRootResult\");\n    function he(e) {\n      return e.type === \"JsdocTypeKeyValue\" ? H(e) : J(e);\n    }\n    r(he, \"assertPlainKeyValueOrRootResult\");\n    function Ft(e) {\n      return e.type === \"JsdocTypeName\" ? e : H(e);\n    }\n    r(Ft, \"assertPlainKeyValueOrNameResult\");\n    function H(e) {\n      if (e.type !== \"JsdocTypeKeyValue\")\n        throw new c(e);\n      return e;\n    }\n    r(H, \"assertPlainKeyValueResult\");\n    function _t(e) {\n      var t;\n      if (e.type === \"JsdocTypeVariadic\") {\n        if (((t = e.element) === null || t === void 0 ? void 0 : t.type) === \"JsdocTypeName\")\n          return e;\n        throw new c(e);\n      }\n      if (e.type !== \"JsdocTypeNumber\" && e.type !== \"JsdocTypeName\")\n        throw new c(e);\n      return e;\n    }\n    r(_t, \"assertNumberOrVariadicNameResult\");\n    function Je(e) {\n      return e.type === \"JsdocTypeIndexSignature\" || e.type === \"JsdocTypeMappedType\";\n    }\n    r(Je, \"isSquaredProperty\");\n    var y;\n    (function(e) {\n      e[e.ALL = 0] = \"ALL\", e[e.PARAMETER_LIST = 1] = \"PARAMETER_LIST\", e[e.OBJECT = 2] = \"OBJECT\", e[e.KEY_VALUE = 3] = \"KEY_VALUE\", e[e.INDEX_BRACKETS =\n      4] = \"INDEX_BRACKETS\", e[e.UNION = 5] = \"UNION\", e[e.INTERSECTION = 6] = \"INTERSECTION\", e[e.PREFIX = 7] = \"PREFIX\", e[e.INFIX = 8] = \"\\\nINFIX\", e[e.TUPLE = 9] = \"TUPLE\", e[e.SYMBOL = 10] = \"SYMBOL\", e[e.OPTIONAL = 11] = \"OPTIONAL\", e[e.NULLABLE = 12] = \"NULLABLE\", e[e.KEY_OF_TYPE_OF =\n      13] = \"KEY_OF_TYPE_OF\", e[e.FUNCTION = 14] = \"FUNCTION\", e[e.ARROW = 15] = \"ARROW\", e[e.ARRAY_BRACKETS = 16] = \"ARRAY_BRACKETS\", e[e.GENERIC =\n      17] = \"GENERIC\", e[e.NAME_PATH = 18] = \"NAME_PATH\", e[e.PARENTHESIS = 19] = \"PARENTHESIS\", e[e.SPECIAL_TYPES = 20] = \"SPECIAL_TYPES\";\n    })(y || (y = {}));\n    let Ae = class Ae {\n      constructor(t, o, i) {\n        this.grammar = t, typeof o == \"string\" ? this._lexer = xe.create(o) : this._lexer = o, this.baseParser = i;\n      }\n      get lexer() {\n        return this._lexer;\n      }\n      /**\n       * Parses a given string and throws an error if the parse ended before the end of the string.\n       */\n      parse() {\n        let t = this.parseType(y.ALL);\n        if (this.lexer.current.type !== \"EOF\")\n          throw new p(this.lexer.current);\n        return t;\n      }\n      /**\n       * Parses with the current lexer and asserts that the result is a {@link RootResult}.\n       */\n      parseType(t) {\n        return J(this.parseIntermediateType(t));\n      }\n      /**\n       * The main parsing function. First it tries to parse the current state in the prefix step, and then it continues\n       * to parse the state in the infix step.\n       */\n      parseIntermediateType(t) {\n        let o = this.tryParslets(null, t);\n        if (o === null)\n          throw new a(this.lexer.current);\n        return this.parseInfixIntermediateType(o, t);\n      }\n      /**\n       * In the infix parsing step the parser continues to parse the current state with all parslets until none returns\n       * a result.\n       */\n      parseInfixIntermediateType(t, o) {\n        let i = this.tryParslets(t, o);\n        for (; i !== null; )\n          t = i, i = this.tryParslets(t, o);\n        return t;\n      }\n      /**\n       * Tries to parse the current state with all parslets in the grammar and returns the first non null result.\n       */\n      tryParslets(t, o) {\n        for (let i of this.grammar) {\n          let l = i(this, o, t);\n          if (l !== null)\n            return l;\n        }\n        return null;\n      }\n      /**\n       * If the given type equals the current type of the {@link Lexer} advance the lexer. Return true if the lexer was\n       * advanced.\n       */\n      consume(t) {\n        return Array.isArray(t) || (t = [t]), t.includes(this.lexer.current.type) ? (this._lexer = this.lexer.advance(), !0) : !1;\n      }\n      acceptLexerState(t) {\n        this._lexer = t.lexer;\n      }\n    };\n    r(Ae, \"Parser\");\n    let I = Ae;\n    function Ye(e) {\n      return e === \"EOF\" || e === \"|\" || e === \",\" || e === \")\" || e === \">\";\n    }\n    r(Ye, \"isQuestionMarkUnknownType\");\n    let we = /* @__PURE__ */ r((e, t, o) => {\n      let i = e.lexer.current.type, l = e.lexer.next.type;\n      return o == null && i === \"?\" && !Ye(l) || o != null && i === \"?\" ? (e.consume(\"?\"), o == null ? {\n        type: \"JsdocTypeNullable\",\n        element: e.parseType(y.NULLABLE),\n        meta: {\n          position: \"prefix\"\n        }\n      } : {\n        type: \"JsdocTypeNullable\",\n        element: J(o),\n        meta: {\n          position: \"suffix\"\n        }\n      }) : null;\n    }, \"nullableParslet\");\n    function x(e) {\n      let t = /* @__PURE__ */ r((o, i, l) => {\n        let f = o.lexer.current.type, d = o.lexer.next.type;\n        if (l === null) {\n          if (\"parsePrefix\" in e && e.accept(f, d))\n            return e.parsePrefix(o);\n        } else if (\"parseInfix\" in e && e.precedence > i && e.accept(f, d))\n          return e.parseInfix(o, l);\n        return null;\n      }, \"parslet\");\n      return Object.defineProperty(t, \"name\", {\n        value: e.name\n      }), t;\n    }\n    r(x, \"composeParslet\");\n    let Q = x({\n      name: \"optionalParslet\",\n      accept: /* @__PURE__ */ r((e) => e === \"=\", \"accept\"),\n      precedence: y.OPTIONAL,\n      parsePrefix: /* @__PURE__ */ r((e) => (e.consume(\"=\"), {\n        type: \"JsdocTypeOptional\",\n        element: e.parseType(y.OPTIONAL),\n        meta: {\n          position: \"prefix\"\n        }\n      }), \"parsePrefix\"),\n      parseInfix: /* @__PURE__ */ r((e, t) => (e.consume(\"=\"), {\n        type: \"JsdocTypeOptional\",\n        element: J(t),\n        meta: {\n          position: \"suffix\"\n        }\n      }), \"parseInfix\")\n    }), Z = x({\n      name: \"numberParslet\",\n      accept: /* @__PURE__ */ r((e) => e === \"Number\", \"accept\"),\n      parsePrefix: /* @__PURE__ */ r((e) => {\n        let t = parseFloat(e.lexer.current.text);\n        return e.consume(\"Number\"), {\n          type: \"JsdocTypeNumber\",\n          value: t\n        };\n      }, \"parsePrefix\")\n    }), Vt = x({\n      name: \"parenthesisParslet\",\n      accept: /* @__PURE__ */ r((e) => e === \"(\", \"accept\"),\n      parsePrefix: /* @__PURE__ */ r((e) => {\n        if (e.consume(\"(\"), e.consume(\")\"))\n          return {\n            type: \"JsdocTypeParameterList\",\n            elements: []\n          };\n        let t = e.parseIntermediateType(y.ALL);\n        if (!e.consume(\")\"))\n          throw new Error(\"Unterminated parenthesis\");\n        return t.type === \"JsdocTypeParameterList\" ? t : t.type === \"JsdocTypeKeyValue\" ? {\n          type: \"JsdocTypeParameterList\",\n          elements: [t]\n        } : {\n          type: \"JsdocTypeParenthesis\",\n          element: J(t)\n        };\n      }, \"parsePrefix\")\n    }), Lt = x({\n      name: \"specialTypesParslet\",\n      accept: /* @__PURE__ */ r((e, t) => e === \"?\" && Ye(t) || e === \"null\" || e === \"undefined\" || e === \"*\", \"accept\"),\n      parsePrefix: /* @__PURE__ */ r((e) => {\n        if (e.consume(\"null\"))\n          return {\n            type: \"JsdocTypeNull\"\n          };\n        if (e.consume(\"undefined\"))\n          return {\n            type: \"JsdocTypeUndefined\"\n          };\n        if (e.consume(\"*\"))\n          return {\n            type: \"JsdocTypeAny\"\n          };\n        if (e.consume(\"?\"))\n          return {\n            type: \"JsdocTypeUnknown\"\n          };\n        throw new Error(\"Unacceptable token: \" + e.lexer.current.text);\n      }, \"parsePrefix\")\n    }), Ut = x({\n      name: \"notNullableParslet\",\n      accept: /* @__PURE__ */ r((e) => e === \"!\", \"accept\"),\n      precedence: y.NULLABLE,\n      parsePrefix: /* @__PURE__ */ r((e) => (e.consume(\"!\"), {\n        type: \"JsdocTypeNotNullable\",\n        element: e.parseType(y.NULLABLE),\n        meta: {\n          position: \"prefix\"\n        }\n      }), \"parsePrefix\"),\n      parseInfix: /* @__PURE__ */ r((e, t) => (e.consume(\"!\"), {\n        type: \"JsdocTypeNotNullable\",\n        element: J(t),\n        meta: {\n          position: \"suffix\"\n        }\n      }), \"parseInfix\")\n    });\n    function Bt({ allowTrailingComma: e }) {\n      return x({\n        name: \"parameterListParslet\",\n        accept: /* @__PURE__ */ r((t) => t === \",\", \"accept\"),\n        precedence: y.PARAMETER_LIST,\n        parseInfix: /* @__PURE__ */ r((t, o) => {\n          let i = [\n            he(o)\n          ];\n          t.consume(\",\");\n          do\n            try {\n              let l = t.parseIntermediateType(y.PARAMETER_LIST);\n              i.push(he(l));\n            } catch (l) {\n              if (e && l instanceof a)\n                break;\n              throw l;\n            }\n          while (t.consume(\",\"));\n          if (i.length > 0 && i.slice(0, -1).some((l) => l.type === \"JsdocTypeVariadic\"))\n            throw new Error(\"Only the last parameter may be a rest parameter\");\n          return {\n            type: \"JsdocTypeParameterList\",\n            elements: i\n          };\n        }, \"parseInfix\")\n      });\n    }\n    r(Bt, \"createParameterListParslet\");\n    let Ct = x({\n      name: \"genericParslet\",\n      accept: /* @__PURE__ */ r((e, t) => e === \"<\" || e === \".\" && t === \"<\", \"accept\"),\n      precedence: y.GENERIC,\n      parseInfix: /* @__PURE__ */ r((e, t) => {\n        let o = e.consume(\".\");\n        e.consume(\"<\");\n        let i = [];\n        do\n          i.push(e.parseType(y.PARAMETER_LIST));\n        while (e.consume(\",\"));\n        if (!e.consume(\">\"))\n          throw new Error(\"Unterminated generic parameter list\");\n        return {\n          type: \"JsdocTypeGeneric\",\n          left: J(t),\n          elements: i,\n          meta: {\n            brackets: \"angle\",\n            dot: o\n          }\n        };\n      }, \"parseInfix\")\n    }), Mt = x({\n      name: \"unionParslet\",\n      accept: /* @__PURE__ */ r((e) => e === \"|\", \"accept\"),\n      precedence: y.UNION,\n      parseInfix: /* @__PURE__ */ r((e, t) => {\n        e.consume(\"|\");\n        let o = [];\n        do\n          o.push(e.parseType(y.UNION));\n        while (e.consume(\"|\"));\n        return {\n          type: \"JsdocTypeUnion\",\n          elements: [J(t), ...o]\n        };\n      }, \"parseInfix\")\n    }), Pe = [\n      we,\n      Q,\n      Z,\n      Vt,\n      Lt,\n      Ut,\n      Bt({\n        allowTrailingComma: !0\n      }),\n      Ct,\n      Mt,\n      Q\n    ];\n    function ee({ allowSquareBracketsOnAnyType: e, allowJsdocNamePaths: t, pathGrammar: o }) {\n      return /* @__PURE__ */ r(function(l, f, d) {\n        if (d == null || f >= y.NAME_PATH)\n          return null;\n        let h = l.lexer.current.type, D = l.lexer.next.type;\n        if (!(h === \".\" && D !== \"<\" || h === \"[\" && (e || d.type === \"JsdocTypeName\") || t && (h === \"~\" || h === \"#\")))\n          return null;\n        let O, ae = !1;\n        l.consume(\".\") ? O = \"property\" : l.consume(\"[\") ? (O = \"property-brackets\", ae = !0) : l.consume(\"~\") ? O = \"inner\" : (l.consume(\"#\"),\n        O = \"instance\");\n        let rt = o !== null ? new I(o, l.lexer, l) : l, k = rt.parseIntermediateType(y.NAME_PATH);\n        l.acceptLexerState(rt);\n        let G;\n        switch (k.type) {\n          case \"JsdocTypeName\":\n            G = {\n              type: \"JsdocTypeProperty\",\n              value: k.value,\n              meta: {\n                quote: void 0\n              }\n            };\n            break;\n          case \"JsdocTypeNumber\":\n            G = {\n              type: \"JsdocTypeProperty\",\n              value: k.value.toString(10),\n              meta: {\n                quote: void 0\n              }\n            };\n            break;\n          case \"JsdocTypeStringValue\":\n            G = {\n              type: \"JsdocTypeProperty\",\n              value: k.value,\n              meta: {\n                quote: k.meta.quote\n              }\n            };\n            break;\n          case \"JsdocTypeSpecialNamePath\":\n            if (k.specialType === \"event\")\n              G = k;\n            else\n              throw new c(k, \"Type 'JsdocTypeSpecialNamePath' is only allowed with specialType 'event'\");\n            break;\n          default:\n            throw new c(k, \"Expecting 'JsdocTypeName', 'JsdocTypeNumber', 'JsdocStringValue' or 'JsdocTypeSpecialNamePath'\");\n        }\n        if (ae && !l.consume(\"]\")) {\n          let nt = l.lexer.current;\n          throw new Error(`Unterminated square brackets. Next token is '${nt.type}' with text '${nt.text}'`);\n        }\n        return {\n          type: \"JsdocTypeNamePath\",\n          left: J(d),\n          right: G,\n          pathType: O\n        };\n      }, \"namePathParslet\");\n    }\n    r(ee, \"createNamePathParslet\");\n    function R({ allowedAdditionalTokens: e }) {\n      return x({\n        name: \"nameParslet\",\n        accept: /* @__PURE__ */ r((t) => t === \"Identifier\" || t === \"this\" || t === \"new\" || e.includes(t), \"accept\"),\n        parsePrefix: /* @__PURE__ */ r((t) => {\n          let { type: o, text: i } = t.lexer.current;\n          return t.consume(o), {\n            type: \"JsdocTypeName\",\n            value: i\n          };\n        }, \"parsePrefix\")\n      });\n    }\n    r(R, \"createNameParslet\");\n    let Y = x({\n      name: \"stringValueParslet\",\n      accept: /* @__PURE__ */ r((e) => e === \"StringValue\", \"accept\"),\n      parsePrefix: /* @__PURE__ */ r((e) => {\n        let t = e.lexer.current.text;\n        return e.consume(\"StringValue\"), {\n          type: \"JsdocTypeStringValue\",\n          value: t.slice(1, -1),\n          meta: {\n            quote: t[0] === \"'\" ? \"single\" : \"double\"\n          }\n        };\n      }, \"parsePrefix\")\n    });\n    function te({ pathGrammar: e, allowedTypes: t }) {\n      return x({\n        name: \"specialNamePathParslet\",\n        accept: /* @__PURE__ */ r((o) => t.includes(o), \"accept\"),\n        parsePrefix: /* @__PURE__ */ r((o) => {\n          let i = o.lexer.current.type;\n          if (o.consume(i), !o.consume(\":\"))\n            return {\n              type: \"JsdocTypeName\",\n              value: i\n            };\n          let l, f = o.lexer.current;\n          if (o.consume(\"StringValue\"))\n            l = {\n              type: \"JsdocTypeSpecialNamePath\",\n              value: f.text.slice(1, -1),\n              specialType: i,\n              meta: {\n                quote: f.text[0] === \"'\" ? \"single\" : \"double\"\n              }\n            };\n          else {\n            let D = \"\", E = [\"Identifier\", \"@\", \"/\"];\n            for (; E.some((O) => o.consume(O)); )\n              D += f.text, f = o.lexer.current;\n            l = {\n              type: \"JsdocTypeSpecialNamePath\",\n              value: D,\n              specialType: i,\n              meta: {\n                quote: void 0\n              }\n            };\n          }\n          let d = new I(e, o.lexer, o), h = d.parseInfixIntermediateType(l, y.ALL);\n          return o.acceptLexerState(d), J(h);\n        }, \"parsePrefix\")\n      });\n    }\n    r(te, \"createSpecialNamePathParslet\");\n    let We = [\n      R({\n        allowedAdditionalTokens: [\"external\", \"module\"]\n      }),\n      Y,\n      Z,\n      ee({\n        allowSquareBracketsOnAnyType: !1,\n        allowJsdocNamePaths: !0,\n        pathGrammar: null\n      })\n    ], L = [\n      ...We,\n      te({\n        allowedTypes: [\"event\"],\n        pathGrammar: We\n      })\n    ];\n    function be(e) {\n      let t;\n      if (e.type === \"JsdocTypeParameterList\")\n        t = e.elements;\n      else if (e.type === \"JsdocTypeParenthesis\")\n        t = [e.element];\n      else\n        throw new c(e);\n      return t.map((o) => he(o));\n    }\n    r(be, \"getParameters\");\n    function Kt(e) {\n      let t = be(e);\n      if (t.some((o) => o.type === \"JsdocTypeKeyValue\"))\n        throw new Error(\"No parameter should be named\");\n      return t;\n    }\n    r(Kt, \"getUnnamedParameters\");\n    function Se({ allowNamedParameters: e, allowNoReturnType: t, allowWithoutParenthesis: o, allowNewAsFunctionKeyword: i }) {\n      return x({\n        name: \"functionParslet\",\n        accept: /* @__PURE__ */ r((l, f) => l === \"function\" || i && l === \"new\" && f === \"(\", \"accept\"),\n        parsePrefix: /* @__PURE__ */ r((l) => {\n          let f = l.consume(\"new\");\n          l.consume(\"function\");\n          let d = l.lexer.current.type === \"(\";\n          if (!d) {\n            if (!o)\n              throw new Error(\"function is missing parameter list\");\n            return {\n              type: \"JsdocTypeName\",\n              value: \"function\"\n            };\n          }\n          let h = {\n            type: \"JsdocTypeFunction\",\n            parameters: [],\n            arrow: !1,\n            constructor: f,\n            parenthesis: d\n          }, D = l.parseIntermediateType(y.FUNCTION);\n          if (e === void 0)\n            h.parameters = Kt(D);\n          else {\n            if (f && D.type === \"JsdocTypeFunction\" && D.arrow)\n              return h = D, h.constructor = !0, h;\n            h.parameters = be(D);\n            for (let E of h.parameters)\n              if (E.type === \"JsdocTypeKeyValue\" && !e.includes(E.key))\n                throw new Error(`only allowed named parameters are ${e.join(\", \")} but got ${E.type}`);\n          }\n          if (l.consume(\":\"))\n            h.returnType = l.parseType(y.PREFIX);\n          else if (!t)\n            throw new Error(\"function is missing return type\");\n          return h;\n        }, \"parsePrefix\")\n      });\n    }\n    r(Se, \"createFunctionParslet\");\n    function Ee({ allowPostfix: e, allowEnclosingBrackets: t }) {\n      return x({\n        name: \"variadicParslet\",\n        accept: /* @__PURE__ */ r((o) => o === \"...\", \"accept\"),\n        precedence: y.PREFIX,\n        parsePrefix: /* @__PURE__ */ r((o) => {\n          o.consume(\"...\");\n          let i = t && o.consume(\"[\");\n          try {\n            let l = o.parseType(y.PREFIX);\n            if (i && !o.consume(\"]\"))\n              throw new Error(\"Unterminated variadic type. Missing ']'\");\n            return {\n              type: \"JsdocTypeVariadic\",\n              element: J(l),\n              meta: {\n                position: \"prefix\",\n                squareBrackets: i\n              }\n            };\n          } catch (l) {\n            if (l instanceof a) {\n              if (i)\n                throw new Error(\"Empty square brackets for variadic are not allowed.\");\n              return {\n                type: \"JsdocTypeVariadic\",\n                meta: {\n                  position: void 0,\n                  squareBrackets: !1\n                }\n              };\n            } else\n              throw l;\n          }\n        }, \"parsePrefix\"),\n        parseInfix: e ? (o, i) => (o.consume(\"...\"), {\n          type: \"JsdocTypeVariadic\",\n          element: J(i),\n          meta: {\n            position: \"suffix\",\n            squareBrackets: !1\n          }\n        }) : void 0\n      });\n    }\n    r(Ee, \"createVariadicParslet\");\n    let Ge = x({\n      name: \"symbolParslet\",\n      accept: /* @__PURE__ */ r((e) => e === \"(\", \"accept\"),\n      precedence: y.SYMBOL,\n      parseInfix: /* @__PURE__ */ r((e, t) => {\n        if (t.type !== \"JsdocTypeName\")\n          throw new Error(\"Symbol expects a name on the left side. (Reacting on '(')\");\n        e.consume(\"(\");\n        let o = {\n          type: \"JsdocTypeSymbol\",\n          value: t.value\n        };\n        if (!e.consume(\")\")) {\n          let i = e.parseIntermediateType(y.SYMBOL);\n          if (o.element = _t(i), !e.consume(\")\"))\n            throw new Error(\"Symbol does not end after value\");\n        }\n        return o;\n      }, \"parseInfix\")\n    }), Xe = x({\n      name: \"arrayBracketsParslet\",\n      precedence: y.ARRAY_BRACKETS,\n      accept: /* @__PURE__ */ r((e, t) => e === \"[\" && t === \"]\", \"accept\"),\n      parseInfix: /* @__PURE__ */ r((e, t) => (e.consume(\"[\"), e.consume(\"]\"), {\n        type: \"JsdocTypeGeneric\",\n        left: {\n          type: \"JsdocTypeName\",\n          value: \"Array\"\n        },\n        elements: [\n          J(t)\n        ],\n        meta: {\n          brackets: \"square\",\n          dot: !1\n        }\n      }), \"parseInfix\")\n    });\n    function Ne({ objectFieldGrammar: e, allowKeyTypes: t }) {\n      return x({\n        name: \"objectParslet\",\n        accept: /* @__PURE__ */ r((o) => o === \"{\", \"accept\"),\n        parsePrefix: /* @__PURE__ */ r((o) => {\n          o.consume(\"{\");\n          let i = {\n            type: \"JsdocTypeObject\",\n            meta: {\n              separator: \"comma\"\n            },\n            elements: []\n          };\n          if (!o.consume(\"}\")) {\n            let l, f = new I(e, o.lexer, o);\n            for (; ; ) {\n              f.acceptLexerState(o);\n              let d = f.parseIntermediateType(y.OBJECT);\n              o.acceptLexerState(f), d === void 0 && t && (d = o.parseIntermediateType(y.OBJECT));\n              let h = !1;\n              if (d.type === \"JsdocTypeNullable\" && (h = !0, d = d.element), d.type === \"JsdocTypeNumber\" || d.type === \"JsdocTypeName\" || d.\n              type === \"JsdocTypeStringValue\") {\n                let E;\n                d.type === \"JsdocTypeStringValue\" && (E = d.meta.quote), i.elements.push({\n                  type: \"JsdocTypeObjectField\",\n                  key: d.value.toString(),\n                  right: void 0,\n                  optional: h,\n                  readonly: !1,\n                  meta: {\n                    quote: E\n                  }\n                });\n              } else if (d.type === \"JsdocTypeObjectField\" || d.type === \"JsdocTypeJsdocObjectField\")\n                i.elements.push(d);\n              else\n                throw new c(d);\n              if (o.lexer.current.startOfLine)\n                l = \"linebreak\";\n              else if (o.consume(\",\"))\n                l = \"comma\";\n              else if (o.consume(\";\"))\n                l = \"semicolon\";\n              else\n                break;\n              if (o.lexer.current.type === \"}\")\n                break;\n            }\n            if (i.meta.separator = l ?? \"comma\", !o.consume(\"}\"))\n              throw new Error(\"Unterminated record type. Missing '}'\");\n          }\n          return i;\n        }, \"parsePrefix\")\n      });\n    }\n    r(Ne, \"createObjectParslet\");\n    function De({ allowSquaredProperties: e, allowKeyTypes: t, allowReadonly: o, allowOptional: i }) {\n      return x({\n        name: \"objectFieldParslet\",\n        precedence: y.KEY_VALUE,\n        accept: /* @__PURE__ */ r((l) => l === \":\", \"accept\"),\n        parseInfix: /* @__PURE__ */ r((l, f) => {\n          var d;\n          let h = !1, D = !1;\n          i && f.type === \"JsdocTypeNullable\" && (h = !0, f = f.element), o && f.type === \"JsdocTypeReadonlyProperty\" && (D = !0, f = f.element);\n          let E = (d = l.baseParser) !== null && d !== void 0 ? d : l;\n          if (E.acceptLexerState(l), f.type === \"JsdocTypeNumber\" || f.type === \"JsdocTypeName\" || f.type === \"JsdocTypeStringValue\" || Je(f)) {\n            if (Je(f) && !e)\n              throw new c(f);\n            E.consume(\":\");\n            let O;\n            f.type === \"JsdocTypeStringValue\" && (O = f.meta.quote);\n            let ae = E.parseType(y.KEY_VALUE);\n            return l.acceptLexerState(E), {\n              type: \"JsdocTypeObjectField\",\n              key: Je(f) ? f : f.value.toString(),\n              right: ae,\n              optional: h,\n              readonly: D,\n              meta: {\n                quote: O\n              }\n            };\n          } else {\n            if (!t)\n              throw new c(f);\n            E.consume(\":\");\n            let O = E.parseType(y.KEY_VALUE);\n            return l.acceptLexerState(E), {\n              type: \"JsdocTypeJsdocObjectField\",\n              left: J(f),\n              right: O\n            };\n          }\n        }, \"parseInfix\")\n      });\n    }\n    r(De, \"createObjectFieldParslet\");\n    function Oe({ allowOptional: e, allowVariadic: t }) {\n      return x({\n        name: \"keyValueParslet\",\n        precedence: y.KEY_VALUE,\n        accept: /* @__PURE__ */ r((o) => o === \":\", \"accept\"),\n        parseInfix: /* @__PURE__ */ r((o, i) => {\n          let l = !1, f = !1;\n          if (e && i.type === \"JsdocTypeNullable\" && (l = !0, i = i.element), t && i.type === \"JsdocTypeVariadic\" && i.element !== void 0 &&\n          (f = !0, i = i.element), i.type !== \"JsdocTypeName\")\n            throw new c(i);\n          o.consume(\":\");\n          let d = o.parseType(y.KEY_VALUE);\n          return {\n            type: \"JsdocTypeKeyValue\",\n            key: i.value,\n            right: d,\n            optional: l,\n            variadic: f\n          };\n        }, \"parseInfix\")\n      });\n    }\n    r(Oe, \"createKeyValueParslet\");\n    let ze = [\n      ...Pe,\n      Se({\n        allowWithoutParenthesis: !0,\n        allowNamedParameters: [\"this\", \"new\"],\n        allowNoReturnType: !0,\n        allowNewAsFunctionKeyword: !1\n      }),\n      Y,\n      te({\n        allowedTypes: [\"module\", \"external\", \"event\"],\n        pathGrammar: L\n      }),\n      Ee({\n        allowEnclosingBrackets: !0,\n        allowPostfix: !0\n      }),\n      R({\n        allowedAdditionalTokens: [\"keyof\"]\n      }),\n      Ge,\n      Xe,\n      ee({\n        allowSquareBracketsOnAnyType: !1,\n        allowJsdocNamePaths: !0,\n        pathGrammar: L\n      })\n    ], $t = [\n      ...ze,\n      Ne({\n        // jsdoc syntax allows full types as keys, so we need to pull in the full grammar here\n        // we leave out the object type deliberately\n        objectFieldGrammar: [\n          R({\n            allowedAdditionalTokens: [\"module\", \"in\"]\n          }),\n          De({\n            allowSquaredProperties: !1,\n            allowKeyTypes: !0,\n            allowOptional: !1,\n            allowReadonly: !1\n          }),\n          ...ze\n        ],\n        allowKeyTypes: !0\n      }),\n      Oe({\n        allowOptional: !0,\n        allowVariadic: !0\n      })\n    ], He = x({\n      name: \"typeOfParslet\",\n      accept: /* @__PURE__ */ r((e) => e === \"typeof\", \"accept\"),\n      parsePrefix: /* @__PURE__ */ r((e) => (e.consume(\"typeof\"), {\n        type: \"JsdocTypeTypeof\",\n        element: J(e.parseType(y.KEY_OF_TYPE_OF))\n      }), \"parsePrefix\")\n    }), qt = [\n      R({\n        allowedAdditionalTokens: [\"module\", \"keyof\", \"event\", \"external\", \"in\"]\n      }),\n      we,\n      Q,\n      Y,\n      Z,\n      De({\n        allowSquaredProperties: !1,\n        allowKeyTypes: !1,\n        allowOptional: !1,\n        allowReadonly: !1\n      })\n    ], Yt = [\n      ...Pe,\n      Ne({\n        allowKeyTypes: !1,\n        objectFieldGrammar: qt\n      }),\n      R({\n        allowedAdditionalTokens: [\"event\", \"external\", \"in\"]\n      }),\n      He,\n      Se({\n        allowWithoutParenthesis: !1,\n        allowNamedParameters: [\"this\", \"new\"],\n        allowNoReturnType: !0,\n        allowNewAsFunctionKeyword: !1\n      }),\n      Ee({\n        allowEnclosingBrackets: !1,\n        allowPostfix: !1\n      }),\n      // additional name parslet is needed for some special cases\n      R({\n        allowedAdditionalTokens: [\"keyof\"]\n      }),\n      te({\n        allowedTypes: [\"module\"],\n        pathGrammar: L\n      }),\n      ee({\n        allowSquareBracketsOnAnyType: !1,\n        allowJsdocNamePaths: !0,\n        pathGrammar: L\n      }),\n      Oe({\n        allowOptional: !1,\n        allowVariadic: !1\n      }),\n      Ge\n    ], Wt = x({\n      name: \"assertsParslet\",\n      accept: /* @__PURE__ */ r((e) => e === \"asserts\", \"accept\"),\n      parsePrefix: /* @__PURE__ */ r((e) => {\n        e.consume(\"asserts\");\n        let t = e.parseIntermediateType(y.SYMBOL);\n        if (t.type !== \"JsdocTypeName\")\n          throw new c(t, \"A typescript asserts always has to have a name on the left side.\");\n        return e.consume(\"is\"), {\n          type: \"JsdocTypeAsserts\",\n          left: t,\n          right: J(e.parseIntermediateType(y.INFIX))\n        };\n      }, \"parsePrefix\")\n    });\n    function Gt({ allowQuestionMark: e }) {\n      return x({\n        name: \"tupleParslet\",\n        accept: /* @__PURE__ */ r((t) => t === \"[\", \"accept\"),\n        parsePrefix: /* @__PURE__ */ r((t) => {\n          t.consume(\"[\");\n          let o = {\n            type: \"JsdocTypeTuple\",\n            elements: []\n          };\n          if (t.consume(\"]\"))\n            return o;\n          let i = t.parseIntermediateType(y.ALL);\n          if (i.type === \"JsdocTypeParameterList\" ? i.elements[0].type === \"JsdocTypeKeyValue\" ? o.elements = i.elements.map(H) : o.elements =\n          i.elements.map(J) : i.type === \"JsdocTypeKeyValue\" ? o.elements = [H(i)] : o.elements = [J(i)], !t.consume(\"]\"))\n            throw new Error(\"Unterminated '['\");\n          if (!e && o.elements.some((l) => l.type === \"JsdocTypeUnknown\"))\n            throw new Error(\"Question mark in tuple not allowed\");\n          return o;\n        }, \"parsePrefix\")\n      });\n    }\n    r(Gt, \"createTupleParslet\");\n    let Xt = x({\n      name: \"keyOfParslet\",\n      accept: /* @__PURE__ */ r((e) => e === \"keyof\", \"accept\"),\n      parsePrefix: /* @__PURE__ */ r((e) => (e.consume(\"keyof\"), {\n        type: \"JsdocTypeKeyof\",\n        element: J(e.parseType(y.KEY_OF_TYPE_OF))\n      }), \"parsePrefix\")\n    }), zt = x({\n      name: \"importParslet\",\n      accept: /* @__PURE__ */ r((e) => e === \"import\", \"accept\"),\n      parsePrefix: /* @__PURE__ */ r((e) => {\n        if (e.consume(\"import\"), !e.consume(\"(\"))\n          throw new Error(\"Missing parenthesis after import keyword\");\n        let t = e.parseType(y.PREFIX);\n        if (t.type !== \"JsdocTypeStringValue\")\n          throw new Error(\"Only string values are allowed as paths for imports\");\n        if (!e.consume(\")\"))\n          throw new Error(\"Missing closing parenthesis after import keyword\");\n        return {\n          type: \"JsdocTypeImport\",\n          element: t\n        };\n      }, \"parsePrefix\")\n    }), Ht = x({\n      name: \"readonlyPropertyParslet\",\n      accept: /* @__PURE__ */ r((e) => e === \"readonly\", \"accept\"),\n      parsePrefix: /* @__PURE__ */ r((e) => (e.consume(\"readonly\"), {\n        type: \"JsdocTypeReadonlyProperty\",\n        element: e.parseType(y.KEY_VALUE)\n      }), \"parsePrefix\")\n    }), Qt = x({\n      name: \"arrowFunctionParslet\",\n      precedence: y.ARROW,\n      accept: /* @__PURE__ */ r((e) => e === \"=>\", \"accept\"),\n      parseInfix: /* @__PURE__ */ r((e, t) => (e.consume(\"=>\"), {\n        type: \"JsdocTypeFunction\",\n        parameters: be(t).map(Ft),\n        arrow: !0,\n        constructor: !1,\n        parenthesis: !0,\n        returnType: e.parseType(y.OBJECT)\n      }), \"parseInfix\")\n    }), Zt = x({\n      name: \"intersectionParslet\",\n      accept: /* @__PURE__ */ r((e) => e === \"&\", \"accept\"),\n      precedence: y.INTERSECTION,\n      parseInfix: /* @__PURE__ */ r((e, t) => {\n        e.consume(\"&\");\n        let o = [];\n        do\n          o.push(e.parseType(y.INTERSECTION));\n        while (e.consume(\"&\"));\n        return {\n          type: \"JsdocTypeIntersection\",\n          elements: [J(t), ...o]\n        };\n      }, \"parseInfix\")\n    }), er = x({\n      name: \"predicateParslet\",\n      precedence: y.INFIX,\n      accept: /* @__PURE__ */ r((e) => e === \"is\", \"accept\"),\n      parseInfix: /* @__PURE__ */ r((e, t) => {\n        if (t.type !== \"JsdocTypeName\")\n          throw new c(t, \"A typescript predicate always has to have a name on the left side.\");\n        return e.consume(\"is\"), {\n          type: \"JsdocTypePredicate\",\n          left: t,\n          right: J(e.parseIntermediateType(y.INFIX))\n        };\n      }, \"parseInfix\")\n    }), tr = x({\n      name: \"objectSquareBracketPropertyParslet\",\n      accept: /* @__PURE__ */ r((e) => e === \"[\", \"accept\"),\n      parsePrefix: /* @__PURE__ */ r((e) => {\n        if (e.baseParser === void 0)\n          throw new Error(\"Only allowed inside object grammar\");\n        e.consume(\"[\");\n        let t = e.lexer.current.text;\n        e.consume(\"Identifier\");\n        let o;\n        if (e.consume(\":\")) {\n          let i = e.baseParser;\n          i.acceptLexerState(e), o = {\n            type: \"JsdocTypeIndexSignature\",\n            key: t,\n            right: i.parseType(y.INDEX_BRACKETS)\n          }, e.acceptLexerState(i);\n        } else if (e.consume(\"in\")) {\n          let i = e.baseParser;\n          i.acceptLexerState(e), o = {\n            type: \"JsdocTypeMappedType\",\n            key: t,\n            right: i.parseType(y.ARRAY_BRACKETS)\n          }, e.acceptLexerState(i);\n        } else\n          throw new Error(\"Missing ':' or 'in' inside square bracketed property.\");\n        if (!e.consume(\"]\"))\n          throw new Error(\"Unterminated square brackets\");\n        return o;\n      }, \"parsePrefix\")\n    }), rr = [\n      Ht,\n      R({\n        allowedAdditionalTokens: [\"module\", \"event\", \"keyof\", \"event\", \"external\", \"in\"]\n      }),\n      we,\n      Q,\n      Y,\n      Z,\n      De({\n        allowSquaredProperties: !0,\n        allowKeyTypes: !1,\n        allowOptional: !0,\n        allowReadonly: !0\n      }),\n      tr\n    ], nr = [\n      ...Pe,\n      Ne({\n        allowKeyTypes: !1,\n        objectFieldGrammar: rr\n      }),\n      He,\n      Xt,\n      zt,\n      Y,\n      Se({\n        allowWithoutParenthesis: !0,\n        allowNoReturnType: !1,\n        allowNamedParameters: [\"this\", \"new\", \"args\"],\n        allowNewAsFunctionKeyword: !0\n      }),\n      Gt({\n        allowQuestionMark: !1\n      }),\n      Ee({\n        allowEnclosingBrackets: !1,\n        allowPostfix: !1\n      }),\n      Wt,\n      R({\n        allowedAdditionalTokens: [\"event\", \"external\", \"in\"]\n      }),\n      te({\n        allowedTypes: [\"module\"],\n        pathGrammar: L\n      }),\n      Xe,\n      Qt,\n      ee({\n        allowSquareBracketsOnAnyType: !0,\n        allowJsdocNamePaths: !1,\n        pathGrammar: L\n      }),\n      Zt,\n      er,\n      Oe({\n        allowVariadic: !0,\n        allowOptional: !0\n      })\n    ];\n    function Qe(e, t) {\n      switch (t) {\n        case \"closure\":\n          return new I(Yt, e).parse();\n        case \"jsdoc\":\n          return new I($t, e).parse();\n        case \"typescript\":\n          return new I(nr, e).parse();\n      }\n    }\n    r(Qe, \"parse\");\n    function or(e, t = [\"typescript\", \"closure\", \"jsdoc\"]) {\n      let o;\n      for (let i of t)\n        try {\n          return Qe(e, i);\n        } catch (l) {\n          o = l;\n        }\n      throw o;\n    }\n    r(or, \"tryParse\");\n    function W(e, t) {\n      let o = e[t.type];\n      if (o === void 0)\n        throw new Error(`In this set of transform rules exists no rule for type ${t.type}.`);\n      return o(t, (i) => W(e, i));\n    }\n    r(W, \"transform\");\n    function N(e) {\n      throw new Error(\"This transform is not available. Are you trying the correct parsing mode?\");\n    }\n    r(N, \"notAvailableTransform\");\n    function Ze(e) {\n      let t = {\n        params: []\n      };\n      for (let o of e.parameters)\n        o.type === \"JsdocTypeKeyValue\" ? o.key === \"this\" ? t.this = o.right : o.key === \"new\" ? t.new = o.right : t.params.push(o) : t.params.\n        push(o);\n      return t;\n    }\n    r(Ze, \"extractSpecialParams\");\n    function re(e, t, o) {\n      return e === \"prefix\" ? o + t : t + o;\n    }\n    r(re, \"applyPosition\");\n    function j(e, t) {\n      switch (t) {\n        case \"double\":\n          return `\"${e}\"`;\n        case \"single\":\n          return `'${e}'`;\n        case void 0:\n          return e;\n      }\n    }\n    r(j, \"quote\");\n    function et() {\n      return {\n        JsdocTypeParenthesis: /* @__PURE__ */ r((e, t) => `(${e.element !== void 0 ? t(e.element) : \"\"})`, \"JsdocTypeParenthesis\"),\n        JsdocTypeKeyof: /* @__PURE__ */ r((e, t) => `keyof ${t(e.element)}`, \"JsdocTypeKeyof\"),\n        JsdocTypeFunction: /* @__PURE__ */ r((e, t) => {\n          if (e.arrow) {\n            if (e.returnType === void 0)\n              throw new Error(\"Arrow function needs a return type.\");\n            let o = `(${e.parameters.map(t).join(\", \")}) => ${t(e.returnType)}`;\n            return e.constructor && (o = \"new \" + o), o;\n          } else {\n            let o = e.constructor ? \"new\" : \"function\";\n            return e.parenthesis && (o += `(${e.parameters.map(t).join(\", \")})`, e.returnType !== void 0 && (o += `: ${t(e.returnType)}`)), o;\n          }\n        }, \"JsdocTypeFunction\"),\n        JsdocTypeName: /* @__PURE__ */ r((e) => e.value, \"JsdocTypeName\"),\n        JsdocTypeTuple: /* @__PURE__ */ r((e, t) => `[${e.elements.map(t).join(\", \")}]`, \"JsdocTypeTuple\"),\n        JsdocTypeVariadic: /* @__PURE__ */ r((e, t) => e.meta.position === void 0 ? \"...\" : re(e.meta.position, t(e.element), \"...\"), \"Jsdoc\\\nTypeVariadic\"),\n        JsdocTypeNamePath: /* @__PURE__ */ r((e, t) => {\n          let o = t(e.left), i = t(e.right);\n          switch (e.pathType) {\n            case \"inner\":\n              return `${o}~${i}`;\n            case \"instance\":\n              return `${o}#${i}`;\n            case \"property\":\n              return `${o}.${i}`;\n            case \"property-brackets\":\n              return `${o}[${i}]`;\n          }\n        }, \"JsdocTypeNamePath\"),\n        JsdocTypeStringValue: /* @__PURE__ */ r((e) => j(e.value, e.meta.quote), \"JsdocTypeStringValue\"),\n        JsdocTypeAny: /* @__PURE__ */ r(() => \"*\", \"JsdocTypeAny\"),\n        JsdocTypeGeneric: /* @__PURE__ */ r((e, t) => {\n          if (e.meta.brackets === \"square\") {\n            let o = e.elements[0], i = t(o);\n            return o.type === \"JsdocTypeUnion\" || o.type === \"JsdocTypeIntersection\" ? `(${i})[]` : `${i}[]`;\n          } else\n            return `${t(e.left)}${e.meta.dot ? \".\" : \"\"}<${e.elements.map(t).join(\", \")}>`;\n        }, \"JsdocTypeGeneric\"),\n        JsdocTypeImport: /* @__PURE__ */ r((e, t) => `import(${t(e.element)})`, \"JsdocTypeImport\"),\n        JsdocTypeObjectField: /* @__PURE__ */ r((e, t) => {\n          let o = \"\";\n          return e.readonly && (o += \"readonly \"), typeof e.key == \"string\" ? o += j(e.key, e.meta.quote) : o += t(e.key), e.optional && (o +=\n          \"?\"), e.right === void 0 ? o : o + `: ${t(e.right)}`;\n        }, \"JsdocTypeObjectField\"),\n        JsdocTypeJsdocObjectField: /* @__PURE__ */ r((e, t) => `${t(e.left)}: ${t(e.right)}`, \"JsdocTypeJsdocObjectField\"),\n        JsdocTypeKeyValue: /* @__PURE__ */ r((e, t) => {\n          let o = e.key;\n          return e.optional && (o += \"?\"), e.variadic && (o = \"...\" + o), e.right === void 0 ? o : o + `: ${t(e.right)}`;\n        }, \"JsdocTypeKeyValue\"),\n        JsdocTypeSpecialNamePath: /* @__PURE__ */ r((e) => `${e.specialType}:${j(e.value, e.meta.quote)}`, \"JsdocTypeSpecialNamePath\"),\n        JsdocTypeNotNullable: /* @__PURE__ */ r((e, t) => re(e.meta.position, t(e.element), \"!\"), \"JsdocTypeNotNullable\"),\n        JsdocTypeNull: /* @__PURE__ */ r(() => \"null\", \"JsdocTypeNull\"),\n        JsdocTypeNullable: /* @__PURE__ */ r((e, t) => re(e.meta.position, t(e.element), \"?\"), \"JsdocTypeNullable\"),\n        JsdocTypeNumber: /* @__PURE__ */ r((e) => e.value.toString(), \"JsdocTypeNumber\"),\n        JsdocTypeObject: /* @__PURE__ */ r((e, t) => `{${e.elements.map(t).join((e.meta.separator === \"comma\" ? \",\" : \";\") + \" \")}}`, \"Jsdoc\\\nTypeObject\"),\n        JsdocTypeOptional: /* @__PURE__ */ r((e, t) => re(e.meta.position, t(e.element), \"=\"), \"JsdocTypeOptional\"),\n        JsdocTypeSymbol: /* @__PURE__ */ r((e, t) => `${e.value}(${e.element !== void 0 ? t(e.element) : \"\"})`, \"JsdocTypeSymbol\"),\n        JsdocTypeTypeof: /* @__PURE__ */ r((e, t) => `typeof ${t(e.element)}`, \"JsdocTypeTypeof\"),\n        JsdocTypeUndefined: /* @__PURE__ */ r(() => \"undefined\", \"JsdocTypeUndefined\"),\n        JsdocTypeUnion: /* @__PURE__ */ r((e, t) => e.elements.map(t).join(\" | \"), \"JsdocTypeUnion\"),\n        JsdocTypeUnknown: /* @__PURE__ */ r(() => \"?\", \"JsdocTypeUnknown\"),\n        JsdocTypeIntersection: /* @__PURE__ */ r((e, t) => e.elements.map(t).join(\" & \"), \"JsdocTypeIntersection\"),\n        JsdocTypeProperty: /* @__PURE__ */ r((e) => j(e.value, e.meta.quote), \"JsdocTypeProperty\"),\n        JsdocTypePredicate: /* @__PURE__ */ r((e, t) => `${t(e.left)} is ${t(e.right)}`, \"JsdocTypePredicate\"),\n        JsdocTypeIndexSignature: /* @__PURE__ */ r((e, t) => `[${e.key}: ${t(e.right)}]`, \"JsdocTypeIndexSignature\"),\n        JsdocTypeMappedType: /* @__PURE__ */ r((e, t) => `[${e.key} in ${t(e.right)}]`, \"JsdocTypeMappedType\"),\n        JsdocTypeAsserts: /* @__PURE__ */ r((e, t) => `asserts ${t(e.left)} is ${t(e.right)}`, \"JsdocTypeAsserts\")\n      };\n    }\n    r(et, \"stringifyRules\");\n    let sr = et();\n    function ar(e) {\n      return W(sr, e);\n    }\n    r(ar, \"stringify\");\n    let ir = [\n      \"null\",\n      \"true\",\n      \"false\",\n      \"break\",\n      \"case\",\n      \"catch\",\n      \"class\",\n      \"const\",\n      \"continue\",\n      \"debugger\",\n      \"default\",\n      \"delete\",\n      \"do\",\n      \"else\",\n      \"export\",\n      \"extends\",\n      \"finally\",\n      \"for\",\n      \"function\",\n      \"if\",\n      \"import\",\n      \"in\",\n      \"instanceof\",\n      \"new\",\n      \"return\",\n      \"super\",\n      \"switch\",\n      \"this\",\n      \"throw\",\n      \"try\",\n      \"typeof\",\n      \"var\",\n      \"void\",\n      \"while\",\n      \"with\",\n      \"yield\"\n    ];\n    function F(e) {\n      let t = {\n        type: \"NameExpression\",\n        name: e\n      };\n      return ir.includes(e) && (t.reservedWord = !0), t;\n    }\n    r(F, \"makeName\");\n    let pr = {\n      JsdocTypeOptional: /* @__PURE__ */ r((e, t) => {\n        let o = t(e.element);\n        return o.optional = !0, o;\n      }, \"JsdocTypeOptional\"),\n      JsdocTypeNullable: /* @__PURE__ */ r((e, t) => {\n        let o = t(e.element);\n        return o.nullable = !0, o;\n      }, \"JsdocTypeNullable\"),\n      JsdocTypeNotNullable: /* @__PURE__ */ r((e, t) => {\n        let o = t(e.element);\n        return o.nullable = !1, o;\n      }, \"JsdocTypeNotNullable\"),\n      JsdocTypeVariadic: /* @__PURE__ */ r((e, t) => {\n        if (e.element === void 0)\n          throw new Error(\"dots without value are not allowed in catharsis mode\");\n        let o = t(e.element);\n        return o.repeatable = !0, o;\n      }, \"JsdocTypeVariadic\"),\n      JsdocTypeAny: /* @__PURE__ */ r(() => ({\n        type: \"AllLiteral\"\n      }), \"JsdocTypeAny\"),\n      JsdocTypeNull: /* @__PURE__ */ r(() => ({\n        type: \"NullLiteral\"\n      }), \"JsdocTypeNull\"),\n      JsdocTypeStringValue: /* @__PURE__ */ r((e) => F(j(e.value, e.meta.quote)), \"JsdocTypeStringValue\"),\n      JsdocTypeUndefined: /* @__PURE__ */ r(() => ({\n        type: \"UndefinedLiteral\"\n      }), \"JsdocTypeUndefined\"),\n      JsdocTypeUnknown: /* @__PURE__ */ r(() => ({\n        type: \"UnknownLiteral\"\n      }), \"JsdocTypeUnknown\"),\n      JsdocTypeFunction: /* @__PURE__ */ r((e, t) => {\n        let o = Ze(e), i = {\n          type: \"FunctionType\",\n          params: o.params.map(t)\n        };\n        return o.this !== void 0 && (i.this = t(o.this)), o.new !== void 0 && (i.new = t(o.new)), e.returnType !== void 0 && (i.result = t(e.\n        returnType)), i;\n      }, \"JsdocTypeFunction\"),\n      JsdocTypeGeneric: /* @__PURE__ */ r((e, t) => ({\n        type: \"TypeApplication\",\n        applications: e.elements.map((o) => t(o)),\n        expression: t(e.left)\n      }), \"JsdocTypeGeneric\"),\n      JsdocTypeSpecialNamePath: /* @__PURE__ */ r((e) => F(e.specialType + \":\" + j(e.value, e.meta.quote)), \"JsdocTypeSpecialNamePath\"),\n      JsdocTypeName: /* @__PURE__ */ r((e) => e.value !== \"function\" ? F(e.value) : {\n        type: \"FunctionType\",\n        params: []\n      }, \"JsdocTypeName\"),\n      JsdocTypeNumber: /* @__PURE__ */ r((e) => F(e.value.toString()), \"JsdocTypeNumber\"),\n      JsdocTypeObject: /* @__PURE__ */ r((e, t) => {\n        let o = {\n          type: \"RecordType\",\n          fields: []\n        };\n        for (let i of e.elements)\n          i.type !== \"JsdocTypeObjectField\" && i.type !== \"JsdocTypeJsdocObjectField\" ? o.fields.push({\n            type: \"FieldType\",\n            key: t(i),\n            value: void 0\n          }) : o.fields.push(t(i));\n        return o;\n      }, \"JsdocTypeObject\"),\n      JsdocTypeObjectField: /* @__PURE__ */ r((e, t) => {\n        if (typeof e.key != \"string\")\n          throw new Error(\"Index signatures and mapped types are not supported\");\n        return {\n          type: \"FieldType\",\n          key: F(j(e.key, e.meta.quote)),\n          value: e.right === void 0 ? void 0 : t(e.right)\n        };\n      }, \"JsdocTypeObjectField\"),\n      JsdocTypeJsdocObjectField: /* @__PURE__ */ r((e, t) => ({\n        type: \"FieldType\",\n        key: t(e.left),\n        value: t(e.right)\n      }), \"JsdocTypeJsdocObjectField\"),\n      JsdocTypeUnion: /* @__PURE__ */ r((e, t) => ({\n        type: \"TypeUnion\",\n        elements: e.elements.map((o) => t(o))\n      }), \"JsdocTypeUnion\"),\n      JsdocTypeKeyValue: /* @__PURE__ */ r((e, t) => ({\n        type: \"FieldType\",\n        key: F(e.key),\n        value: e.right === void 0 ? void 0 : t(e.right)\n      }), \"JsdocTypeKeyValue\"),\n      JsdocTypeNamePath: /* @__PURE__ */ r((e, t) => {\n        let o = t(e.left), i;\n        e.right.type === \"JsdocTypeSpecialNamePath\" ? i = t(e.right).name : i = j(e.right.value, e.right.meta.quote);\n        let l = e.pathType === \"inner\" ? \"~\" : e.pathType === \"instance\" ? \"#\" : \".\";\n        return F(`${o.name}${l}${i}`);\n      }, \"JsdocTypeNamePath\"),\n      JsdocTypeSymbol: /* @__PURE__ */ r((e) => {\n        let t = \"\", o = e.element, i = !1;\n        return o?.type === \"JsdocTypeVariadic\" && (o.meta.position === \"prefix\" ? t = \"...\" : i = !0, o = o.element), o?.type === \"JsdocType\\\nName\" ? t += o.value : o?.type === \"JsdocTypeNumber\" && (t += o.value.toString()), i && (t += \"...\"), F(`${e.value}(${t})`);\n      }, \"JsdocTypeSymbol\"),\n      JsdocTypeParenthesis: /* @__PURE__ */ r((e, t) => t(J(e.element)), \"JsdocTypeParenthesis\"),\n      JsdocTypeMappedType: N,\n      JsdocTypeIndexSignature: N,\n      JsdocTypeImport: N,\n      JsdocTypeKeyof: N,\n      JsdocTypeTuple: N,\n      JsdocTypeTypeof: N,\n      JsdocTypeIntersection: N,\n      JsdocTypeProperty: N,\n      JsdocTypePredicate: N,\n      JsdocTypeAsserts: N\n    };\n    function cr(e) {\n      return W(pr, e);\n    }\n    r(cr, \"catharsisTransform\");\n    function V(e) {\n      switch (e) {\n        case void 0:\n          return \"none\";\n        case \"single\":\n          return \"single\";\n        case \"double\":\n          return \"double\";\n      }\n    }\n    r(V, \"getQuoteStyle\");\n    function lr(e) {\n      switch (e) {\n        case \"inner\":\n          return \"INNER_MEMBER\";\n        case \"instance\":\n          return \"INSTANCE_MEMBER\";\n        case \"property\":\n          return \"MEMBER\";\n        case \"property-brackets\":\n          return \"MEMBER\";\n      }\n    }\n    r(lr, \"getMemberType\");\n    function ve(e, t) {\n      return t.length === 2 ? {\n        type: e,\n        left: t[0],\n        right: t[1]\n      } : {\n        type: e,\n        left: t[0],\n        right: ve(e, t.slice(1))\n      };\n    }\n    r(ve, \"nestResults\");\n    let ur = {\n      JsdocTypeOptional: /* @__PURE__ */ r((e, t) => ({\n        type: \"OPTIONAL\",\n        value: t(e.element),\n        meta: {\n          syntax: e.meta.position === \"prefix\" ? \"PREFIX_EQUAL_SIGN\" : \"SUFFIX_EQUALS_SIGN\"\n        }\n      }), \"JsdocTypeOptional\"),\n      JsdocTypeNullable: /* @__PURE__ */ r((e, t) => ({\n        type: \"NULLABLE\",\n        value: t(e.element),\n        meta: {\n          syntax: e.meta.position === \"prefix\" ? \"PREFIX_QUESTION_MARK\" : \"SUFFIX_QUESTION_MARK\"\n        }\n      }), \"JsdocTypeNullable\"),\n      JsdocTypeNotNullable: /* @__PURE__ */ r((e, t) => ({\n        type: \"NOT_NULLABLE\",\n        value: t(e.element),\n        meta: {\n          syntax: e.meta.position === \"prefix\" ? \"PREFIX_BANG\" : \"SUFFIX_BANG\"\n        }\n      }), \"JsdocTypeNotNullable\"),\n      JsdocTypeVariadic: /* @__PURE__ */ r((e, t) => {\n        let o = {\n          type: \"VARIADIC\",\n          meta: {\n            syntax: e.meta.position === \"prefix\" ? \"PREFIX_DOTS\" : e.meta.position === \"suffix\" ? \"SUFFIX_DOTS\" : \"ONLY_DOTS\"\n          }\n        };\n        return e.element !== void 0 && (o.value = t(e.element)), o;\n      }, \"JsdocTypeVariadic\"),\n      JsdocTypeName: /* @__PURE__ */ r((e) => ({\n        type: \"NAME\",\n        name: e.value\n      }), \"JsdocTypeName\"),\n      JsdocTypeTypeof: /* @__PURE__ */ r((e, t) => ({\n        type: \"TYPE_QUERY\",\n        name: t(e.element)\n      }), \"JsdocTypeTypeof\"),\n      JsdocTypeTuple: /* @__PURE__ */ r((e, t) => ({\n        type: \"TUPLE\",\n        entries: e.elements.map(t)\n      }), \"JsdocTypeTuple\"),\n      JsdocTypeKeyof: /* @__PURE__ */ r((e, t) => ({\n        type: \"KEY_QUERY\",\n        value: t(e.element)\n      }), \"JsdocTypeKeyof\"),\n      JsdocTypeImport: /* @__PURE__ */ r((e) => ({\n        type: \"IMPORT\",\n        path: {\n          type: \"STRING_VALUE\",\n          quoteStyle: V(e.element.meta.quote),\n          string: e.element.value\n        }\n      }), \"JsdocTypeImport\"),\n      JsdocTypeUndefined: /* @__PURE__ */ r(() => ({\n        type: \"NAME\",\n        name: \"undefined\"\n      }), \"JsdocTypeUndefined\"),\n      JsdocTypeAny: /* @__PURE__ */ r(() => ({\n        type: \"ANY\"\n      }), \"JsdocTypeAny\"),\n      JsdocTypeFunction: /* @__PURE__ */ r((e, t) => {\n        let o = Ze(e), i = {\n          type: e.arrow ? \"ARROW\" : \"FUNCTION\",\n          params: o.params.map((l) => {\n            if (l.type === \"JsdocTypeKeyValue\") {\n              if (l.right === void 0)\n                throw new Error(\"Function parameter without ':' is not expected to be 'KEY_VALUE'\");\n              return {\n                type: \"NAMED_PARAMETER\",\n                name: l.key,\n                typeName: t(l.right)\n              };\n            } else\n              return t(l);\n          }),\n          new: null,\n          returns: null\n        };\n        return o.this !== void 0 ? i.this = t(o.this) : e.arrow || (i.this = null), o.new !== void 0 && (i.new = t(o.new)), e.returnType !==\n        void 0 && (i.returns = t(e.returnType)), i;\n      }, \"JsdocTypeFunction\"),\n      JsdocTypeGeneric: /* @__PURE__ */ r((e, t) => {\n        let o = {\n          type: \"GENERIC\",\n          subject: t(e.left),\n          objects: e.elements.map(t),\n          meta: {\n            syntax: e.meta.brackets === \"square\" ? \"SQUARE_BRACKET\" : e.meta.dot ? \"ANGLE_BRACKET_WITH_DOT\" : \"ANGLE_BRACKET\"\n          }\n        };\n        return e.meta.brackets === \"square\" && e.elements[0].type === \"JsdocTypeFunction\" && !e.elements[0].parenthesis && (o.objects[0] = {\n          type: \"NAME\",\n          name: \"function\"\n        }), o;\n      }, \"JsdocTypeGeneric\"),\n      JsdocTypeObjectField: /* @__PURE__ */ r((e, t) => {\n        if (typeof e.key != \"string\")\n          throw new Error(\"Index signatures and mapped types are not supported\");\n        if (e.right === void 0)\n          return {\n            type: \"RECORD_ENTRY\",\n            key: e.key,\n            quoteStyle: V(e.meta.quote),\n            value: null,\n            readonly: !1\n          };\n        let o = t(e.right);\n        return e.optional && (o = {\n          type: \"OPTIONAL\",\n          value: o,\n          meta: {\n            syntax: \"SUFFIX_KEY_QUESTION_MARK\"\n          }\n        }), {\n          type: \"RECORD_ENTRY\",\n          key: e.key.toString(),\n          quoteStyle: V(e.meta.quote),\n          value: o,\n          readonly: !1\n        };\n      }, \"JsdocTypeObjectField\"),\n      JsdocTypeJsdocObjectField: /* @__PURE__ */ r(() => {\n        throw new Error(\"Keys may not be typed in jsdoctypeparser.\");\n      }, \"JsdocTypeJsdocObjectField\"),\n      JsdocTypeKeyValue: /* @__PURE__ */ r((e, t) => {\n        if (e.right === void 0)\n          return {\n            type: \"RECORD_ENTRY\",\n            key: e.key,\n            quoteStyle: \"none\",\n            value: null,\n            readonly: !1\n          };\n        let o = t(e.right);\n        return e.optional && (o = {\n          type: \"OPTIONAL\",\n          value: o,\n          meta: {\n            syntax: \"SUFFIX_KEY_QUESTION_MARK\"\n          }\n        }), {\n          type: \"RECORD_ENTRY\",\n          key: e.key,\n          quoteStyle: \"none\",\n          value: o,\n          readonly: !1\n        };\n      }, \"JsdocTypeKeyValue\"),\n      JsdocTypeObject: /* @__PURE__ */ r((e, t) => {\n        let o = [];\n        for (let i of e.elements)\n          (i.type === \"JsdocTypeObjectField\" || i.type === \"JsdocTypeJsdocObjectField\") && o.push(t(i));\n        return {\n          type: \"RECORD\",\n          entries: o\n        };\n      }, \"JsdocTypeObject\"),\n      JsdocTypeSpecialNamePath: /* @__PURE__ */ r((e) => {\n        if (e.specialType !== \"module\")\n          throw new Error(`jsdoctypeparser does not support type ${e.specialType} at this point.`);\n        return {\n          type: \"MODULE\",\n          value: {\n            type: \"FILE_PATH\",\n            quoteStyle: V(e.meta.quote),\n            path: e.value\n          }\n        };\n      }, \"JsdocTypeSpecialNamePath\"),\n      JsdocTypeNamePath: /* @__PURE__ */ r((e, t) => {\n        let o = !1, i, l;\n        e.right.type === \"JsdocTypeSpecialNamePath\" && e.right.specialType === \"event\" ? (o = !0, i = e.right.value, l = V(e.right.meta.quote)) :\n        (i = e.right.value, l = V(e.right.meta.quote));\n        let f = {\n          type: lr(e.pathType),\n          owner: t(e.left),\n          name: i,\n          quoteStyle: l,\n          hasEventPrefix: o\n        };\n        if (f.owner.type === \"MODULE\") {\n          let d = f.owner;\n          return f.owner = f.owner.value, d.value = f, d;\n        } else\n          return f;\n      }, \"JsdocTypeNamePath\"),\n      JsdocTypeUnion: /* @__PURE__ */ r((e, t) => ve(\"UNION\", e.elements.map(t)), \"JsdocTypeUnion\"),\n      JsdocTypeParenthesis: /* @__PURE__ */ r((e, t) => ({\n        type: \"PARENTHESIS\",\n        value: t(J(e.element))\n      }), \"JsdocTypeParenthesis\"),\n      JsdocTypeNull: /* @__PURE__ */ r(() => ({\n        type: \"NAME\",\n        name: \"null\"\n      }), \"JsdocTypeNull\"),\n      JsdocTypeUnknown: /* @__PURE__ */ r(() => ({\n        type: \"UNKNOWN\"\n      }), \"JsdocTypeUnknown\"),\n      JsdocTypeStringValue: /* @__PURE__ */ r((e) => ({\n        type: \"STRING_VALUE\",\n        quoteStyle: V(e.meta.quote),\n        string: e.value\n      }), \"JsdocTypeStringValue\"),\n      JsdocTypeIntersection: /* @__PURE__ */ r((e, t) => ve(\"INTERSECTION\", e.elements.map(t)), \"JsdocTypeIntersection\"),\n      JsdocTypeNumber: /* @__PURE__ */ r((e) => ({\n        type: \"NUMBER_VALUE\",\n        number: e.value.toString()\n      }), \"JsdocTypeNumber\"),\n      JsdocTypeSymbol: N,\n      JsdocTypeProperty: N,\n      JsdocTypePredicate: N,\n      JsdocTypeMappedType: N,\n      JsdocTypeIndexSignature: N,\n      JsdocTypeAsserts: N\n    };\n    function mr(e) {\n      return W(ur, e);\n    }\n    r(mr, \"jtpTransform\");\n    function fr() {\n      return {\n        JsdocTypeIntersection: /* @__PURE__ */ r((e, t) => ({\n          type: \"JsdocTypeIntersection\",\n          elements: e.elements.map(t)\n        }), \"JsdocTypeIntersection\"),\n        JsdocTypeGeneric: /* @__PURE__ */ r((e, t) => ({\n          type: \"JsdocTypeGeneric\",\n          left: t(e.left),\n          elements: e.elements.map(t),\n          meta: {\n            dot: e.meta.dot,\n            brackets: e.meta.brackets\n          }\n        }), \"JsdocTypeGeneric\"),\n        JsdocTypeNullable: /* @__PURE__ */ r((e) => e, \"JsdocTypeNullable\"),\n        JsdocTypeUnion: /* @__PURE__ */ r((e, t) => ({\n          type: \"JsdocTypeUnion\",\n          elements: e.elements.map(t)\n        }), \"JsdocTypeUnion\"),\n        JsdocTypeUnknown: /* @__PURE__ */ r((e) => e, \"JsdocTypeUnknown\"),\n        JsdocTypeUndefined: /* @__PURE__ */ r((e) => e, \"JsdocTypeUndefined\"),\n        JsdocTypeTypeof: /* @__PURE__ */ r((e, t) => ({\n          type: \"JsdocTypeTypeof\",\n          element: t(e.element)\n        }), \"JsdocTypeTypeof\"),\n        JsdocTypeSymbol: /* @__PURE__ */ r((e, t) => {\n          let o = {\n            type: \"JsdocTypeSymbol\",\n            value: e.value\n          };\n          return e.element !== void 0 && (o.element = t(e.element)), o;\n        }, \"JsdocTypeSymbol\"),\n        JsdocTypeOptional: /* @__PURE__ */ r((e, t) => ({\n          type: \"JsdocTypeOptional\",\n          element: t(e.element),\n          meta: {\n            position: e.meta.position\n          }\n        }), \"JsdocTypeOptional\"),\n        JsdocTypeObject: /* @__PURE__ */ r((e, t) => ({\n          type: \"JsdocTypeObject\",\n          meta: {\n            separator: \"comma\"\n          },\n          elements: e.elements.map(t)\n        }), \"JsdocTypeObject\"),\n        JsdocTypeNumber: /* @__PURE__ */ r((e) => e, \"JsdocTypeNumber\"),\n        JsdocTypeNull: /* @__PURE__ */ r((e) => e, \"JsdocTypeNull\"),\n        JsdocTypeNotNullable: /* @__PURE__ */ r((e, t) => ({\n          type: \"JsdocTypeNotNullable\",\n          element: t(e.element),\n          meta: {\n            position: e.meta.position\n          }\n        }), \"JsdocTypeNotNullable\"),\n        JsdocTypeSpecialNamePath: /* @__PURE__ */ r((e) => e, \"JsdocTypeSpecialNamePath\"),\n        JsdocTypeObjectField: /* @__PURE__ */ r((e, t) => ({\n          type: \"JsdocTypeObjectField\",\n          key: e.key,\n          right: e.right === void 0 ? void 0 : t(e.right),\n          optional: e.optional,\n          readonly: e.readonly,\n          meta: e.meta\n        }), \"JsdocTypeObjectField\"),\n        JsdocTypeJsdocObjectField: /* @__PURE__ */ r((e, t) => ({\n          type: \"JsdocTypeJsdocObjectField\",\n          left: t(e.left),\n          right: t(e.right)\n        }), \"JsdocTypeJsdocObjectField\"),\n        JsdocTypeKeyValue: /* @__PURE__ */ r((e, t) => ({\n          type: \"JsdocTypeKeyValue\",\n          key: e.key,\n          right: e.right === void 0 ? void 0 : t(e.right),\n          optional: e.optional,\n          variadic: e.variadic\n        }), \"JsdocTypeKeyValue\"),\n        JsdocTypeImport: /* @__PURE__ */ r((e, t) => ({\n          type: \"JsdocTypeImport\",\n          element: t(e.element)\n        }), \"JsdocTypeImport\"),\n        JsdocTypeAny: /* @__PURE__ */ r((e) => e, \"JsdocTypeAny\"),\n        JsdocTypeStringValue: /* @__PURE__ */ r((e) => e, \"JsdocTypeStringValue\"),\n        JsdocTypeNamePath: /* @__PURE__ */ r((e) => e, \"JsdocTypeNamePath\"),\n        JsdocTypeVariadic: /* @__PURE__ */ r((e, t) => {\n          let o = {\n            type: \"JsdocTypeVariadic\",\n            meta: {\n              position: e.meta.position,\n              squareBrackets: e.meta.squareBrackets\n            }\n          };\n          return e.element !== void 0 && (o.element = t(e.element)), o;\n        }, \"JsdocTypeVariadic\"),\n        JsdocTypeTuple: /* @__PURE__ */ r((e, t) => ({\n          type: \"JsdocTypeTuple\",\n          elements: e.elements.map(t)\n        }), \"JsdocTypeTuple\"),\n        JsdocTypeName: /* @__PURE__ */ r((e) => e, \"JsdocTypeName\"),\n        JsdocTypeFunction: /* @__PURE__ */ r((e, t) => {\n          let o = {\n            type: \"JsdocTypeFunction\",\n            arrow: e.arrow,\n            parameters: e.parameters.map(t),\n            constructor: e.constructor,\n            parenthesis: e.parenthesis\n          };\n          return e.returnType !== void 0 && (o.returnType = t(e.returnType)), o;\n        }, \"JsdocTypeFunction\"),\n        JsdocTypeKeyof: /* @__PURE__ */ r((e, t) => ({\n          type: \"JsdocTypeKeyof\",\n          element: t(e.element)\n        }), \"JsdocTypeKeyof\"),\n        JsdocTypeParenthesis: /* @__PURE__ */ r((e, t) => ({\n          type: \"JsdocTypeParenthesis\",\n          element: t(e.element)\n        }), \"JsdocTypeParenthesis\"),\n        JsdocTypeProperty: /* @__PURE__ */ r((e) => e, \"JsdocTypeProperty\"),\n        JsdocTypePredicate: /* @__PURE__ */ r((e, t) => ({\n          type: \"JsdocTypePredicate\",\n          left: t(e.left),\n          right: t(e.right)\n        }), \"JsdocTypePredicate\"),\n        JsdocTypeIndexSignature: /* @__PURE__ */ r((e, t) => ({\n          type: \"JsdocTypeIndexSignature\",\n          key: e.key,\n          right: t(e.right)\n        }), \"JsdocTypeIndexSignature\"),\n        JsdocTypeMappedType: /* @__PURE__ */ r((e, t) => ({\n          type: \"JsdocTypeMappedType\",\n          key: e.key,\n          right: t(e.right)\n        }), \"JsdocTypeMappedType\"),\n        JsdocTypeAsserts: /* @__PURE__ */ r((e, t) => ({\n          type: \"JsdocTypeAsserts\",\n          left: t(e.left),\n          right: t(e.right)\n        }), \"JsdocTypeAsserts\")\n      };\n    }\n    r(fr, \"identityTransformRules\");\n    let tt = {\n      JsdocTypeAny: [],\n      JsdocTypeFunction: [\"parameters\", \"returnType\"],\n      JsdocTypeGeneric: [\"left\", \"elements\"],\n      JsdocTypeImport: [],\n      JsdocTypeIndexSignature: [\"right\"],\n      JsdocTypeIntersection: [\"elements\"],\n      JsdocTypeKeyof: [\"element\"],\n      JsdocTypeKeyValue: [\"right\"],\n      JsdocTypeMappedType: [\"right\"],\n      JsdocTypeName: [],\n      JsdocTypeNamePath: [\"left\", \"right\"],\n      JsdocTypeNotNullable: [\"element\"],\n      JsdocTypeNull: [],\n      JsdocTypeNullable: [\"element\"],\n      JsdocTypeNumber: [],\n      JsdocTypeObject: [\"elements\"],\n      JsdocTypeObjectField: [\"right\"],\n      JsdocTypeJsdocObjectField: [\"left\", \"right\"],\n      JsdocTypeOptional: [\"element\"],\n      JsdocTypeParenthesis: [\"element\"],\n      JsdocTypeSpecialNamePath: [],\n      JsdocTypeStringValue: [],\n      JsdocTypeSymbol: [\"element\"],\n      JsdocTypeTuple: [\"elements\"],\n      JsdocTypeTypeof: [\"element\"],\n      JsdocTypeUndefined: [],\n      JsdocTypeUnion: [\"elements\"],\n      JsdocTypeUnknown: [],\n      JsdocTypeVariadic: [\"element\"],\n      JsdocTypeProperty: [],\n      JsdocTypePredicate: [\"left\", \"right\"],\n      JsdocTypeAsserts: [\"left\", \"right\"]\n    };\n    function ke(e, t, o, i, l) {\n      i?.(e, t, o);\n      let f = tt[e.type];\n      for (let d of f) {\n        let h = e[d];\n        if (h !== void 0)\n          if (Array.isArray(h))\n            for (let D of h)\n              ke(D, e, d, i, l);\n          else\n            ke(h, e, d, i, l);\n      }\n      l?.(e, t, o);\n    }\n    r(ke, \"_traverse\");\n    function yr(e, t, o) {\n      ke(e, void 0, void 0, t, o);\n    }\n    r(yr, \"traverse\"), n.catharsisTransform = cr, n.identityTransformRules = fr, n.jtpTransform = mr, n.parse = Qe, n.stringify = ar, n.stringifyRules =\n    et, n.transform = W, n.traverse = yr, n.tryParse = or, n.visitorKeys = tt;\n  });\n});\n\n// src/docs-tools/argTypes/convert/flow/convert.ts\nimport { UnknownArgTypesError as br } from \"storybook/internal/preview-errors\";\nvar Sr = /* @__PURE__ */ r((n) => n.name === \"literal\", \"isLiteral\"), Er = /* @__PURE__ */ r((n) => n.value.replace(/['|\"]/g, \"\"), \"toEnumOp\\\ntion\"), Nr = /* @__PURE__ */ r((n) => {\n  switch (n.type) {\n    case \"function\":\n      return { name: \"function\" };\n    case \"object\":\n      let s = {};\n      return n.signature.properties.forEach((a) => {\n        s[a.key] = B(a.value);\n      }), {\n        name: \"object\",\n        value: s\n      };\n    default:\n      throw new br({ type: n, language: \"Flow\" });\n  }\n}, \"convertSig\"), B = /* @__PURE__ */ r((n) => {\n  let { name: s, raw: a } = n, p = {};\n  switch (typeof a < \"u\" && (p.raw = a), n.name) {\n    case \"literal\":\n      return { ...p, name: \"other\", value: n.value };\n    case \"string\":\n    case \"number\":\n    case \"symbol\":\n    case \"boolean\":\n      return { ...p, name: s };\n    case \"Array\":\n      return { ...p, name: \"array\", value: n.elements.map(B) };\n    case \"signature\":\n      return { ...p, ...Nr(n) };\n    case \"union\":\n      return n.elements?.every(Sr) ? { ...p, name: \"enum\", value: n.elements?.map(Er) } : { ...p, name: s, value: n.elements?.map(B) };\n    case \"intersection\":\n      return { ...p, name: s, value: n.elements?.map(B) };\n    default:\n      return { ...p, name: \"other\", value: s };\n  }\n}, \"convert\");\n\n// ../node_modules/es-toolkit/dist/predicate/isPlainObject.mjs\nfunction X(n) {\n  if (!n || typeof n != \"object\")\n    return !1;\n  let s = Object.getPrototypeOf(n);\n  return s === null || s === Object.prototype || Object.getPrototypeOf(s) === null ? Object.prototype.toString.call(n) === \"[object Object]\" :\n  !1;\n}\nr(X, \"isPlainObject\");\n\n// ../node_modules/es-toolkit/dist/object/mapValues.mjs\nfunction Re(n, s) {\n  let a = {}, p = Object.keys(n);\n  for (let c = 0; c < p.length; c++) {\n    let u = p[c], m = n[u];\n    a[u] = s(m, u, n);\n  }\n  return a;\n}\nr(Re, \"mapValues\");\n\n// src/docs-tools/argTypes/convert/utils.ts\nvar ot = /^['\"]|['\"]$/g, Dr = /* @__PURE__ */ r((n) => n.replace(ot, \"\"), \"trimQuotes\"), Or = /* @__PURE__ */ r((n) => ot.test(n), \"includes\\\nQuotes\"), ie = /* @__PURE__ */ r((n) => {\n  let s = Dr(n);\n  return Or(n) || Number.isNaN(Number(s)) ? s : Number(s);\n}, \"parseLiteral\");\n\n// src/docs-tools/argTypes/convert/proptypes/convert.ts\nvar vr = /^\\(.*\\) => /, C = /* @__PURE__ */ r((n) => {\n  let { name: s, raw: a, computed: p, value: c } = n, u = {};\n  switch (typeof a < \"u\" && (u.raw = a), s) {\n    case \"enum\": {\n      let T = p ? c : c.map((g) => ie(g.value));\n      return { ...u, name: s, value: T };\n    }\n    case \"string\":\n    case \"number\":\n    case \"symbol\":\n      return { ...u, name: s };\n    case \"func\":\n      return { ...u, name: \"function\" };\n    case \"bool\":\n    case \"boolean\":\n      return { ...u, name: \"boolean\" };\n    case \"arrayOf\":\n    case \"array\":\n      return { ...u, name: \"array\", value: c && C(c) };\n    case \"object\":\n      return { ...u, name: s };\n    case \"objectOf\":\n      return { ...u, name: s, value: C(c) };\n    case \"shape\":\n    case \"exact\":\n      let m = Re(c, (T) => C(T));\n      return { ...u, name: \"object\", value: m };\n    case \"union\":\n      return { ...u, name: \"union\", value: c.map((T) => C(T)) };\n    case \"instanceOf\":\n    case \"element\":\n    case \"elementType\":\n    default: {\n      if (s?.indexOf(\"|\") > 0)\n        try {\n          let P = s.split(\"|\").map((b) => JSON.parse(b));\n          return { ...u, name: \"enum\", value: P };\n        } catch {\n        }\n      let T = c ? `${s}(${c})` : s, g = vr.test(s) ? \"function\" : \"other\";\n      return { ...u, name: g, value: T };\n    }\n  }\n}, \"convert\");\n\n// src/docs-tools/argTypes/convert/typescript/convert.ts\nimport { UnknownArgTypesError as kr } from \"storybook/internal/preview-errors\";\nvar Ar = /* @__PURE__ */ r((n) => {\n  switch (n.type) {\n    case \"function\":\n      return { name: \"function\" };\n    case \"object\":\n      let s = {};\n      return n.signature.properties.forEach((a) => {\n        s[a.key] = M(a.value);\n      }), {\n        name: \"object\",\n        value: s\n      };\n    default:\n      throw new kr({ type: n, language: \"Typescript\" });\n  }\n}, \"convertSig\"), M = /* @__PURE__ */ r((n) => {\n  let { name: s, raw: a } = n, p = {};\n  switch (typeof a < \"u\" && (p.raw = a), n.name) {\n    case \"string\":\n    case \"number\":\n    case \"symbol\":\n    case \"boolean\":\n      return { ...p, name: s };\n    case \"Array\":\n      return { ...p, name: \"array\", value: n.elements.map(M) };\n    case \"signature\":\n      return { ...p, ...Ar(n) };\n    case \"union\":\n      let c;\n      return n.elements?.every((u) => u.name === \"literal\") ? c = {\n        ...p,\n        name: \"enum\",\n        // @ts-expect-error fix types\n        value: n.elements?.map((u) => ie(u.value))\n      } : c = { ...p, name: s, value: n.elements?.map(M) }, c;\n    case \"intersection\":\n      return { ...p, name: s, value: n.elements?.map(M) };\n    default:\n      return { ...p, name: \"other\", value: s };\n  }\n}, \"convert\");\n\n// src/docs-tools/argTypes/convert/index.ts\nvar pe = /* @__PURE__ */ r((n) => {\n  let { type: s, tsType: a, flowType: p } = n;\n  try {\n    if (s != null)\n      return C(s);\n    if (a != null)\n      return M(a);\n    if (p != null)\n      return B(p);\n  } catch (c) {\n    console.error(c);\n  }\n  return null;\n}, \"convert\");\n\n// src/docs-tools/argTypes/docgen/types.ts\nvar Ir = /* @__PURE__ */ ((c) => (c.JAVASCRIPT = \"JavaScript\", c.FLOW = \"Flow\", c.TYPESCRIPT = \"TypeScript\", c.UNKNOWN = \"Unknown\", c))(Ir ||\n{});\n\n// src/docs-tools/argTypes/docgen/utils/defaultValue.ts\nvar Rr = [\"null\", \"undefined\"];\nfunction K(n) {\n  return Rr.some((s) => s === n);\n}\nr(K, \"isDefaultValueBlacklisted\");\n\n// src/docs-tools/argTypes/docgen/utils/string.ts\nvar st = /* @__PURE__ */ r((n) => {\n  if (!n)\n    return \"\";\n  if (typeof n == \"string\")\n    return n;\n  throw new Error(`Description: expected string, got: ${JSON.stringify(n)}`);\n}, \"str\");\n\n// src/docs-tools/argTypes/docgen/utils/docgenInfo.ts\nfunction at(n) {\n  return !!n.__docgenInfo;\n}\nr(at, \"hasDocgen\");\nfunction it(n) {\n  return n != null && Object.keys(n).length > 0;\n}\nr(it, \"isValidDocgenSection\");\nfunction pt(n, s) {\n  return at(n) ? n.__docgenInfo[s] : null;\n}\nr(pt, \"getDocgenSection\");\nfunction ct(n) {\n  return at(n) ? st(n.__docgenInfo.description) : \"\";\n}\nr(ct, \"getDocgenDescription\");\n\n// ../node_modules/comment-parser/es6/primitives.js\nvar v;\n(function(n) {\n  n.start = \"/**\", n.nostart = \"/***\", n.delim = \"*\", n.end = \"*/\";\n})(v = v || (v = {}));\n\n// ../node_modules/comment-parser/es6/util.js\nfunction je(n) {\n  return /^\\s+$/.test(n);\n}\nr(je, \"isSpace\");\nfunction lt(n) {\n  let s = n.match(/\\r+$/);\n  return s == null ? [\"\", n] : [n.slice(-s[0].length), n.slice(0, -s[0].length)];\n}\nr(lt, \"splitCR\");\nfunction A(n) {\n  let s = n.match(/^\\s+/);\n  return s == null ? [\"\", n] : [n.slice(0, s[0].length), n.slice(s[0].length)];\n}\nr(A, \"splitSpace\");\nfunction ut(n) {\n  return n.split(/\\n/);\n}\nr(ut, \"splitLines\");\nfunction mt(n = {}) {\n  return Object.assign({ tag: \"\", name: \"\", type: \"\", optional: !1, description: \"\", problems: [], source: [] }, n);\n}\nr(mt, \"seedSpec\");\nfunction Fe(n = {}) {\n  return Object.assign({ start: \"\", delimiter: \"\", postDelimiter: \"\", tag: \"\", postTag: \"\", name: \"\", postName: \"\", type: \"\", postType: \"\", description: \"\",\n  end: \"\", lineEnd: \"\" }, n);\n}\nr(Fe, \"seedTokens\");\n\n// ../node_modules/comment-parser/es6/parser/block-parser.js\nvar jr = /^@\\S+/;\nfunction _e({ fence: n = \"```\" } = {}) {\n  let s = Fr(n), a = /* @__PURE__ */ r((p, c) => s(p) ? !c : c, \"toggleFence\");\n  return /* @__PURE__ */ r(function(c) {\n    let u = [[]], m = !1;\n    for (let T of c)\n      jr.test(T.tokens.description) && !m ? u.push([T]) : u[u.length - 1].push(T), m = a(T.tokens.description, m);\n    return u;\n  }, \"parseBlock\");\n}\nr(_e, \"getParser\");\nfunction Fr(n) {\n  return typeof n == \"string\" ? (s) => s.split(n).length % 2 === 0 : n;\n}\nr(Fr, \"getFencer\");\n\n// ../node_modules/comment-parser/es6/parser/source-parser.js\nfunction Ve({ startLine: n = 0, markers: s = v } = {}) {\n  let a = null, p = n;\n  return /* @__PURE__ */ r(function(u) {\n    let m = u, T = Fe();\n    if ([T.lineEnd, m] = lt(m), [T.start, m] = A(m), a === null && m.startsWith(s.start) && !m.startsWith(s.nostart) && (a = [], T.delimiter =\n    m.slice(0, s.start.length), m = m.slice(s.start.length), [T.postDelimiter, m] = A(m)), a === null)\n      return p++, null;\n    let g = m.trimRight().endsWith(s.end);\n    if (T.delimiter === \"\" && m.startsWith(s.delim) && !m.startsWith(s.end) && (T.delimiter = s.delim, m = m.slice(s.delim.length), [T.postDelimiter,\n    m] = A(m)), g) {\n      let P = m.trimRight();\n      T.end = m.slice(P.length - s.end.length), m = P.slice(0, -s.end.length);\n    }\n    if (T.description = m, a.push({ number: p, source: u, tokens: T }), p++, g) {\n      let P = a.slice();\n      return a = null, P;\n    }\n    return null;\n  }, \"parseSource\");\n}\nr(Ve, \"getParser\");\n\n// ../node_modules/comment-parser/es6/parser/spec-parser.js\nfunction Le({ tokenizers: n }) {\n  return /* @__PURE__ */ r(function(a) {\n    var p;\n    let c = mt({ source: a });\n    for (let u of n)\n      if (c = u(c), !((p = c.problems[c.problems.length - 1]) === null || p === void 0) && p.critical)\n        break;\n    return c;\n  }, \"parseSpec\");\n}\nr(Le, \"getParser\");\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/tag.js\nfunction ce() {\n  return (n) => {\n    let { tokens: s } = n.source[0], a = s.description.match(/\\s*(@(\\S+))(\\s*)/);\n    return a === null ? (n.problems.push({\n      code: \"spec:tag:prefix\",\n      message: 'tag should start with \"@\" symbol',\n      line: n.source[0].number,\n      critical: !0\n    }), n) : (s.tag = a[1], s.postTag = a[3], s.description = s.description.slice(a[0].length), n.tag = a[2], n);\n  };\n}\nr(ce, \"tagTokenizer\");\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/type.js\nfunction le(n = \"compact\") {\n  let s = Vr(n);\n  return (a) => {\n    let p = 0, c = [];\n    for (let [T, { tokens: g }] of a.source.entries()) {\n      let P = \"\";\n      if (T === 0 && g.description[0] !== \"{\")\n        return a;\n      for (let b of g.description)\n        if (b === \"{\" && p++, b === \"}\" && p--, P += b, p === 0)\n          break;\n      if (c.push([g, P]), p === 0)\n        break;\n    }\n    if (p !== 0)\n      return a.problems.push({\n        code: \"spec:type:unpaired-curlies\",\n        message: \"unpaired curlies\",\n        line: a.source[0].number,\n        critical: !0\n      }), a;\n    let u = [], m = c[0][0].postDelimiter.length;\n    for (let [T, [g, P]] of c.entries())\n      g.type = P, T > 0 && (g.type = g.postDelimiter.slice(m) + P, g.postDelimiter = g.postDelimiter.slice(0, m)), [g.postType, g.description] =\n      A(g.description.slice(P.length)), u.push(g.type);\n    return u[0] = u[0].slice(1), u[u.length - 1] = u[u.length - 1].slice(0, -1), a.type = s(u), a;\n  };\n}\nr(le, \"typeTokenizer\");\nvar _r = /* @__PURE__ */ r((n) => n.trim(), \"trim\");\nfunction Vr(n) {\n  return n === \"compact\" ? (s) => s.map(_r).join(\"\") : n === \"preserve\" ? (s) => s.join(`\n`) : n;\n}\nr(Vr, \"getJoiner\");\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/name.js\nvar Lr = /* @__PURE__ */ r((n) => n && n.startsWith('\"') && n.endsWith('\"'), \"isQuoted\");\nfunction ue() {\n  let n = /* @__PURE__ */ r((s, { tokens: a }, p) => a.type === \"\" ? s : p, \"typeEnd\");\n  return (s) => {\n    let { tokens: a } = s.source[s.source.reduce(n, 0)], p = a.description.trimLeft(), c = p.split('\"');\n    if (c.length > 1 && c[0] === \"\" && c.length % 2 === 1)\n      return s.name = c[1], a.name = `\"${c[1]}\"`, [a.postName, a.description] = A(p.slice(a.name.length)), s;\n    let u = 0, m = \"\", T = !1, g;\n    for (let b of p) {\n      if (u === 0 && je(b))\n        break;\n      b === \"[\" && u++, b === \"]\" && u--, m += b;\n    }\n    if (u !== 0)\n      return s.problems.push({\n        code: \"spec:name:unpaired-brackets\",\n        message: \"unpaired brackets\",\n        line: s.source[0].number,\n        critical: !0\n      }), s;\n    let P = m;\n    if (m[0] === \"[\" && m[m.length - 1] === \"]\") {\n      T = !0, m = m.slice(1, -1);\n      let b = m.split(\"=\");\n      if (m = b[0].trim(), b[1] !== void 0 && (g = b.slice(1).join(\"=\").trim()), m === \"\")\n        return s.problems.push({\n          code: \"spec:name:empty-name\",\n          message: \"empty name\",\n          line: s.source[0].number,\n          critical: !0\n        }), s;\n      if (g === \"\")\n        return s.problems.push({\n          code: \"spec:name:empty-default\",\n          message: \"empty default value\",\n          line: s.source[0].number,\n          critical: !0\n        }), s;\n      if (!Lr(g) && /=(?!>)/.test(g))\n        return s.problems.push({\n          code: \"spec:name:invalid-default\",\n          message: \"invalid default value syntax\",\n          line: s.source[0].number,\n          critical: !0\n        }), s;\n    }\n    return s.optional = T, s.name = m, a.name = P, g !== void 0 && (s.default = g), [a.postName, a.description] = A(p.slice(a.name.length)),\n    s;\n  };\n}\nr(ue, \"nameTokenizer\");\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/description.js\nfunction me(n = \"compact\", s = v) {\n  let a = Ue(n);\n  return (p) => (p.description = a(p.source, s), p);\n}\nr(me, \"descriptionTokenizer\");\nfunction Ue(n) {\n  return n === \"compact\" ? Ur : n === \"preserve\" ? Mr : n;\n}\nr(Ue, \"getJoiner\");\nfunction Ur(n, s = v) {\n  return n.map(({ tokens: { description: a } }) => a.trim()).filter((a) => a !== \"\").join(\" \");\n}\nr(Ur, \"compactJoiner\");\nvar Br = /* @__PURE__ */ r((n, { tokens: s }, a) => s.type === \"\" ? n : a, \"lineNo\"), Cr = /* @__PURE__ */ r(({ tokens: n }) => (n.delimiter ===\n\"\" ? n.start : n.postDelimiter.slice(1)) + n.description, \"getDescription\");\nfunction Mr(n, s = v) {\n  if (n.length === 0)\n    return \"\";\n  n[0].tokens.description === \"\" && n[0].tokens.delimiter === s.start && (n = n.slice(1));\n  let a = n[n.length - 1];\n  return a !== void 0 && a.tokens.description === \"\" && a.tokens.end.endsWith(s.end) && (n = n.slice(0, -1)), n = n.slice(n.reduce(Br, 0)), n.\n  map(Cr).join(`\n`);\n}\nr(Mr, \"preserveJoiner\");\n\n// ../node_modules/comment-parser/es6/parser/index.js\nfunction Be({ startLine: n = 0, fence: s = \"```\", spacing: a = \"compact\", markers: p = v, tokenizers: c = [\n  ce(),\n  le(a),\n  ue(),\n  me(a)\n] } = {}) {\n  if (n < 0 || n % 1 > 0)\n    throw new Error(\"Invalid startLine\");\n  let u = Ve({ startLine: n, markers: p }), m = _e({ fence: s }), T = Le({ tokenizers: c }), g = Ue(a);\n  return function(P) {\n    let b = [];\n    for (let de of ut(P)) {\n      let q = u(de);\n      if (q === null)\n        continue;\n      let S = m(q), z = S.slice(1).map(T);\n      b.push({\n        description: g(S[0], p),\n        tags: z,\n        source: q,\n        problems: z.reduce((Te, ge) => Te.concat(ge.problems), [])\n      });\n    }\n    return b;\n  };\n}\nr(Be, \"getParser\");\n\n// ../node_modules/comment-parser/es6/stringifier/index.js\nfunction Kr(n) {\n  return n.start + n.delimiter + n.postDelimiter + n.tag + n.postTag + n.type + n.postType + n.name + n.postName + n.description + n.end + n.\n  lineEnd;\n}\nr(Kr, \"join\");\nfunction Ce() {\n  return (n) => n.source.map(({ tokens: s }) => Kr(s)).join(`\n`);\n}\nr(Ce, \"getStringifier\");\n\n// ../node_modules/comment-parser/es6/stringifier/inspect.js\nvar $r = {\n  line: 0,\n  start: 0,\n  delimiter: 0,\n  postDelimiter: 0,\n  tag: 0,\n  postTag: 0,\n  name: 0,\n  postName: 0,\n  type: 0,\n  postType: 0,\n  description: 0,\n  end: 0,\n  lineEnd: 0\n};\nvar Wo = Object.keys($r);\n\n// ../node_modules/comment-parser/es6/index.js\nfunction ft(n, s = {}) {\n  return Be(s)(n);\n}\nr(ft, \"parse\");\nvar ys = Ce();\n\n// src/docs-tools/argTypes/jsdocParser.ts\nvar $ = Pr(dt(), 1);\nfunction qr(n) {\n  return n != null && n.includes(\"@\");\n}\nr(qr, \"containsJsDoc\");\nfunction Yr(n) {\n  let p = `/**\n` + (n ?? \"\").split(`\n`).map((u) => ` * ${u}`).join(`\n`) + `\n*/`, c = ft(p, {\n    spacing: \"preserve\"\n  });\n  if (!c || c.length === 0)\n    throw new Error(\"Cannot parse JSDoc tags.\");\n  return c[0];\n}\nr(Yr, \"parse\");\nvar Wr = {\n  tags: [\"param\", \"arg\", \"argument\", \"returns\", \"ignore\", \"deprecated\"]\n}, Tt = /* @__PURE__ */ r((n, s = Wr) => {\n  if (!qr(n))\n    return {\n      includesJsDoc: !1,\n      ignore: !1\n    };\n  let a = Yr(n), p = Gr(a, s.tags);\n  return p.ignore ? {\n    includesJsDoc: !0,\n    ignore: !0\n  } : {\n    includesJsDoc: !0,\n    ignore: !1,\n    // Always use the parsed description to ensure JSDoc is removed from the description.\n    description: a.description.trim(),\n    extractedTags: p\n  };\n}, \"parseJsDoc\");\nfunction Gr(n, s) {\n  let a = {\n    params: null,\n    deprecated: null,\n    returns: null,\n    ignore: !1\n  };\n  for (let p of n.tags)\n    if (!(s !== void 0 && !s.includes(p.tag)))\n      if (p.tag === \"ignore\") {\n        a.ignore = !0;\n        break;\n      } else\n        switch (p.tag) {\n          // arg & argument are aliases for param.\n          case \"param\":\n          case \"arg\":\n          case \"argument\": {\n            let c = zr(p);\n            c != null && (a.params == null && (a.params = []), a.params.push(c));\n            break;\n          }\n          case \"deprecated\": {\n            let c = Hr(p);\n            c != null && (a.deprecated = c);\n            break;\n          }\n          case \"returns\": {\n            let c = Qr(p);\n            c != null && (a.returns = c);\n            break;\n          }\n          default:\n            break;\n        }\n  return a;\n}\nr(Gr, \"extractJsDocTags\");\nfunction Xr(n) {\n  return n.replace(/[\\.-]$/, \"\");\n}\nr(Xr, \"normaliseParamName\");\nfunction zr(n) {\n  if (!n.name || n.name === \"-\")\n    return null;\n  let s = ht(n.type);\n  return {\n    name: n.name,\n    type: s,\n    description: xt(n.description),\n    getPrettyName: /* @__PURE__ */ r(() => Xr(n.name), \"getPrettyName\"),\n    getTypeName: /* @__PURE__ */ r(() => s ? Jt(s) : null, \"getTypeName\")\n  };\n}\nr(zr, \"extractParam\");\nfunction Hr(n) {\n  return n.name ? gt(n.name, n.description) : null;\n}\nr(Hr, \"extractDeprecated\");\nfunction gt(n, s) {\n  let a = n === \"\" ? s : `${n} ${s}`;\n  return xt(a);\n}\nr(gt, \"joinNameAndDescription\");\nfunction xt(n) {\n  let s = n.replace(/^- /g, \"\").trim();\n  return s === \"\" ? null : s;\n}\nr(xt, \"normaliseDescription\");\nfunction Qr(n) {\n  let s = ht(n.type);\n  return s ? {\n    type: s,\n    description: gt(n.name, n.description),\n    getTypeName: /* @__PURE__ */ r(() => Jt(s), \"getTypeName\")\n  } : null;\n}\nr(Qr, \"extractReturns\");\nvar _ = (0, $.stringifyRules)(), Zr = _.JsdocTypeObject;\n_.JsdocTypeAny = () => \"any\";\n_.JsdocTypeObject = (n, s) => `(${Zr(n, s)})`;\n_.JsdocTypeOptional = (n, s) => s(n.element);\n_.JsdocTypeNullable = (n, s) => s(n.element);\n_.JsdocTypeNotNullable = (n, s) => s(n.element);\n_.JsdocTypeUnion = (n, s) => n.elements.map(s).join(\"|\");\nfunction ht(n) {\n  try {\n    return (0, $.parse)(n, \"typescript\");\n  } catch {\n    return null;\n  }\n}\nr(ht, \"extractType\");\nfunction Jt(n) {\n  return (0, $.transform)(_, n);\n}\nr(Jt, \"extractTypeName\");\n\n// src/docs-tools/argTypes/utils.ts\nvar bs = 90, Ss = 50;\nfunction Ke(n) {\n  return n.length > 90;\n}\nr(Ke, \"isTooLongForTypeSummary\");\nfunction wt(n) {\n  return n.length > 50;\n}\nr(wt, \"isTooLongForDefaultValueSummary\");\nfunction w(n, s) {\n  return n === s ? { summary: n } : { summary: n, detail: s };\n}\nr(w, \"createSummaryValue\");\nvar Es = /* @__PURE__ */ r((n) => n.replace(/\\\\r\\\\n/g, \"\\\\n\"), \"normalizeNewlines\");\n\n// src/docs-tools/argTypes/docgen/flow/createDefaultValue.ts\nfunction Pt(n, s) {\n  if (n != null) {\n    let { value: a } = n;\n    if (!K(a))\n      return wt(a) ? w(s?.name, a) : w(a);\n  }\n  return null;\n}\nr(Pt, \"createDefaultValue\");\n\n// src/docs-tools/argTypes/docgen/flow/createType.ts\nfunction bt({ name: n, value: s, elements: a, raw: p }) {\n  return s ?? (a != null ? a.map(bt).join(\" | \") : p ?? n);\n}\nr(bt, \"generateUnionElement\");\nfunction en({ name: n, raw: s, elements: a }) {\n  return a != null ? w(a.map(bt).join(\" | \")) : s != null ? w(s.replace(/^\\|\\s*/, \"\")) : w(n);\n}\nr(en, \"generateUnion\");\nfunction tn({ type: n, raw: s }) {\n  return s != null ? w(s) : w(n);\n}\nr(tn, \"generateFuncSignature\");\nfunction rn({ type: n, raw: s }) {\n  return s != null ? Ke(s) ? w(n, s) : w(s) : w(n);\n}\nr(rn, \"generateObjectSignature\");\nfunction nn(n) {\n  let { type: s } = n;\n  return s === \"object\" ? rn(n) : tn(n);\n}\nr(nn, \"generateSignature\");\nfunction on({ name: n, raw: s }) {\n  return s != null ? Ke(s) ? w(n, s) : w(s) : w(n);\n}\nr(on, \"generateDefault\");\nfunction St(n) {\n  if (n == null)\n    return null;\n  switch (n.name) {\n    case \"union\":\n      return en(n);\n    case \"signature\":\n      return nn(n);\n    default:\n      return on(n);\n  }\n}\nr(St, \"createType\");\n\n// src/docs-tools/argTypes/docgen/flow/createPropDef.ts\nvar Et = /* @__PURE__ */ r((n, s) => {\n  let { flowType: a, description: p, required: c, defaultValue: u } = s;\n  return {\n    name: n,\n    type: St(a),\n    required: c,\n    description: p,\n    defaultValue: Pt(u ?? null, a ?? null)\n  };\n}, \"createFlowPropDef\");\n\n// src/docs-tools/argTypes/docgen/typeScript/createDefaultValue.ts\nfunction Nt({ defaultValue: n }) {\n  if (n != null) {\n    let { value: s } = n;\n    if (!K(s))\n      return w(s);\n  }\n  return null;\n}\nr(Nt, \"createDefaultValue\");\n\n// src/docs-tools/argTypes/docgen/typeScript/createType.ts\nfunction Dt({ tsType: n, required: s }) {\n  if (n == null)\n    return null;\n  let a = n.name;\n  return s || (a = a.replace(\" | undefined\", \"\")), w(\n    [\"Array\", \"Record\", \"signature\"].includes(n.name) ? n.raw : a\n  );\n}\nr(Dt, \"createType\");\n\n// src/docs-tools/argTypes/docgen/typeScript/createPropDef.ts\nvar Ot = /* @__PURE__ */ r((n, s) => {\n  let { description: a, required: p } = s;\n  return {\n    name: n,\n    type: Dt(s),\n    required: p,\n    description: a,\n    defaultValue: Nt(s)\n  };\n}, \"createTsPropDef\");\n\n// src/docs-tools/argTypes/docgen/createPropDef.ts\nfunction sn(n) {\n  return n != null ? w(n.name) : null;\n}\nr(sn, \"createType\");\nfunction an(n) {\n  let { computed: s, func: a } = n;\n  return typeof s > \"u\" && typeof a > \"u\";\n}\nr(an, \"isReactDocgenTypescript\");\nfunction pn(n) {\n  return n ? n.name === \"string\" ? !0 : n.name === \"enum\" ? Array.isArray(n.value) && n.value.every(\n    ({ value: s }) => typeof s == \"string\" && s[0] === '\"' && s[s.length - 1] === '\"'\n  ) : !1 : !1;\n}\nr(pn, \"isStringValued\");\nfunction cn(n, s) {\n  if (n != null) {\n    let { value: a } = n;\n    if (!K(a))\n      return an(n) && pn(s) ? w(JSON.stringify(a)) : w(a);\n  }\n  return null;\n}\nr(cn, \"createDefaultValue\");\nfunction vt(n, s, a) {\n  let { description: p, required: c, defaultValue: u } = a;\n  return {\n    name: n,\n    type: sn(s),\n    required: c,\n    description: p,\n    defaultValue: cn(u, s)\n  };\n}\nr(vt, \"createBasicPropDef\");\nfunction ye(n, s) {\n  if (s?.includesJsDoc) {\n    let { description: a, extractedTags: p } = s;\n    a != null && (n.description = s.description);\n    let c = {\n      ...p,\n      params: p?.params?.map(\n        (u) => ({\n          name: u.getPrettyName(),\n          description: u.description\n        })\n      )\n    };\n    Object.values(c).filter(Boolean).length > 0 && (n.jsDocTags = c);\n  }\n  return n;\n}\nr(ye, \"applyJsDocResult\");\nvar ln = /* @__PURE__ */ r((n, s, a) => {\n  let p = vt(n, s.type, s);\n  return p.sbType = pe(s), ye(p, a);\n}, \"javaScriptFactory\"), un = /* @__PURE__ */ r((n, s, a) => {\n  let p = Ot(n, s);\n  return p.sbType = pe(s), ye(p, a);\n}, \"tsFactory\"), mn = /* @__PURE__ */ r((n, s, a) => {\n  let p = Et(n, s);\n  return p.sbType = pe(s), ye(p, a);\n}, \"flowFactory\"), fn = /* @__PURE__ */ r((n, s, a) => {\n  let p = vt(n, { name: \"unknown\" }, s);\n  return ye(p, a);\n}, \"unknownFactory\"), $e = /* @__PURE__ */ r((n) => {\n  switch (n) {\n    case \"JavaScript\":\n      return ln;\n    case \"TypeScript\":\n      return un;\n    case \"Flow\":\n      return mn;\n    default:\n      return fn;\n  }\n}, \"getPropDefFactory\");\n\n// src/docs-tools/argTypes/docgen/extractDocgenProps.ts\nvar kt = /* @__PURE__ */ r((n) => n.type != null ? \"JavaScript\" : n.flowType != null ? \"Flow\" : n.tsType != null ? \"TypeScript\" : \"Unknown\",\n\"getTypeSystem\"), yn = /* @__PURE__ */ r((n) => {\n  let s = kt(n[0]), a = $e(s);\n  return n.map((p) => {\n    let c = p;\n    return p.type?.elements && (c = {\n      ...p,\n      type: {\n        ...p.type,\n        value: p.type.elements\n      }\n    }), At(c.name, c, s, a);\n  });\n}, \"extractComponentSectionArray\"), dn = /* @__PURE__ */ r((n) => {\n  let s = Object.keys(n), a = kt(n[s[0]]), p = $e(a);\n  return s.map((c) => {\n    let u = n[c];\n    return u != null ? At(c, u, a, p) : null;\n  }).filter(Boolean);\n}, \"extractComponentSectionObject\"), aa = /* @__PURE__ */ r((n, s) => {\n  let a = pt(n, s);\n  return it(a) ? Array.isArray(a) ? yn(a) : dn(a) : [];\n}, \"extractComponentProps\");\nfunction At(n, s, a, p) {\n  let c = Tt(s.description);\n  return c.includesJsDoc && c.ignore ? null : {\n    propDef: p(n, s, c),\n    jsDocTags: c.extractedTags,\n    docgenInfo: s,\n    typeSystem: a\n  };\n}\nr(At, \"extractProp\");\nfunction ia(n) {\n  return n != null ? ct(n) : \"\";\n}\nr(ia, \"extractComponentDescription\");\n\n// src/preview-api/modules/store/parameters.ts\nvar qe = /* @__PURE__ */ r((...n) => {\n  let s = {}, a = n.filter(Boolean), p = a.reduce((c, u) => (Object.entries(u).forEach(([m, T]) => {\n    let g = c[m];\n    Array.isArray(T) || typeof g > \"u\" ? c[m] = T : X(T) && X(g) ? s[m] = !0 : typeof T < \"u\" && (c[m] = T);\n  }), c), {});\n  return Object.keys(s).forEach((c) => {\n    let u = a.filter(Boolean).map((m) => m[c]).filter((m) => typeof m < \"u\");\n    u.every((m) => X(m)) ? p[c] = qe(...u) : p[c] = u[u.length - 1];\n  }), p;\n}, \"combineParameters\");\n\n// src/docs-tools/argTypes/enhanceArgTypes.ts\nvar ya = /* @__PURE__ */ r((n) => {\n  let {\n    component: s,\n    argTypes: a,\n    parameters: { docs: p = {} }\n  } = n, { extractArgTypes: c } = p;\n  if (!c || !s)\n    return a;\n  let u = c(s);\n  return u ? qe(u, a) : a;\n}, \"enhanceArgTypes\");\n\n// src/docs-tools/shared.ts\nvar It = \"storybook/docs\", ga = `${It}/panel`, xa = \"docs\", ha = `${It}/snippet-rendered`, Tn = /* @__PURE__ */ ((p) => (p.AUTO = \"auto\", p.\nCODE = \"code\", p.DYNAMIC = \"dynamic\", p))(Tn || {});\nexport {\n  It as ADDON_ID,\n  Ss as MAX_DEFAULT_VALUE_SUMMARY_LENGTH,\n  bs as MAX_TYPE_SUMMARY_LENGTH,\n  ga as PANEL_ID,\n  xa as PARAM_KEY,\n  ha as SNIPPET_RENDERED,\n  Tn as SourceType,\n  Ir as TypeSystem,\n  pe as convert,\n  w as createSummaryValue,\n  ya as enhanceArgTypes,\n  ia as extractComponentDescription,\n  aa as extractComponentProps,\n  yn as extractComponentSectionArray,\n  dn as extractComponentSectionObject,\n  ct as getDocgenDescription,\n  pt as getDocgenSection,\n  at as hasDocgen,\n  K as isDefaultValueBlacklisted,\n  wt as isTooLongForDefaultValueSummary,\n  Ke as isTooLongForTypeSummary,\n  it as isValidDocgenSection,\n  Es as normalizeNewlines,\n  Tt as parseJsDoc,\n  st as str\n};\n"],"mappings":"AAAA,IAAIA,EAAE,GAAGC,MAAM,CAACC,MAAM;AACtB,IAAIC,EAAE,GAAGF,MAAM,CAACG,cAAc;AAC9B,IAAIC,EAAE,GAAGJ,MAAM,CAACK,wBAAwB;AACxC,IAAIC,EAAE,GAAGN,MAAM,CAACO,mBAAmB;AACnC,IAAIC,EAAE,GAAGR,MAAM,CAACS,cAAc;EAAEC,EAAE,GAAGV,MAAM,CAACW,SAAS,CAACC,cAAc;AACpE,IAAIC,CAAC,GAAGA,CAACC,CAAC,EAAEC,CAAC,KAAKb,EAAE,CAACY,CAAC,EAAE,MAAM,EAAE;EAAEE,KAAK,EAAED,CAAC;EAAEE,YAAY,EAAE,CAAC;AAAE,CAAC,CAAC;AAC/D,IAAIC,EAAE,GAAGA,CAACJ,CAAC,EAAEC,CAAC,KAAK,OAAOA,CAAC,IAAID,CAAC,CAAC,CAACC,CAAC,GAAG;EAAEI,OAAO,EAAE,CAAC;AAAE,CAAC,EAAEA,OAAO,EAAEJ,CAAC,CAAC,EAAEA,CAAC,CAACI,OAAO,CAAC;AAC9E,IAAIC,EAAE,GAAGA,CAACN,CAAC,EAAEC,CAAC,EAAEM,CAAC,EAAEC,CAAC,KAAK;EACvB,IAAIP,CAAC,IAAI,OAAOA,CAAC,IAAI,QAAQ,IAAI,OAAOA,CAAC,IAAI,UAAU,EACrD,KAAK,IAAIQ,CAAC,IAAIjB,EAAE,CAACS,CAAC,CAAC,EACjB,CAACL,EAAE,CAACc,IAAI,CAACV,CAAC,EAAES,CAAC,CAAC,IAAIA,CAAC,KAAKF,CAAC,IAAInB,EAAE,CAACY,CAAC,EAAES,CAAC,EAAE;IAAEE,GAAG,EAAEA,CAAA,KAAMV,CAAC,CAACQ,CAAC,CAAC;IAAEG,UAAU,EAAE,EAAEJ,CAAC,GAAGlB,EAAE,CAACW,CAAC,EAAEQ,CAAC,CAAC,CAAC,IAAID,CAAC,CAACI;EAAW,CAAC,CAAC;EAC3G,OAAOZ,CAAC;AACV,CAAC;AACD,IAAIa,EAAE,GAAGA,CAACb,CAAC,EAAEC,CAAC,EAAEM,CAAC,MAAMA,CAAC,GAAGP,CAAC,IAAI,IAAI,GAAGf,EAAE,CAACS,EAAE,CAACM,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAEM,EAAE;AACvD;AACA;AACA;AACA;AACAL,CAAC,IAAI,CAACD,CAAC,IAAI,CAACA,CAAC,CAACc,UAAU,GAAG1B,EAAE,CAACmB,CAAC,EAAE,SAAS,EAAE;EAAEL,KAAK,EAAEF,CAAC;EAAEY,UAAU,EAAE,CAAC;AAAE,CAAC,CAAC,GAAGL,CAAC,EAC7EP,CACF,CAAC,CAAC;;AAEF;AACA,IAAIe,EAAE,GAAGX,EAAE,CAAC,CAACY,EAAE,EAAEC,EAAE,KAAK;EACtB,CAAC,UAASjB,CAAC,EAAEC,CAAC,EAAE;IACd,OAAOe,EAAE,IAAI,QAAQ,IAAI,OAAOC,EAAE,GAAG,GAAG,GAAGhB,CAAC,CAACe,EAAE,CAAC,GAAG,OAAOE,MAAM,IAAI,UAAU,IAAIA,MAAM,CAACC,GAAG,GAAGD,MAAM,CAAC,CAAC,SAAS,CAAC,EAAEjB,CAAC,CAAC,IAAID,CAAC,GAAG,OAAOoB,UAAU,GAC9I,GAAG,GAAGA,UAAU,GAAGpB,CAAC,IAAIqB,IAAI,EAAEpB,CAAC,CAACD,CAAC,CAACsB,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC;EAC/C,CAAC,EAAEN,EAAE,EAAE,UAAShB,CAAC,EAAE;IACjB,YAAY;;IACZ,SAASC,CAACA,CAACsB,CAAC,EAAE;MACZ,OAAOA,CAAC,CAACC,IAAI,KAAK,KAAK,CAAC,IAAID,CAAC,CAACC,IAAI,KAAK,EAAE,GAAG,IAAID,CAAC,CAACE,IAAI,iBAAiBF,CAAC,CAACC,IAAI,GAAG,GAAG,IAAID,CAAC,CAACE,IAAI,GAAG;IAClG;IACA1B,CAAC,CAACE,CAAC,EAAE,eAAe,CAAC;IACrB,IAAIyB,EAAE,GAAG,MAAMA,EAAE,SAASC,KAAK,CAAC;MAC9BC,WAAWA,CAACC,CAAC,EAAE;QACb,KAAK,CAAC,+BAA+B5B,CAAC,CAAC4B,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,CAACC,KAAK,GAAGD,CAAC,EAAE3C,MAAM,CAAC6C,cAAc,CAAC,IAAI,EAAEL,EAAE,CAAC7B,SAAS,CAAC;MACzG;MACAmC,QAAQA,CAAA,EAAG;QACT,OAAO,IAAI,CAACF,KAAK;MACnB;IACF,CAAC;IACD/B,CAAC,CAAC2B,EAAE,EAAE,qBAAqB,CAAC;IAC5B,IAAInB,CAAC,GAAGmB,EAAE;MAAEO,EAAE,GAAG,MAAMA,EAAE,SAASN,KAAK,CAAC;QACtCC,WAAWA,CAACC,CAAC,EAAE;UACb,KAAK,CAAC,gDAAgD5B,CAAC,CAAC4B,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,CAACC,KAAK,GAAGD,CAAC,EAAE3C,MAAM,CAAC6C,cAAc,CAAC,IAAI,EAAEE,EAAE,CAACpC,SAAS,CAAC;QAC1H;QACAmC,QAAQA,CAAA,EAAG;UACT,OAAO,IAAI,CAACF,KAAK;QACnB;MACF,CAAC;IACD/B,CAAC,CAACkC,EAAE,EAAE,sBAAsB,CAAC;IAC7B,IAAIzB,CAAC,GAAGyB,EAAE;MAAEC,EAAE,GAAG,MAAMA,EAAE,SAASP,KAAK,CAAC;QACtCC,WAAWA,CAACC,CAAC,EAAEM,CAAC,EAAE;UAChB,IAAIC,CAAC,GAAG,qBAAqBP,CAAC,CAACJ,IAAI,IAAI;UACvCU,CAAC,KAAK,KAAK,CAAC,KAAKC,CAAC,IAAI,aAAaD,CAAC,EAAE,CAAC,EAAE,KAAK,CAACC,CAAC,CAAC,EAAElD,MAAM,CAAC6C,cAAc,CAAC,IAAI,EAAEG,EAAE,CAACrC,SAAS,CAAC;QAC9F;MACF,CAAC;IACDE,CAAC,CAACmC,EAAE,EAAE,qBAAqB,CAAC;IAC5B,IAAIzB,CAAC,GAAGyB,EAAE;IACV,SAASG,CAACA,CAACd,CAAC,EAAE;MACZ,OAAQM,CAAC,IAAKA,CAAC,CAACS,UAAU,CAACf,CAAC,CAAC,GAAG;QAAEE,IAAI,EAAEF,CAAC;QAAEC,IAAI,EAAED;MAAE,CAAC,GAAG,IAAI;IAC7D;IACAxB,CAAC,CAACsC,CAAC,EAAE,qBAAqB,CAAC;IAC3B,SAASE,CAACA,CAAChB,CAAC,EAAE;MACZ,IAAIM,CAAC,GAAG,CAAC;QAAEM,CAAC;QAAEC,CAAC,GAAGb,CAAC,CAAC,CAAC,CAAC;QAAEiB,CAAC,GAAG,CAAC,CAAC;MAC9B,IAAIJ,CAAC,KAAK,GAAG,IAAIA,CAAC,KAAK,GAAG,EACxB,OAAO,IAAI;MACb,OAAOP,CAAC,GAAGN,CAAC,CAACkB,MAAM,GAAI;QACrB,IAAIZ,CAAC,EAAE,EAAEM,CAAC,GAAGZ,CAAC,CAACM,CAAC,CAAC,EAAE,CAACW,CAAC,IAAIL,CAAC,KAAKC,CAAC,EAAE;UAChCP,CAAC,EAAE;UACH;QACF;QACAW,CAAC,GAAG,CAACA,CAAC,IAAIL,CAAC,KAAK,IAAI;MACtB;MACA,IAAIA,CAAC,KAAKC,CAAC,EACT,MAAM,IAAIT,KAAK,CAAC,qBAAqB,CAAC;MACxC,OAAOJ,CAAC,CAACmB,KAAK,CAAC,CAAC,EAAEb,CAAC,CAAC;IACtB;IACA9B,CAAC,CAACwC,CAAC,EAAE,WAAW,CAAC;IACjB,IAAII,CAAC,GAAG,IAAIC,MAAM,CAAC,mGAAmG,EAAE,GAAG,CAAC;MAAEC,CAAC,GAAG,IAAID,MAAM,CAC5I,sHAAsH,EAAE,GAAG,CAAC;IAC5H,SAASE,CAACA,CAACvB,CAAC,EAAE;MACZ,IAAIM,CAAC,GAAGN,CAAC,CAAC,CAAC,CAAC;MACZ,IAAI,CAACoB,CAAC,CAACI,IAAI,CAAClB,CAAC,CAAC,EACZ,OAAO,IAAI;MACb,IAAIM,CAAC,GAAG,CAAC;MACT,GAAG;QACD,IAAIN,CAAC,GAAGN,CAAC,CAACY,CAAC,CAAC,EAAE,CAACU,CAAC,CAACE,IAAI,CAAClB,CAAC,CAAC,EACtB;QACFM,CAAC,EAAE;MACL,CAAC,QAAQA,CAAC,GAAGZ,CAAC,CAACkB,MAAM;MACrB,OAAOlB,CAAC,CAACmB,KAAK,CAAC,CAAC,EAAEP,CAAC,CAAC;IACtB;IACApC,CAAC,CAAC+C,CAAC,EAAE,eAAe,CAAC;IACrB,IAAIE,CAAC,GAAG,mDAAmD;IAC3D,SAASC,EAAEA,CAAC1B,CAAC,EAAE;MACb,IAAIM,CAAC,EAAEM,CAAC;MACR,OAAO,CAACA,CAAC,GAAG,CAACN,CAAC,GAAGmB,CAAC,CAACE,IAAI,CAAC3B,CAAC,CAAC,MAAM,IAAI,IAAIM,CAAC,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,CAAC,CAAC,CAAC,CAAC,MAAM,IAAI,IAAIM,CAAC,KAAK,KAAK,CAAC,GAAGA,CAAC,GAAG,IAAI;IAC3G;IACApC,CAAC,CAACkD,EAAE,EAAE,WAAW,CAAC;IAClB,IAAIE,CAAC,GAAG,eAAgBpD,CAAC,CAAEwB,CAAC,IAAK;MAC/B,IAAIM,CAAC,GAAGiB,CAAC,CAACvB,CAAC,CAAC;MACZ,OAAOM,CAAC,IAAI,IAAI,GAAG,IAAI,GAAG;QACxBJ,IAAI,EAAE,YAAY;QAClBD,IAAI,EAAEK;MACR,CAAC;IACH,CAAC,EAAE,gBAAgB,CAAC;IACpB,SAASuB,CAACA,CAAC7B,CAAC,EAAE;MACZ,OAAQM,CAAC,IAAK;QACZ,IAAI,CAACA,CAAC,CAACS,UAAU,CAACf,CAAC,CAAC,EAClB,OAAO,IAAI;QACb,IAAIY,CAAC,GAAGN,CAAC,CAACN,CAAC,CAACkB,MAAM,CAAC;QACnB,OAAON,CAAC,KAAK,KAAK,CAAC,IAAIU,CAAC,CAACE,IAAI,CAACZ,CAAC,CAAC,GAAG,IAAI,GAAG;UACxCV,IAAI,EAAEF,CAAC;UACPC,IAAI,EAAED;QACR,CAAC;MACH,CAAC;IACH;IACAxB,CAAC,CAACqD,CAAC,EAAE,iBAAiB,CAAC;IACvB,IAAIC,CAAC,GAAG,eAAgBtD,CAAC,CAAEwB,CAAC,IAAK;QAC/B,IAAIM,CAAC,GAAGU,CAAC,CAAChB,CAAC,CAAC;QACZ,OAAOM,CAAC,IAAI,IAAI,GAAG,IAAI,GAAG;UACxBJ,IAAI,EAAE,aAAa;UACnBD,IAAI,EAAEK;QACR,CAAC;MACH,CAAC,EAAE,iBAAiB,CAAC;MAAEyB,EAAE,GAAG,eAAgBvD,CAAC,CAAEwB,CAAC,IAAKA,CAAC,CAACkB,MAAM,GAAG,CAAC,GAAG,IAAI,GAAG;QACzEhB,IAAI,EAAE,KAAK;QACXD,IAAI,EAAE;MACR,CAAC,EAAE,SAAS,CAAC;MAAE+B,EAAE,GAAG,eAAgBxD,CAAC,CAAEwB,CAAC,IAAK;QAC3C,IAAIM,CAAC,GAAGoB,EAAE,CAAC1B,CAAC,CAAC;QACb,OAAOM,CAAC,KAAK,IAAI,GAAG,IAAI,GAAG;UACzBJ,IAAI,EAAE,QAAQ;UACdD,IAAI,EAAEK;QACR,CAAC;MACH,CAAC,EAAE,YAAY,CAAC;MAAE2B,EAAE,GAAG,CACrBF,EAAE,EACFjB,CAAC,CAAC,IAAI,CAAC,EACPA,CAAC,CAAC,GAAG,CAAC,EACNA,CAAC,CAAC,GAAG,CAAC,EACNA,CAAC,CAAC,GAAG,CAAC,EACNA,CAAC,CAAC,GAAG,CAAC,EACNA,CAAC,CAAC,GAAG,CAAC,EACNA,CAAC,CAAC,GAAG,CAAC,EACNA,CAAC,CAAC,GAAG,CAAC,EACNA,CAAC,CAAC,GAAG,CAAC,EACNA,CAAC,CAAC,GAAG,CAAC,EACNA,CAAC,CAAC,GAAG,CAAC,EACNA,CAAC,CAAC,GAAG,CAAC,EACNA,CAAC,CAAC,GAAG,CAAC,EACNA,CAAC,CAAC,GAAG,CAAC,EACNA,CAAC,CAAC,GAAG,CAAC,EACNA,CAAC,CAAC,GAAG,CAAC,EACNA,CAAC,CAAC,GAAG,CAAC,EACNA,CAAC,CAAC,GAAG,CAAC,EACNA,CAAC,CAAC,KAAK,CAAC,EACRA,CAAC,CAAC,GAAG,CAAC,EACNA,CAAC,CAAC,GAAG,CAAC,EACNA,CAAC,CAAC,GAAG,CAAC,EACNA,CAAC,CAAC,GAAG,CAAC,EACNA,CAAC,CAAC,GAAG,CAAC,EACNe,CAAC,CAAC,WAAW,CAAC,EACdA,CAAC,CAAC,MAAM,CAAC,EACTA,CAAC,CAAC,UAAU,CAAC,EACbA,CAAC,CAAC,MAAM,CAAC,EACTA,CAAC,CAAC,KAAK,CAAC,EACRA,CAAC,CAAC,QAAQ,CAAC,EACXA,CAAC,CAAC,OAAO,CAAC,EACVA,CAAC,CAAC,UAAU,CAAC,EACbA,CAAC,CAAC,QAAQ,CAAC,EACXA,CAAC,CAAC,OAAO,CAAC,EACVA,CAAC,CAAC,UAAU,CAAC,EACbA,CAAC,CAAC,QAAQ,CAAC,EACXA,CAAC,CAAC,IAAI,CAAC,EACPA,CAAC,CAAC,IAAI,CAAC,EACPA,CAAC,CAAC,SAAS,CAAC,EACZG,EAAE,EACFJ,CAAC,EACDE,CAAC,CACF;MAAEI,EAAE,GAAG,WAAW;MAAEC,CAAC,GAAG,MAAMA,CAAC,CAAC;QAC/B,OAAOvE,MAAMA,CAAC0C,CAAC,EAAE;UACf,IAAIM,CAAC,GAAG,IAAI,CAACwB,IAAI,CAAC9B,CAAC,CAAC;UACpBA,CAAC,GAAGM,CAAC,CAACX,IAAI;UACV,IAAIY,CAAC,GAAG,IAAI,CAACuB,IAAI,CAAC9B,CAAC,CAAC;UACpB,OAAOA,CAAC,GAAGO,CAAC,CAACZ,IAAI,EAAE,IAAIkC,CAAC,CAAC7B,CAAC,EAAE,KAAK,CAAC,EAAEM,CAAC,CAACL,KAAK,EAAEM,CAAC,CAACN,KAAK,CAAC;QACvD;QACAF,WAAWA,CAACC,CAAC,EAAEM,CAAC,EAAEC,CAAC,EAAEI,CAAC,EAAE;UACtB,IAAI,CAAChB,IAAI,GAAG,EAAE,EAAE,IAAI,CAACA,IAAI,GAAGK,CAAC,EAAE,IAAI,CAAC+B,QAAQ,GAAGzB,CAAC,EAAE,IAAI,CAAC0B,OAAO,GAAGzB,CAAC,EAAE,IAAI,CAAC0B,IAAI,GAAGtB,CAAC;QACnF;QACA,OAAOmB,IAAIA,CAAC9B,CAAC,EAAEM,CAAC,GAAG,CAAC,CAAC,EAAE;UACrBA,CAAC,GAAGA,CAAC,IAAIsB,EAAE,CAACV,IAAI,CAAClB,CAAC,CAAC,EAAEA,CAAC,GAAGA,CAAC,CAACkC,IAAI,CAAC,CAAC;UACjC,KAAK,IAAI3B,CAAC,IAAIoB,EAAE,EAAE;YAChB,IAAIhB,CAAC,GAAGJ,CAAC,CAACP,CAAC,CAAC;YACZ,IAAIW,CAAC,KAAK,IAAI,EAAE;cACd,IAAIwB,CAAC,GAAG9E,MAAM,CAAC+E,MAAM,CAAC/E,MAAM,CAAC+E,MAAM,CAAC,CAAC,CAAC,EAAEzB,CAAC,CAAC,EAAE;gBAAE0B,WAAW,EAAE/B;cAAE,CAAC,CAAC;cAC/D,OAAON,CAAC,GAAGA,CAAC,CAACa,KAAK,CAACsB,CAAC,CAACxC,IAAI,CAACiB,MAAM,CAAC,EAAE;gBAAEjB,IAAI,EAAEK,CAAC;gBAAEC,KAAK,EAAEkC;cAAE,CAAC;YAC1D;UACF;UACA,MAAM,IAAIrC,KAAK,CAAC,mBAAmB,GAAGE,CAAC,CAAC;QAC1C;QACAsC,OAAOA,CAAA,EAAG;UACR,IAAItC,CAAC,GAAG6B,CAAC,CAACC,IAAI,CAAC,IAAI,CAACnC,IAAI,CAAC;UACzB,OAAO,IAAIkC,CAAC,CAAC7B,CAAC,CAACL,IAAI,EAAE,IAAI,CAACqC,OAAO,EAAE,IAAI,CAACC,IAAI,EAAEjC,CAAC,CAACC,KAAK,CAAC;QACxD;MACF,CAAC;IACD/B,CAAC,CAAC2D,CAAC,EAAE,OAAO,CAAC;IACb,IAAIU,EAAE,GAAGV,CAAC;IACV,SAASW,CAACA,CAAC9C,CAAC,EAAE;MACZ,IAAIA,CAAC,KAAK,KAAK,CAAC,EACd,MAAM,IAAII,KAAK,CAAC,sBAAsB,CAAC;MACzC,IAAIJ,CAAC,CAACE,IAAI,KAAK,mBAAmB,IAAIF,CAAC,CAACE,IAAI,KAAK,wBAAwB,IAAIF,CAAC,CAACE,IAAI,KAAK,mBAAmB,IAAIF,CAAC,CAACE,IAAI,KAAK;AAChI,eAAe,IAAIF,CAAC,CAACE,IAAI,KAAK,sBAAsB,IAAIF,CAAC,CAACE,IAAI,KAAK,2BAA2B,IAAIF,CAAC,CAACE,IAAI,KAAK,yBAAyB,IAAIF,CAAC,CACrIE,IAAI,KAAK,qBAAqB,EAC5B,MAAM,IAAIhB,CAAC,CAACc,CAAC,CAAC;MAChB,OAAOA,CAAC;IACV;IACAxB,CAAC,CAACsE,CAAC,EAAE,kBAAkB,CAAC;IACxB,SAASC,EAAEA,CAAC/C,CAAC,EAAE;MACb,OAAOA,CAAC,CAACE,IAAI,KAAK,mBAAmB,GAAG8C,CAAC,CAAChD,CAAC,CAAC,GAAG8C,CAAC,CAAC9C,CAAC,CAAC;IACrD;IACAxB,CAAC,CAACuE,EAAE,EAAE,iCAAiC,CAAC;IACxC,SAASE,EAAEA,CAACjD,CAAC,EAAE;MACb,OAAOA,CAAC,CAACE,IAAI,KAAK,eAAe,GAAGF,CAAC,GAAGgD,CAAC,CAAChD,CAAC,CAAC;IAC9C;IACAxB,CAAC,CAACyE,EAAE,EAAE,iCAAiC,CAAC;IACxC,SAASD,CAACA,CAAChD,CAAC,EAAE;MACZ,IAAIA,CAAC,CAACE,IAAI,KAAK,mBAAmB,EAChC,MAAM,IAAIhB,CAAC,CAACc,CAAC,CAAC;MAChB,OAAOA,CAAC;IACV;IACAxB,CAAC,CAACwE,CAAC,EAAE,2BAA2B,CAAC;IACjC,SAASE,EAAEA,CAAClD,CAAC,EAAE;MACb,IAAIM,CAAC;MACL,IAAIN,CAAC,CAACE,IAAI,KAAK,mBAAmB,EAAE;QAClC,IAAI,CAAC,CAACI,CAAC,GAAGN,CAAC,CAACmD,OAAO,MAAM,IAAI,IAAI7C,CAAC,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,CAAC,CAACJ,IAAI,MAAM,eAAe,EAClF,OAAOF,CAAC;QACV,MAAM,IAAId,CAAC,CAACc,CAAC,CAAC;MAChB;MACA,IAAIA,CAAC,CAACE,IAAI,KAAK,iBAAiB,IAAIF,CAAC,CAACE,IAAI,KAAK,eAAe,EAC5D,MAAM,IAAIhB,CAAC,CAACc,CAAC,CAAC;MAChB,OAAOA,CAAC;IACV;IACAxB,CAAC,CAAC0E,EAAE,EAAE,kCAAkC,CAAC;IACzC,SAASE,EAAEA,CAACpD,CAAC,EAAE;MACb,OAAOA,CAAC,CAACE,IAAI,KAAK,yBAAyB,IAAIF,CAAC,CAACE,IAAI,KAAK,qBAAqB;IACjF;IACA1B,CAAC,CAAC4E,EAAE,EAAE,mBAAmB,CAAC;IAC1B,IAAIC,CAAC;IACL,CAAC,UAASrD,CAAC,EAAE;MACXA,CAAC,CAACA,CAAC,CAACsD,GAAG,GAAG,CAAC,CAAC,GAAG,KAAK,EAAEtD,CAAC,CAACA,CAAC,CAACuD,cAAc,GAAG,CAAC,CAAC,GAAG,gBAAgB,EAAEvD,CAAC,CAACA,CAAC,CAACwD,MAAM,GAAG,CAAC,CAAC,GAAG,QAAQ,EAAExD,CAAC,CAACA,CAAC,CAACyD,SAAS,GAAG,CAAC,CAAC,GAAG,WAAW,EAAEzD,CAAC,CAACA,CAAC,CAAC0D,cAAc,GAClJ,CAAC,CAAC,GAAG,gBAAgB,EAAE1D,CAAC,CAACA,CAAC,CAAC2D,KAAK,GAAG,CAAC,CAAC,GAAG,OAAO,EAAE3D,CAAC,CAACA,CAAC,CAAC4D,YAAY,GAAG,CAAC,CAAC,GAAG,cAAc,EAAE5D,CAAC,CAACA,CAAC,CAAC6D,MAAM,GAAG,CAAC,CAAC,GAAG,QAAQ,EAAE7D,CAAC,CAACA,CAAC,CAAC8D,KAAK,GAAG,CAAC,CAAC,GAAG;AAC5I,MAAM,EAAE9D,CAAC,CAACA,CAAC,CAAC+D,KAAK,GAAG,CAAC,CAAC,GAAG,OAAO,EAAE/D,CAAC,CAACA,CAAC,CAACgE,MAAM,GAAG,EAAE,CAAC,GAAG,QAAQ,EAAEhE,CAAC,CAACA,CAAC,CAACiE,QAAQ,GAAG,EAAE,CAAC,GAAG,UAAU,EAAEjE,CAAC,CAACA,CAAC,CAACkE,QAAQ,GAAG,EAAE,CAAC,GAAG,UAAU,EAAElE,CAAC,CAACA,CAAC,CAACmE,cAAc,GAC7I,EAAE,CAAC,GAAG,gBAAgB,EAAEnE,CAAC,CAACA,CAAC,CAACoE,QAAQ,GAAG,EAAE,CAAC,GAAG,UAAU,EAAEpE,CAAC,CAACA,CAAC,CAACqE,KAAK,GAAG,EAAE,CAAC,GAAG,OAAO,EAAErE,CAAC,CAACA,CAAC,CAACsE,cAAc,GAAG,EAAE,CAAC,GAAG,gBAAgB,EAAEtE,CAAC,CAACA,CAAC,CAACuE,OAAO,GAC5I,EAAE,CAAC,GAAG,SAAS,EAAEvE,CAAC,CAACA,CAAC,CAACwE,SAAS,GAAG,EAAE,CAAC,GAAG,WAAW,EAAExE,CAAC,CAACA,CAAC,CAACyE,WAAW,GAAG,EAAE,CAAC,GAAG,aAAa,EAAEzE,CAAC,CAACA,CAAC,CAAC0E,aAAa,GAAG,EAAE,CAAC,GAAG,eAAe;IACtI,CAAC,EAAErB,CAAC,KAAKA,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;IACjB,IAAIsB,EAAE,GAAG,MAAMA,EAAE,CAAC;MAChBtE,WAAWA,CAACC,CAAC,EAAEM,CAAC,EAAEC,CAAC,EAAE;QACnB,IAAI,CAAC+D,OAAO,GAAGtE,CAAC,EAAE,OAAOM,CAAC,IAAI,QAAQ,GAAG,IAAI,CAACiE,MAAM,GAAGhC,EAAE,CAACjF,MAAM,CAACgD,CAAC,CAAC,GAAG,IAAI,CAACiE,MAAM,GAAGjE,CAAC,EAAE,IAAI,CAACkE,UAAU,GAAGjE,CAAC;MAC5G;MACA,IAAIkE,KAAKA,CAAA,EAAG;QACV,OAAO,IAAI,CAACF,MAAM;MACpB;MACA;AACN;AACA;MACMG,KAAKA,CAAA,EAAG;QACN,IAAI1E,CAAC,GAAG,IAAI,CAAC2E,SAAS,CAAC5B,CAAC,CAACC,GAAG,CAAC;QAC7B,IAAI,IAAI,CAACyB,KAAK,CAACzC,OAAO,CAACpC,IAAI,KAAK,KAAK,EACnC,MAAM,IAAIjB,CAAC,CAAC,IAAI,CAAC8F,KAAK,CAACzC,OAAO,CAAC;QACjC,OAAOhC,CAAC;MACV;MACA;AACN;AACA;MACM2E,SAASA,CAAC3E,CAAC,EAAE;QACX,OAAOwC,CAAC,CAAC,IAAI,CAACoC,qBAAqB,CAAC5E,CAAC,CAAC,CAAC;MACzC;MACA;AACN;AACA;AACA;MACM4E,qBAAqBA,CAAC5E,CAAC,EAAE;QACvB,IAAIM,CAAC,GAAG,IAAI,CAACuE,WAAW,CAAC,IAAI,EAAE7E,CAAC,CAAC;QACjC,IAAIM,CAAC,KAAK,IAAI,EACZ,MAAM,IAAI5B,CAAC,CAAC,IAAI,CAAC+F,KAAK,CAACzC,OAAO,CAAC;QACjC,OAAO,IAAI,CAAC8C,0BAA0B,CAACxE,CAAC,EAAEN,CAAC,CAAC;MAC9C;MACA;AACN;AACA;AACA;MACM8E,0BAA0BA,CAAC9E,CAAC,EAAEM,CAAC,EAAE;QAC/B,IAAIC,CAAC,GAAG,IAAI,CAACsE,WAAW,CAAC7E,CAAC,EAAEM,CAAC,CAAC;QAC9B,OAAOC,CAAC,KAAK,IAAI,GACfP,CAAC,GAAGO,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACsE,WAAW,CAAC7E,CAAC,EAAEM,CAAC,CAAC;QACnC,OAAON,CAAC;MACV;MACA;AACN;AACA;MACM6E,WAAWA,CAAC7E,CAAC,EAAEM,CAAC,EAAE;QAChB,KAAK,IAAIC,CAAC,IAAI,IAAI,CAAC+D,OAAO,EAAE;UAC1B,IAAI3D,CAAC,GAAGJ,CAAC,CAAC,IAAI,EAAED,CAAC,EAAEN,CAAC,CAAC;UACrB,IAAIW,CAAC,KAAK,IAAI,EACZ,OAAOA,CAAC;QACZ;QACA,OAAO,IAAI;MACb;MACA;AACN;AACA;AACA;MACMoE,OAAOA,CAAC/E,CAAC,EAAE;QACT,OAAOgF,KAAK,CAACC,OAAO,CAACjF,CAAC,CAAC,KAAKA,CAAC,GAAG,CAACA,CAAC,CAAC,CAAC,EAAEA,CAAC,CAACkF,QAAQ,CAAC,IAAI,CAACT,KAAK,CAACzC,OAAO,CAACpC,IAAI,CAAC,IAAI,IAAI,CAAC2E,MAAM,GAAG,IAAI,CAACE,KAAK,CAACnC,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC;MAC3H;MACA6C,gBAAgBA,CAACnF,CAAC,EAAE;QAClB,IAAI,CAACuE,MAAM,GAAGvE,CAAC,CAACyE,KAAK;MACvB;IACF,CAAC;IACDvG,CAAC,CAACmG,EAAE,EAAE,QAAQ,CAAC;IACf,IAAIe,CAAC,GAAGf,EAAE;IACV,SAASgB,EAAEA,CAAC3F,CAAC,EAAE;MACb,OAAOA,CAAC,KAAK,KAAK,IAAIA,CAAC,KAAK,GAAG,IAAIA,CAAC,KAAK,GAAG,IAAIA,CAAC,KAAK,GAAG,IAAIA,CAAC,KAAK,GAAG;IACxE;IACAxB,CAAC,CAACmH,EAAE,EAAE,2BAA2B,CAAC;IAClC,IAAIC,EAAE,GAAG,eAAgBpH,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,EAAEM,CAAC,KAAK;MACtC,IAAIC,CAAC,GAAGb,CAAC,CAAC+E,KAAK,CAACzC,OAAO,CAACpC,IAAI;QAAEe,CAAC,GAAGjB,CAAC,CAAC+E,KAAK,CAACxC,IAAI,CAACrC,IAAI;MACnD,OAAOU,CAAC,IAAI,IAAI,IAAIC,CAAC,KAAK,GAAG,IAAI,CAAC8E,EAAE,CAAC1E,CAAC,CAAC,IAAIL,CAAC,IAAI,IAAI,IAAIC,CAAC,KAAK,GAAG,IAAIb,CAAC,CAACqF,OAAO,CAAC,GAAG,CAAC,EAAEzE,CAAC,IAAI,IAAI,GAAG;QAC/FV,IAAI,EAAE,mBAAmB;QACzBiD,OAAO,EAAEnD,CAAC,CAACiF,SAAS,CAAC5B,CAAC,CAACa,QAAQ,CAAC;QAChC2B,IAAI,EAAE;UACJC,QAAQ,EAAE;QACZ;MACF,CAAC,GAAG;QACF5F,IAAI,EAAE,mBAAmB;QACzBiD,OAAO,EAAEL,CAAC,CAAClC,CAAC,CAAC;QACbiF,IAAI,EAAE;UACJC,QAAQ,EAAE;QACZ;MACF,CAAC,IAAI,IAAI;IACX,CAAC,EAAE,iBAAiB,CAAC;IACrB,SAASC,CAACA,CAAC/F,CAAC,EAAE;MACZ,IAAIM,CAAC,GAAG,eAAgB9B,CAAC,CAAC,CAACoC,CAAC,EAAEC,CAAC,EAAEI,CAAC,KAAK;QACrC,IAAIwB,CAAC,GAAG7B,CAAC,CAACmE,KAAK,CAACzC,OAAO,CAACpC,IAAI;UAAE8F,CAAC,GAAGpF,CAAC,CAACmE,KAAK,CAACxC,IAAI,CAACrC,IAAI;QACnD,IAAIe,CAAC,KAAK,IAAI,EAAE;UACd,IAAI,aAAa,IAAIjB,CAAC,IAAIA,CAAC,CAACiG,MAAM,CAACxD,CAAC,EAAEuD,CAAC,CAAC,EACtC,OAAOhG,CAAC,CAACkG,WAAW,CAACtF,CAAC,CAAC;QAC3B,CAAC,MAAM,IAAI,YAAY,IAAIZ,CAAC,IAAIA,CAAC,CAACmG,UAAU,GAAGtF,CAAC,IAAIb,CAAC,CAACiG,MAAM,CAACxD,CAAC,EAAEuD,CAAC,CAAC,EAChE,OAAOhG,CAAC,CAACoG,UAAU,CAACxF,CAAC,EAAEK,CAAC,CAAC;QAC3B,OAAO,IAAI;MACb,CAAC,EAAE,SAAS,CAAC;MACb,OAAOtD,MAAM,CAACG,cAAc,CAACwC,CAAC,EAAE,MAAM,EAAE;QACtC3B,KAAK,EAAEqB,CAAC,CAACqG;MACX,CAAC,CAAC,EAAE/F,CAAC;IACP;IACA9B,CAAC,CAACuH,CAAC,EAAE,gBAAgB,CAAC;IACtB,IAAIO,CAAC,GAAGP,CAAC,CAAC;QACRM,IAAI,EAAE,iBAAiB;QACvBJ,MAAM,EAAE,eAAgBzH,CAAC,CAAEwB,CAAC,IAAKA,CAAC,KAAK,GAAG,EAAE,QAAQ,CAAC;QACrDmG,UAAU,EAAE9C,CAAC,CAACY,QAAQ;QACtBiC,WAAW,EAAE,eAAgB1H,CAAC,CAAEwB,CAAC,KAAMA,CAAC,CAACqF,OAAO,CAAC,GAAG,CAAC,EAAE;UACrDnF,IAAI,EAAE,mBAAmB;UACzBiD,OAAO,EAAEnD,CAAC,CAACiF,SAAS,CAAC5B,CAAC,CAACY,QAAQ,CAAC;UAChC4B,IAAI,EAAE;YACJC,QAAQ,EAAE;UACZ;QACF,CAAC,CAAC,EAAE,aAAa,CAAC;QAClBM,UAAU,EAAE,eAAgB5H,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,MAAMN,CAAC,CAACqF,OAAO,CAAC,GAAG,CAAC,EAAE;UACvDnF,IAAI,EAAE,mBAAmB;UACzBiD,OAAO,EAAEL,CAAC,CAACxC,CAAC,CAAC;UACbuF,IAAI,EAAE;YACJC,QAAQ,EAAE;UACZ;QACF,CAAC,CAAC,EAAE,YAAY;MAClB,CAAC,CAAC;MAAES,CAAC,GAAGR,CAAC,CAAC;QACRM,IAAI,EAAE,eAAe;QACrBJ,MAAM,EAAE,eAAgBzH,CAAC,CAAEwB,CAAC,IAAKA,CAAC,KAAK,QAAQ,EAAE,QAAQ,CAAC;QAC1DkG,WAAW,EAAE,eAAgB1H,CAAC,CAAEwB,CAAC,IAAK;UACpC,IAAIM,CAAC,GAAGkG,UAAU,CAACxG,CAAC,CAAC+E,KAAK,CAACzC,OAAO,CAACrC,IAAI,CAAC;UACxC,OAAOD,CAAC,CAACqF,OAAO,CAAC,QAAQ,CAAC,EAAE;YAC1BnF,IAAI,EAAE,iBAAiB;YACvBvB,KAAK,EAAE2B;UACT,CAAC;QACH,CAAC,EAAE,aAAa;MAClB,CAAC,CAAC;MAAEmG,EAAE,GAAGV,CAAC,CAAC;QACTM,IAAI,EAAE,oBAAoB;QAC1BJ,MAAM,EAAE,eAAgBzH,CAAC,CAAEwB,CAAC,IAAKA,CAAC,KAAK,GAAG,EAAE,QAAQ,CAAC;QACrDkG,WAAW,EAAE,eAAgB1H,CAAC,CAAEwB,CAAC,IAAK;UACpC,IAAIA,CAAC,CAACqF,OAAO,CAAC,GAAG,CAAC,EAAErF,CAAC,CAACqF,OAAO,CAAC,GAAG,CAAC,EAChC,OAAO;YACLnF,IAAI,EAAE,wBAAwB;YAC9BwG,QAAQ,EAAE;UACZ,CAAC;UACH,IAAIpG,CAAC,GAAGN,CAAC,CAACkF,qBAAqB,CAAC7B,CAAC,CAACC,GAAG,CAAC;UACtC,IAAI,CAACtD,CAAC,CAACqF,OAAO,CAAC,GAAG,CAAC,EACjB,MAAM,IAAIjF,KAAK,CAAC,0BAA0B,CAAC;UAC7C,OAAOE,CAAC,CAACJ,IAAI,KAAK,wBAAwB,GAAGI,CAAC,GAAGA,CAAC,CAACJ,IAAI,KAAK,mBAAmB,GAAG;YAChFA,IAAI,EAAE,wBAAwB;YAC9BwG,QAAQ,EAAE,CAACpG,CAAC;UACd,CAAC,GAAG;YACFJ,IAAI,EAAE,sBAAsB;YAC5BiD,OAAO,EAAEL,CAAC,CAACxC,CAAC;UACd,CAAC;QACH,CAAC,EAAE,aAAa;MAClB,CAAC,CAAC;MAAEqG,EAAE,GAAGZ,CAAC,CAAC;QACTM,IAAI,EAAE,qBAAqB;QAC3BJ,MAAM,EAAE,eAAgBzH,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAKN,CAAC,KAAK,GAAG,IAAI2F,EAAE,CAACrF,CAAC,CAAC,IAAIN,CAAC,KAAK,MAAM,IAAIA,CAAC,KAAK,WAAW,IAAIA,CAAC,KAAK,GAAG,EAAE,QAAQ,CAAC;QACnHkG,WAAW,EAAE,eAAgB1H,CAAC,CAAEwB,CAAC,IAAK;UACpC,IAAIA,CAAC,CAACqF,OAAO,CAAC,MAAM,CAAC,EACnB,OAAO;YACLnF,IAAI,EAAE;UACR,CAAC;UACH,IAAIF,CAAC,CAACqF,OAAO,CAAC,WAAW,CAAC,EACxB,OAAO;YACLnF,IAAI,EAAE;UACR,CAAC;UACH,IAAIF,CAAC,CAACqF,OAAO,CAAC,GAAG,CAAC,EAChB,OAAO;YACLnF,IAAI,EAAE;UACR,CAAC;UACH,IAAIF,CAAC,CAACqF,OAAO,CAAC,GAAG,CAAC,EAChB,OAAO;YACLnF,IAAI,EAAE;UACR,CAAC;UACH,MAAM,IAAIE,KAAK,CAAC,sBAAsB,GAAGJ,CAAC,CAAC+E,KAAK,CAACzC,OAAO,CAACrC,IAAI,CAAC;QAChE,CAAC,EAAE,aAAa;MAClB,CAAC,CAAC;MAAE2G,EAAE,GAAGb,CAAC,CAAC;QACTM,IAAI,EAAE,oBAAoB;QAC1BJ,MAAM,EAAE,eAAgBzH,CAAC,CAAEwB,CAAC,IAAKA,CAAC,KAAK,GAAG,EAAE,QAAQ,CAAC;QACrDmG,UAAU,EAAE9C,CAAC,CAACa,QAAQ;QACtBgC,WAAW,EAAE,eAAgB1H,CAAC,CAAEwB,CAAC,KAAMA,CAAC,CAACqF,OAAO,CAAC,GAAG,CAAC,EAAE;UACrDnF,IAAI,EAAE,sBAAsB;UAC5BiD,OAAO,EAAEnD,CAAC,CAACiF,SAAS,CAAC5B,CAAC,CAACa,QAAQ,CAAC;UAChC2B,IAAI,EAAE;YACJC,QAAQ,EAAE;UACZ;QACF,CAAC,CAAC,EAAE,aAAa,CAAC;QAClBM,UAAU,EAAE,eAAgB5H,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,MAAMN,CAAC,CAACqF,OAAO,CAAC,GAAG,CAAC,EAAE;UACvDnF,IAAI,EAAE,sBAAsB;UAC5BiD,OAAO,EAAEL,CAAC,CAACxC,CAAC,CAAC;UACbuF,IAAI,EAAE;YACJC,QAAQ,EAAE;UACZ;QACF,CAAC,CAAC,EAAE,YAAY;MAClB,CAAC,CAAC;IACF,SAASe,EAAEA,CAAC;MAAEC,kBAAkB,EAAE9G;IAAE,CAAC,EAAE;MACrC,OAAO+F,CAAC,CAAC;QACPM,IAAI,EAAE,sBAAsB;QAC5BJ,MAAM,EAAE,eAAgBzH,CAAC,CAAE8B,CAAC,IAAKA,CAAC,KAAK,GAAG,EAAE,QAAQ,CAAC;QACrD6F,UAAU,EAAE9C,CAAC,CAACE,cAAc;QAC5B6C,UAAU,EAAE,eAAgB5H,CAAC,CAAC,CAAC8B,CAAC,EAAEM,CAAC,KAAK;UACtC,IAAIC,CAAC,GAAG,CACNkC,EAAE,CAACnC,CAAC,CAAC,CACN;UACDN,CAAC,CAAC+E,OAAO,CAAC,GAAG,CAAC;UACd,GACE,IAAI;YACF,IAAIpE,CAAC,GAAGX,CAAC,CAAC4E,qBAAqB,CAAC7B,CAAC,CAACE,cAAc,CAAC;YACjD1C,CAAC,CAACkG,IAAI,CAAChE,EAAE,CAAC9B,CAAC,CAAC,CAAC;UACf,CAAC,CAAC,OAAOA,CAAC,EAAE;YACV,IAAIjB,CAAC,IAAIiB,CAAC,YAAYjC,CAAC,EACrB;YACF,MAAMiC,CAAC;UACT,CAAC,QACIX,CAAC,CAAC+E,OAAO,CAAC,GAAG,CAAC;UACrB,IAAIxE,CAAC,CAACK,MAAM,GAAG,CAAC,IAAIL,CAAC,CAACM,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC6F,IAAI,CAAE/F,CAAC,IAAKA,CAAC,CAACf,IAAI,KAAK,mBAAmB,CAAC,EAC5E,MAAM,IAAIE,KAAK,CAAC,iDAAiD,CAAC;UACpE,OAAO;YACLF,IAAI,EAAE,wBAAwB;YAC9BwG,QAAQ,EAAE7F;UACZ,CAAC;QACH,CAAC,EAAE,YAAY;MACjB,CAAC,CAAC;IACJ;IACArC,CAAC,CAACqI,EAAE,EAAE,4BAA4B,CAAC;IACnC,IAAII,EAAE,GAAGlB,CAAC,CAAC;QACTM,IAAI,EAAE,gBAAgB;QACtBJ,MAAM,EAAE,eAAgBzH,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAKN,CAAC,KAAK,GAAG,IAAIA,CAAC,KAAK,GAAG,IAAIM,CAAC,KAAK,GAAG,EAAE,QAAQ,CAAC;QAClF6F,UAAU,EAAE9C,CAAC,CAACkB,OAAO;QACrB6B,UAAU,EAAE,eAAgB5H,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAK;UACtC,IAAIM,CAAC,GAAGZ,CAAC,CAACqF,OAAO,CAAC,GAAG,CAAC;UACtBrF,CAAC,CAACqF,OAAO,CAAC,GAAG,CAAC;UACd,IAAIxE,CAAC,GAAG,EAAE;UACV,GACEA,CAAC,CAACkG,IAAI,CAAC/G,CAAC,CAACiF,SAAS,CAAC5B,CAAC,CAACE,cAAc,CAAC,CAAC,CAAC,QACjCvD,CAAC,CAACqF,OAAO,CAAC,GAAG,CAAC;UACrB,IAAI,CAACrF,CAAC,CAACqF,OAAO,CAAC,GAAG,CAAC,EACjB,MAAM,IAAIjF,KAAK,CAAC,qCAAqC,CAAC;UACxD,OAAO;YACLF,IAAI,EAAE,kBAAkB;YACxBgH,IAAI,EAAEpE,CAAC,CAACxC,CAAC,CAAC;YACVoG,QAAQ,EAAE7F,CAAC;YACXgF,IAAI,EAAE;cACJsB,QAAQ,EAAE,OAAO;cACjBC,GAAG,EAAExG;YACP;UACF,CAAC;QACH,CAAC,EAAE,YAAY;MACjB,CAAC,CAAC;MAAEyG,EAAE,GAAGtB,CAAC,CAAC;QACTM,IAAI,EAAE,cAAc;QACpBJ,MAAM,EAAE,eAAgBzH,CAAC,CAAEwB,CAAC,IAAKA,CAAC,KAAK,GAAG,EAAE,QAAQ,CAAC;QACrDmG,UAAU,EAAE9C,CAAC,CAACM,KAAK;QACnByC,UAAU,EAAE,eAAgB5H,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAK;UACtCN,CAAC,CAACqF,OAAO,CAAC,GAAG,CAAC;UACd,IAAIzE,CAAC,GAAG,EAAE;UACV,GACEA,CAAC,CAACmG,IAAI,CAAC/G,CAAC,CAACiF,SAAS,CAAC5B,CAAC,CAACM,KAAK,CAAC,CAAC,CAAC,QACxB3D,CAAC,CAACqF,OAAO,CAAC,GAAG,CAAC;UACrB,OAAO;YACLnF,IAAI,EAAE,gBAAgB;YACtBwG,QAAQ,EAAE,CAAC5D,CAAC,CAACxC,CAAC,CAAC,EAAE,GAAGM,CAAC;UACvB,CAAC;QACH,CAAC,EAAE,YAAY;MACjB,CAAC,CAAC;MAAE0G,EAAE,GAAG,CACP1B,EAAE,EACFU,CAAC,EACDC,CAAC,EACDE,EAAE,EACFE,EAAE,EACFC,EAAE,EACFC,EAAE,CAAC;QACDC,kBAAkB,EAAE,CAAC;MACvB,CAAC,CAAC,EACFG,EAAE,EACFI,EAAE,EACFf,CAAC,CACF;IACD,SAASiB,EAAEA,CAAC;MAAEC,4BAA4B,EAAExH,CAAC;MAAEyH,mBAAmB,EAAEnH,CAAC;MAAEoH,WAAW,EAAE9G;IAAE,CAAC,EAAE;MACvF,OAAO,eAAgBpC,CAAC,CAAC,UAASyC,CAAC,EAAEwB,CAAC,EAAEuD,CAAC,EAAE;QACzC,IAAIA,CAAC,IAAI,IAAI,IAAIvD,CAAC,IAAIY,CAAC,CAACmB,SAAS,EAC/B,OAAO,IAAI;QACb,IAAImD,CAAC,GAAG1G,CAAC,CAAC8D,KAAK,CAACzC,OAAO,CAACpC,IAAI;UAAE0H,CAAC,GAAG3G,CAAC,CAAC8D,KAAK,CAACxC,IAAI,CAACrC,IAAI;QACnD,IAAI,EAAEyH,CAAC,KAAK,GAAG,IAAIC,CAAC,KAAK,GAAG,IAAID,CAAC,KAAK,GAAG,KAAK3H,CAAC,IAAIgG,CAAC,CAAC9F,IAAI,KAAK,eAAe,CAAC,IAAII,CAAC,KAAKqH,CAAC,KAAK,GAAG,IAAIA,CAAC,KAAK,GAAG,CAAC,CAAC,EAC9G,OAAO,IAAI;QACb,IAAIE,CAAC;UAAEC,EAAE,GAAG,CAAC,CAAC;QACd7G,CAAC,CAACoE,OAAO,CAAC,GAAG,CAAC,GAAGwC,CAAC,GAAG,UAAU,GAAG5G,CAAC,CAACoE,OAAO,CAAC,GAAG,CAAC,IAAIwC,CAAC,GAAG,mBAAmB,EAAEC,EAAE,GAAG,CAAC,CAAC,IAAI7G,CAAC,CAACoE,OAAO,CAAC,GAAG,CAAC,GAAGwC,CAAC,GAAG,OAAO,IAAI5G,CAAC,CAACoE,OAAO,CAAC,GAAG,CAAC,EACtIwC,CAAC,GAAG,UAAU,CAAC;QACf,IAAIE,EAAE,GAAGnH,CAAC,KAAK,IAAI,GAAG,IAAI8E,CAAC,CAAC9E,CAAC,EAAEK,CAAC,CAAC8D,KAAK,EAAE9D,CAAC,CAAC,GAAGA,CAAC;UAAE+G,CAAC,GAAGD,EAAE,CAAC7C,qBAAqB,CAAC7B,CAAC,CAACmB,SAAS,CAAC;QACzFvD,CAAC,CAACwE,gBAAgB,CAACsC,EAAE,CAAC;QACtB,IAAIE,CAAC;QACL,QAAQD,CAAC,CAAC9H,IAAI;UACZ,KAAK,eAAe;YAClB+H,CAAC,GAAG;cACF/H,IAAI,EAAE,mBAAmB;cACzBvB,KAAK,EAAEqJ,CAAC,CAACrJ,KAAK;cACdkH,IAAI,EAAE;gBACJqC,KAAK,EAAE,KAAK;cACd;YACF,CAAC;YACD;UACF,KAAK,iBAAiB;YACpBD,CAAC,GAAG;cACF/H,IAAI,EAAE,mBAAmB;cACzBvB,KAAK,EAAEqJ,CAAC,CAACrJ,KAAK,CAACwJ,QAAQ,CAAC,EAAE,CAAC;cAC3BtC,IAAI,EAAE;gBACJqC,KAAK,EAAE,KAAK;cACd;YACF,CAAC;YACD;UACF,KAAK,sBAAsB;YACzBD,CAAC,GAAG;cACF/H,IAAI,EAAE,mBAAmB;cACzBvB,KAAK,EAAEqJ,CAAC,CAACrJ,KAAK;cACdkH,IAAI,EAAE;gBACJqC,KAAK,EAAEF,CAAC,CAACnC,IAAI,CAACqC;cAChB;YACF,CAAC;YACD;UACF,KAAK,0BAA0B;YAC7B,IAAIF,CAAC,CAACI,WAAW,KAAK,OAAO,EAC3BH,CAAC,GAAGD,CAAC,CAAC,KAEN,MAAM,IAAI9I,CAAC,CAAC8I,CAAC,EAAE,0EAA0E,CAAC;YAC5F;UACF;YACE,MAAM,IAAI9I,CAAC,CAAC8I,CAAC,EAAE,gGAAgG,CAAC;QACpH;QACA,IAAIF,EAAE,IAAI,CAAC7G,CAAC,CAACoE,OAAO,CAAC,GAAG,CAAC,EAAE;UACzB,IAAIgD,EAAE,GAAGpH,CAAC,CAAC8D,KAAK,CAACzC,OAAO;UACxB,MAAM,IAAIlC,KAAK,CAAC,gDAAgDiI,EAAE,CAACnI,IAAI,gBAAgBmI,EAAE,CAACpI,IAAI,GAAG,CAAC;QACpG;QACA,OAAO;UACLC,IAAI,EAAE,mBAAmB;UACzBgH,IAAI,EAAEpE,CAAC,CAACkD,CAAC,CAAC;UACVsC,KAAK,EAAEL,CAAC;UACRM,QAAQ,EAAEV;QACZ,CAAC;MACH,CAAC,EAAE,iBAAiB,CAAC;IACvB;IACArJ,CAAC,CAAC+I,EAAE,EAAE,uBAAuB,CAAC;IAC9B,SAASiB,CAACA,CAAC;MAAEC,uBAAuB,EAAEzI;IAAE,CAAC,EAAE;MACzC,OAAO+F,CAAC,CAAC;QACPM,IAAI,EAAE,aAAa;QACnBJ,MAAM,EAAE,eAAgBzH,CAAC,CAAE8B,CAAC,IAAKA,CAAC,KAAK,YAAY,IAAIA,CAAC,KAAK,MAAM,IAAIA,CAAC,KAAK,KAAK,IAAIN,CAAC,CAACwF,QAAQ,CAAClF,CAAC,CAAC,EAAE,QAAQ,CAAC;QAC9G4F,WAAW,EAAE,eAAgB1H,CAAC,CAAE8B,CAAC,IAAK;UACpC,IAAI;YAAEJ,IAAI,EAAEU,CAAC;YAAEX,IAAI,EAAEY;UAAE,CAAC,GAAGP,CAAC,CAACyE,KAAK,CAACzC,OAAO;UAC1C,OAAOhC,CAAC,CAAC+E,OAAO,CAACzE,CAAC,CAAC,EAAE;YACnBV,IAAI,EAAE,eAAe;YACrBvB,KAAK,EAAEkC;UACT,CAAC;QACH,CAAC,EAAE,aAAa;MAClB,CAAC,CAAC;IACJ;IACArC,CAAC,CAACgK,CAAC,EAAE,mBAAmB,CAAC;IACzB,IAAIE,CAAC,GAAG3C,CAAC,CAAC;MACRM,IAAI,EAAE,oBAAoB;MAC1BJ,MAAM,EAAE,eAAgBzH,CAAC,CAAEwB,CAAC,IAAKA,CAAC,KAAK,aAAa,EAAE,QAAQ,CAAC;MAC/DkG,WAAW,EAAE,eAAgB1H,CAAC,CAAEwB,CAAC,IAAK;QACpC,IAAIM,CAAC,GAAGN,CAAC,CAAC+E,KAAK,CAACzC,OAAO,CAACrC,IAAI;QAC5B,OAAOD,CAAC,CAACqF,OAAO,CAAC,aAAa,CAAC,EAAE;UAC/BnF,IAAI,EAAE,sBAAsB;UAC5BvB,KAAK,EAAE2B,CAAC,CAACa,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;UACrB0E,IAAI,EAAE;YACJqC,KAAK,EAAE5H,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,GAAG,QAAQ,GAAG;UACnC;QACF,CAAC;MACH,CAAC,EAAE,aAAa;IAClB,CAAC,CAAC;IACF,SAASqI,EAAEA,CAAC;MAAEjB,WAAW,EAAE1H,CAAC;MAAE4I,YAAY,EAAEtI;IAAE,CAAC,EAAE;MAC/C,OAAOyF,CAAC,CAAC;QACPM,IAAI,EAAE,wBAAwB;QAC9BJ,MAAM,EAAE,eAAgBzH,CAAC,CAAEoC,CAAC,IAAKN,CAAC,CAACkF,QAAQ,CAAC5E,CAAC,CAAC,EAAE,QAAQ,CAAC;QACzDsF,WAAW,EAAE,eAAgB1H,CAAC,CAAEoC,CAAC,IAAK;UACpC,IAAIC,CAAC,GAAGD,CAAC,CAACmE,KAAK,CAACzC,OAAO,CAACpC,IAAI;UAC5B,IAAIU,CAAC,CAACyE,OAAO,CAACxE,CAAC,CAAC,EAAE,CAACD,CAAC,CAACyE,OAAO,CAAC,GAAG,CAAC,EAC/B,OAAO;YACLnF,IAAI,EAAE,eAAe;YACrBvB,KAAK,EAAEkC;UACT,CAAC;UACH,IAAII,CAAC;YAAEwB,CAAC,GAAG7B,CAAC,CAACmE,KAAK,CAACzC,OAAO;UAC1B,IAAI1B,CAAC,CAACyE,OAAO,CAAC,aAAa,CAAC,EAC1BpE,CAAC,GAAG;YACFf,IAAI,EAAE,0BAA0B;YAChCvB,KAAK,EAAE8D,CAAC,CAACxC,IAAI,CAACkB,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;YAC1BiH,WAAW,EAAEvH,CAAC;YACdgF,IAAI,EAAE;cACJqC,KAAK,EAAEzF,CAAC,CAACxC,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,GAAG,QAAQ,GAAG;YACxC;UACF,CAAC,CAAC,KACC;YACH,IAAI2H,CAAC,GAAG,EAAE;cAAEiB,CAAC,GAAG,CAAC,YAAY,EAAE,GAAG,EAAE,GAAG,CAAC;YACxC,OAAOA,CAAC,CAAC7B,IAAI,CAAEa,CAAC,IAAKjH,CAAC,CAACyE,OAAO,CAACwC,CAAC,CAAC,CAAC,GAChCD,CAAC,IAAInF,CAAC,CAACxC,IAAI,EAAEwC,CAAC,GAAG7B,CAAC,CAACmE,KAAK,CAACzC,OAAO;YAClCrB,CAAC,GAAG;cACFf,IAAI,EAAE,0BAA0B;cAChCvB,KAAK,EAAEiJ,CAAC;cACRQ,WAAW,EAAEvH,CAAC;cACdgF,IAAI,EAAE;gBACJqC,KAAK,EAAE,KAAK;cACd;YACF,CAAC;UACH;UACA,IAAIlC,CAAC,GAAG,IAAIN,CAAC,CAAC1F,CAAC,EAAEY,CAAC,CAACmE,KAAK,EAAEnE,CAAC,CAAC;YAAE+G,CAAC,GAAG3B,CAAC,CAACZ,0BAA0B,CAACnE,CAAC,EAAEoC,CAAC,CAACC,GAAG,CAAC;UACxE,OAAO1C,CAAC,CAAC6E,gBAAgB,CAACO,CAAC,CAAC,EAAElD,CAAC,CAAC6E,CAAC,CAAC;QACpC,CAAC,EAAE,aAAa;MAClB,CAAC,CAAC;IACJ;IACAnJ,CAAC,CAACmK,EAAE,EAAE,8BAA8B,CAAC;IACrC,IAAIG,EAAE,GAAG,CACPN,CAAC,CAAC;QACAC,uBAAuB,EAAE,CAAC,UAAU,EAAE,QAAQ;MAChD,CAAC,CAAC,EACFC,CAAC,EACDnC,CAAC,EACDgB,EAAE,CAAC;QACDC,4BAA4B,EAAE,CAAC,CAAC;QAChCC,mBAAmB,EAAE,CAAC,CAAC;QACvBC,WAAW,EAAE;MACf,CAAC,CAAC,CACH;MAAEqB,CAAC,GAAG,CACL,GAAGD,EAAE,EACLH,EAAE,CAAC;QACDC,YAAY,EAAE,CAAC,OAAO,CAAC;QACvBlB,WAAW,EAAEoB;MACf,CAAC,CAAC,CACH;IACD,SAASE,EAAEA,CAAChJ,CAAC,EAAE;MACb,IAAIM,CAAC;MACL,IAAIN,CAAC,CAACE,IAAI,KAAK,wBAAwB,EACrCI,CAAC,GAAGN,CAAC,CAAC0G,QAAQ,CAAC,KACZ,IAAI1G,CAAC,CAACE,IAAI,KAAK,sBAAsB,EACxCI,CAAC,GAAG,CAACN,CAAC,CAACmD,OAAO,CAAC,CAAC,KAEhB,MAAM,IAAIjE,CAAC,CAACc,CAAC,CAAC;MAChB,OAAOM,CAAC,CAAC2I,GAAG,CAAErI,CAAC,IAAKmC,EAAE,CAACnC,CAAC,CAAC,CAAC;IAC5B;IACApC,CAAC,CAACwK,EAAE,EAAE,eAAe,CAAC;IACtB,SAASE,EAAEA,CAAClJ,CAAC,EAAE;MACb,IAAIM,CAAC,GAAG0I,EAAE,CAAChJ,CAAC,CAAC;MACb,IAAIM,CAAC,CAAC0G,IAAI,CAAEpG,CAAC,IAAKA,CAAC,CAACV,IAAI,KAAK,mBAAmB,CAAC,EAC/C,MAAM,IAAIE,KAAK,CAAC,8BAA8B,CAAC;MACjD,OAAOE,CAAC;IACV;IACA9B,CAAC,CAAC0K,EAAE,EAAE,sBAAsB,CAAC;IAC7B,SAASC,EAAEA,CAAC;MAAEC,oBAAoB,EAAEpJ,CAAC;MAAEqJ,iBAAiB,EAAE/I,CAAC;MAAEgJ,uBAAuB,EAAE1I,CAAC;MAAE2I,yBAAyB,EAAE1I;IAAE,CAAC,EAAE;MACvH,OAAOkF,CAAC,CAAC;QACPM,IAAI,EAAE,iBAAiB;QACvBJ,MAAM,EAAE,eAAgBzH,CAAC,CAAC,CAACyC,CAAC,EAAEwB,CAAC,KAAKxB,CAAC,KAAK,UAAU,IAAIJ,CAAC,IAAII,CAAC,KAAK,KAAK,IAAIwB,CAAC,KAAK,GAAG,EAAE,QAAQ,CAAC;QAChGyD,WAAW,EAAE,eAAgB1H,CAAC,CAAEyC,CAAC,IAAK;UACpC,IAAIwB,CAAC,GAAGxB,CAAC,CAACoE,OAAO,CAAC,KAAK,CAAC;UACxBpE,CAAC,CAACoE,OAAO,CAAC,UAAU,CAAC;UACrB,IAAIW,CAAC,GAAG/E,CAAC,CAAC8D,KAAK,CAACzC,OAAO,CAACpC,IAAI,KAAK,GAAG;UACpC,IAAI,CAAC8F,CAAC,EAAE;YACN,IAAI,CAACpF,CAAC,EACJ,MAAM,IAAIR,KAAK,CAAC,oCAAoC,CAAC;YACvD,OAAO;cACLF,IAAI,EAAE,eAAe;cACrBvB,KAAK,EAAE;YACT,CAAC;UACH;UACA,IAAIgJ,CAAC,GAAG;cACNzH,IAAI,EAAE,mBAAmB;cACzBsJ,UAAU,EAAE,EAAE;cACdC,KAAK,EAAE,CAAC,CAAC;cACTpJ,WAAW,EAAEoC,CAAC;cACdiH,WAAW,EAAE1D;YACf,CAAC;YAAE4B,CAAC,GAAG3G,CAAC,CAACiE,qBAAqB,CAAC7B,CAAC,CAACe,QAAQ,CAAC;UAC1C,IAAIpE,CAAC,KAAK,KAAK,CAAC,EACd2H,CAAC,CAAC6B,UAAU,GAAGN,EAAE,CAACtB,CAAC,CAAC,CAAC,KAClB;YACH,IAAInF,CAAC,IAAImF,CAAC,CAAC1H,IAAI,KAAK,mBAAmB,IAAI0H,CAAC,CAAC6B,KAAK,EAChD,OAAO9B,CAAC,GAAGC,CAAC,EAAED,CAAC,CAACtH,WAAW,GAAG,CAAC,CAAC,EAAEsH,CAAC;YACrCA,CAAC,CAAC6B,UAAU,GAAGR,EAAE,CAACpB,CAAC,CAAC;YACpB,KAAK,IAAIiB,CAAC,IAAIlB,CAAC,CAAC6B,UAAU,EACxB,IAAIX,CAAC,CAAC3I,IAAI,KAAK,mBAAmB,IAAI,CAACF,CAAC,CAACwF,QAAQ,CAACqD,CAAC,CAACc,GAAG,CAAC,EACtD,MAAM,IAAIvJ,KAAK,CAAC,qCAAqCJ,CAAC,CAAC4J,IAAI,CAAC,IAAI,CAAC,YAAYf,CAAC,CAAC3I,IAAI,EAAE,CAAC;UAC5F;UACA,IAAIe,CAAC,CAACoE,OAAO,CAAC,GAAG,CAAC,EAChBsC,CAAC,CAACkC,UAAU,GAAG5I,CAAC,CAACgE,SAAS,CAAC5B,CAAC,CAACQ,MAAM,CAAC,CAAC,KAClC,IAAI,CAACvD,CAAC,EACT,MAAM,IAAIF,KAAK,CAAC,iCAAiC,CAAC;UACpD,OAAOuH,CAAC;QACV,CAAC,EAAE,aAAa;MAClB,CAAC,CAAC;IACJ;IACAnJ,CAAC,CAAC2K,EAAE,EAAE,uBAAuB,CAAC;IAC9B,SAASW,EAAEA,CAAC;MAAEC,YAAY,EAAE/J,CAAC;MAAEgK,sBAAsB,EAAE1J;IAAE,CAAC,EAAE;MAC1D,OAAOyF,CAAC,CAAC;QACPM,IAAI,EAAE,iBAAiB;QACvBJ,MAAM,EAAE,eAAgBzH,CAAC,CAAEoC,CAAC,IAAKA,CAAC,KAAK,KAAK,EAAE,QAAQ,CAAC;QACvDuF,UAAU,EAAE9C,CAAC,CAACQ,MAAM;QACpBqC,WAAW,EAAE,eAAgB1H,CAAC,CAAEoC,CAAC,IAAK;UACpCA,CAAC,CAACyE,OAAO,CAAC,KAAK,CAAC;UAChB,IAAIxE,CAAC,GAAGP,CAAC,IAAIM,CAAC,CAACyE,OAAO,CAAC,GAAG,CAAC;UAC3B,IAAI;YACF,IAAIpE,CAAC,GAAGL,CAAC,CAACqE,SAAS,CAAC5B,CAAC,CAACQ,MAAM,CAAC;YAC7B,IAAIhD,CAAC,IAAI,CAACD,CAAC,CAACyE,OAAO,CAAC,GAAG,CAAC,EACtB,MAAM,IAAIjF,KAAK,CAAC,yCAAyC,CAAC;YAC5D,OAAO;cACLF,IAAI,EAAE,mBAAmB;cACzBiD,OAAO,EAAEL,CAAC,CAAC7B,CAAC,CAAC;cACb4E,IAAI,EAAE;gBACJC,QAAQ,EAAE,QAAQ;gBAClBmE,cAAc,EAAEpJ;cAClB;YACF,CAAC;UACH,CAAC,CAAC,OAAOI,CAAC,EAAE;YACV,IAAIA,CAAC,YAAYjC,CAAC,EAAE;cAClB,IAAI6B,CAAC,EACH,MAAM,IAAIT,KAAK,CAAC,qDAAqD,CAAC;cACxE,OAAO;gBACLF,IAAI,EAAE,mBAAmB;gBACzB2F,IAAI,EAAE;kBACJC,QAAQ,EAAE,KAAK,CAAC;kBAChBmE,cAAc,EAAE,CAAC;gBACnB;cACF,CAAC;YACH,CAAC,MACC,MAAMhJ,CAAC;UACX;QACF,CAAC,EAAE,aAAa,CAAC;QACjBmF,UAAU,EAAEpG,CAAC,GAAG,CAACY,CAAC,EAAEC,CAAC,MAAMD,CAAC,CAACyE,OAAO,CAAC,KAAK,CAAC,EAAE;UAC3CnF,IAAI,EAAE,mBAAmB;UACzBiD,OAAO,EAAEL,CAAC,CAACjC,CAAC,CAAC;UACbgF,IAAI,EAAE;YACJC,QAAQ,EAAE,QAAQ;YAClBmE,cAAc,EAAE,CAAC;UACnB;QACF,CAAC,CAAC,GAAG,KAAK;MACZ,CAAC,CAAC;IACJ;IACAzL,CAAC,CAACsL,EAAE,EAAE,uBAAuB,CAAC;IAC9B,IAAII,EAAE,GAAGnE,CAAC,CAAC;QACTM,IAAI,EAAE,eAAe;QACrBJ,MAAM,EAAE,eAAgBzH,CAAC,CAAEwB,CAAC,IAAKA,CAAC,KAAK,GAAG,EAAE,QAAQ,CAAC;QACrDmG,UAAU,EAAE9C,CAAC,CAACW,MAAM;QACpBoC,UAAU,EAAE,eAAgB5H,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAK;UACtC,IAAIA,CAAC,CAACJ,IAAI,KAAK,eAAe,EAC5B,MAAM,IAAIE,KAAK,CAAC,2DAA2D,CAAC;UAC9EJ,CAAC,CAACqF,OAAO,CAAC,GAAG,CAAC;UACd,IAAIzE,CAAC,GAAG;YACNV,IAAI,EAAE,iBAAiB;YACvBvB,KAAK,EAAE2B,CAAC,CAAC3B;UACX,CAAC;UACD,IAAI,CAACqB,CAAC,CAACqF,OAAO,CAAC,GAAG,CAAC,EAAE;YACnB,IAAIxE,CAAC,GAAGb,CAAC,CAACkF,qBAAqB,CAAC7B,CAAC,CAACW,MAAM,CAAC;YACzC,IAAIpD,CAAC,CAACuC,OAAO,GAAGD,EAAE,CAACrC,CAAC,CAAC,EAAE,CAACb,CAAC,CAACqF,OAAO,CAAC,GAAG,CAAC,EACpC,MAAM,IAAIjF,KAAK,CAAC,iCAAiC,CAAC;UACtD;UACA,OAAOQ,CAAC;QACV,CAAC,EAAE,YAAY;MACjB,CAAC,CAAC;MAAEuJ,EAAE,GAAGpE,CAAC,CAAC;QACTM,IAAI,EAAE,sBAAsB;QAC5BF,UAAU,EAAE9C,CAAC,CAACiB,cAAc;QAC5B2B,MAAM,EAAE,eAAgBzH,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAKN,CAAC,KAAK,GAAG,IAAIM,CAAC,KAAK,GAAG,EAAE,QAAQ,CAAC;QACrE8F,UAAU,EAAE,eAAgB5H,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,MAAMN,CAAC,CAACqF,OAAO,CAAC,GAAG,CAAC,EAAErF,CAAC,CAACqF,OAAO,CAAC,GAAG,CAAC,EAAE;UACvEnF,IAAI,EAAE,kBAAkB;UACxBgH,IAAI,EAAE;YACJhH,IAAI,EAAE,eAAe;YACrBvB,KAAK,EAAE;UACT,CAAC;UACD+H,QAAQ,EAAE,CACR5D,CAAC,CAACxC,CAAC,CAAC,CACL;UACDuF,IAAI,EAAE;YACJsB,QAAQ,EAAE,QAAQ;YAClBC,GAAG,EAAE,CAAC;UACR;QACF,CAAC,CAAC,EAAE,YAAY;MAClB,CAAC,CAAC;IACF,SAASgD,EAAEA,CAAC;MAAEC,kBAAkB,EAAErK,CAAC;MAAEsK,aAAa,EAAEhK;IAAE,CAAC,EAAE;MACvD,OAAOyF,CAAC,CAAC;QACPM,IAAI,EAAE,eAAe;QACrBJ,MAAM,EAAE,eAAgBzH,CAAC,CAAEoC,CAAC,IAAKA,CAAC,KAAK,GAAG,EAAE,QAAQ,CAAC;QACrDsF,WAAW,EAAE,eAAgB1H,CAAC,CAAEoC,CAAC,IAAK;UACpCA,CAAC,CAACyE,OAAO,CAAC,GAAG,CAAC;UACd,IAAIxE,CAAC,GAAG;YACNX,IAAI,EAAE,iBAAiB;YACvB2F,IAAI,EAAE;cACJ0E,SAAS,EAAE;YACb,CAAC;YACD7D,QAAQ,EAAE;UACZ,CAAC;UACD,IAAI,CAAC9F,CAAC,CAACyE,OAAO,CAAC,GAAG,CAAC,EAAE;YACnB,IAAIpE,CAAC;cAAEwB,CAAC,GAAG,IAAIiD,CAAC,CAAC1F,CAAC,EAAEY,CAAC,CAACmE,KAAK,EAAEnE,CAAC,CAAC;YAC/B,SAAW;cACT6B,CAAC,CAACgD,gBAAgB,CAAC7E,CAAC,CAAC;cACrB,IAAIoF,CAAC,GAAGvD,CAAC,CAACyC,qBAAqB,CAAC7B,CAAC,CAACG,MAAM,CAAC;cACzC5C,CAAC,CAAC6E,gBAAgB,CAAChD,CAAC,CAAC,EAAEuD,CAAC,KAAK,KAAK,CAAC,IAAI1F,CAAC,KAAK0F,CAAC,GAAGpF,CAAC,CAACsE,qBAAqB,CAAC7B,CAAC,CAACG,MAAM,CAAC,CAAC;cACnF,IAAImE,CAAC,GAAG,CAAC,CAAC;cACV,IAAI3B,CAAC,CAAC9F,IAAI,KAAK,mBAAmB,KAAKyH,CAAC,GAAG,CAAC,CAAC,EAAE3B,CAAC,GAAGA,CAAC,CAAC7C,OAAO,CAAC,EAAE6C,CAAC,CAAC9F,IAAI,KAAK,iBAAiB,IAAI8F,CAAC,CAAC9F,IAAI,KAAK,eAAe,IAAI8F,CAAC,CAC9H9F,IAAI,KAAK,sBAAsB,EAAE;gBAC/B,IAAI2I,CAAC;gBACL7C,CAAC,CAAC9F,IAAI,KAAK,sBAAsB,KAAK2I,CAAC,GAAG7C,CAAC,CAACH,IAAI,CAACqC,KAAK,CAAC,EAAErH,CAAC,CAAC6F,QAAQ,CAACK,IAAI,CAAC;kBACvE7G,IAAI,EAAE,sBAAsB;kBAC5ByJ,GAAG,EAAE3D,CAAC,CAACrH,KAAK,CAACwJ,QAAQ,CAAC,CAAC;kBACvBG,KAAK,EAAE,KAAK,CAAC;kBACbkC,QAAQ,EAAE7C,CAAC;kBACX8C,QAAQ,EAAE,CAAC,CAAC;kBACZ5E,IAAI,EAAE;oBACJqC,KAAK,EAAEW;kBACT;gBACF,CAAC,CAAC;cACJ,CAAC,MAAM,IAAI7C,CAAC,CAAC9F,IAAI,KAAK,sBAAsB,IAAI8F,CAAC,CAAC9F,IAAI,KAAK,2BAA2B,EACpFW,CAAC,CAAC6F,QAAQ,CAACK,IAAI,CAACf,CAAC,CAAC,CAAC,KAEnB,MAAM,IAAI9G,CAAC,CAAC8G,CAAC,CAAC;cAChB,IAAIpF,CAAC,CAACmE,KAAK,CAACzC,OAAO,CAACK,WAAW,EAC7B1B,CAAC,GAAG,WAAW,CAAC,KACb,IAAIL,CAAC,CAACyE,OAAO,CAAC,GAAG,CAAC,EACrBpE,CAAC,GAAG,OAAO,CAAC,KACT,IAAIL,CAAC,CAACyE,OAAO,CAAC,GAAG,CAAC,EACrBpE,CAAC,GAAG,WAAW,CAAC,KAEhB;cACF,IAAIL,CAAC,CAACmE,KAAK,CAACzC,OAAO,CAACpC,IAAI,KAAK,GAAG,EAC9B;YACJ;YACA,IAAIW,CAAC,CAACgF,IAAI,CAAC0E,SAAS,GAAGtJ,CAAC,IAAI,OAAO,EAAE,CAACL,CAAC,CAACyE,OAAO,CAAC,GAAG,CAAC,EAClD,MAAM,IAAIjF,KAAK,CAAC,uCAAuC,CAAC;UAC5D;UACA,OAAOS,CAAC;QACV,CAAC,EAAE,aAAa;MAClB,CAAC,CAAC;IACJ;IACArC,CAAC,CAAC4L,EAAE,EAAE,qBAAqB,CAAC;IAC5B,SAASM,EAAEA,CAAC;MAAEC,sBAAsB,EAAE3K,CAAC;MAAEsK,aAAa,EAAEhK,CAAC;MAAEsK,aAAa,EAAEhK,CAAC;MAAEiK,aAAa,EAAEhK;IAAE,CAAC,EAAE;MAC/F,OAAOkF,CAAC,CAAC;QACPM,IAAI,EAAE,oBAAoB;QAC1BF,UAAU,EAAE9C,CAAC,CAACI,SAAS;QACvBwC,MAAM,EAAE,eAAgBzH,CAAC,CAAEyC,CAAC,IAAKA,CAAC,KAAK,GAAG,EAAE,QAAQ,CAAC;QACrDmF,UAAU,EAAE,eAAgB5H,CAAC,CAAC,CAACyC,CAAC,EAAEwB,CAAC,KAAK;UACtC,IAAIuD,CAAC;UACL,IAAI2B,CAAC,GAAG,CAAC,CAAC;YAAEC,CAAC,GAAG,CAAC,CAAC;UAClB/G,CAAC,IAAI4B,CAAC,CAACvC,IAAI,KAAK,mBAAmB,KAAKyH,CAAC,GAAG,CAAC,CAAC,EAAElF,CAAC,GAAGA,CAAC,CAACU,OAAO,CAAC,EAAEvC,CAAC,IAAI6B,CAAC,CAACvC,IAAI,KAAK,2BAA2B,KAAK0H,CAAC,GAAG,CAAC,CAAC,EAAEnF,CAAC,GAAGA,CAAC,CAACU,OAAO,CAAC;UACtI,IAAI0F,CAAC,GAAG,CAAC7C,CAAC,GAAG/E,CAAC,CAAC6D,UAAU,MAAM,IAAI,IAAIkB,CAAC,KAAK,KAAK,CAAC,GAAGA,CAAC,GAAG/E,CAAC;UAC3D,IAAI4H,CAAC,CAACpD,gBAAgB,CAACxE,CAAC,CAAC,EAAEwB,CAAC,CAACvC,IAAI,KAAK,iBAAiB,IAAIuC,CAAC,CAACvC,IAAI,KAAK,eAAe,IAAIuC,CAAC,CAACvC,IAAI,KAAK,sBAAsB,IAAIkD,EAAE,CAACX,CAAC,CAAC,EAAE;YACnI,IAAIW,EAAE,CAACX,CAAC,CAAC,IAAI,CAACzC,CAAC,EACb,MAAM,IAAId,CAAC,CAACuD,CAAC,CAAC;YAChBoG,CAAC,CAACxD,OAAO,CAAC,GAAG,CAAC;YACd,IAAIwC,CAAC;YACLpF,CAAC,CAACvC,IAAI,KAAK,sBAAsB,KAAK2H,CAAC,GAAGpF,CAAC,CAACoD,IAAI,CAACqC,KAAK,CAAC;YACvD,IAAIJ,EAAE,GAAGe,CAAC,CAAC5D,SAAS,CAAC5B,CAAC,CAACI,SAAS,CAAC;YACjC,OAAOxC,CAAC,CAACwE,gBAAgB,CAACoD,CAAC,CAAC,EAAE;cAC5B3I,IAAI,EAAE,sBAAsB;cAC5ByJ,GAAG,EAAEvG,EAAE,CAACX,CAAC,CAAC,GAAGA,CAAC,GAAGA,CAAC,CAAC9D,KAAK,CAACwJ,QAAQ,CAAC,CAAC;cACnCG,KAAK,EAAER,EAAE;cACT0C,QAAQ,EAAE7C,CAAC;cACX8C,QAAQ,EAAE7C,CAAC;cACX/B,IAAI,EAAE;gBACJqC,KAAK,EAAEL;cACT;YACF,CAAC;UACH,CAAC,MAAM;YACL,IAAI,CAACvH,CAAC,EACJ,MAAM,IAAIpB,CAAC,CAACuD,CAAC,CAAC;YAChBoG,CAAC,CAACxD,OAAO,CAAC,GAAG,CAAC;YACd,IAAIwC,CAAC,GAAGgB,CAAC,CAAC5D,SAAS,CAAC5B,CAAC,CAACI,SAAS,CAAC;YAChC,OAAOxC,CAAC,CAACwE,gBAAgB,CAACoD,CAAC,CAAC,EAAE;cAC5B3I,IAAI,EAAE,2BAA2B;cACjCgH,IAAI,EAAEpE,CAAC,CAACL,CAAC,CAAC;cACV6F,KAAK,EAAET;YACT,CAAC;UACH;QACF,CAAC,EAAE,YAAY;MACjB,CAAC,CAAC;IACJ;IACArJ,CAAC,CAACkM,EAAE,EAAE,0BAA0B,CAAC;IACjC,SAASI,EAAEA,CAAC;MAAED,aAAa,EAAE7K,CAAC;MAAE+K,aAAa,EAAEzK;IAAE,CAAC,EAAE;MAClD,OAAOyF,CAAC,CAAC;QACPM,IAAI,EAAE,iBAAiB;QACvBF,UAAU,EAAE9C,CAAC,CAACI,SAAS;QACvBwC,MAAM,EAAE,eAAgBzH,CAAC,CAAEoC,CAAC,IAAKA,CAAC,KAAK,GAAG,EAAE,QAAQ,CAAC;QACrDwF,UAAU,EAAE,eAAgB5H,CAAC,CAAC,CAACoC,CAAC,EAAEC,CAAC,KAAK;UACtC,IAAII,CAAC,GAAG,CAAC,CAAC;YAAEwB,CAAC,GAAG,CAAC,CAAC;UAClB,IAAIzC,CAAC,IAAIa,CAAC,CAACX,IAAI,KAAK,mBAAmB,KAAKe,CAAC,GAAG,CAAC,CAAC,EAAEJ,CAAC,GAAGA,CAAC,CAACsC,OAAO,CAAC,EAAE7C,CAAC,IAAIO,CAAC,CAACX,IAAI,KAAK,mBAAmB,IAAIW,CAAC,CAACsC,OAAO,KAAK,KAAK,CAAC,KAC9HV,CAAC,GAAG,CAAC,CAAC,EAAE5B,CAAC,GAAGA,CAAC,CAACsC,OAAO,CAAC,EAAEtC,CAAC,CAACX,IAAI,KAAK,eAAe,EACjD,MAAM,IAAIhB,CAAC,CAAC2B,CAAC,CAAC;UAChBD,CAAC,CAACyE,OAAO,CAAC,GAAG,CAAC;UACd,IAAIW,CAAC,GAAGpF,CAAC,CAACqE,SAAS,CAAC5B,CAAC,CAACI,SAAS,CAAC;UAChC,OAAO;YACLvD,IAAI,EAAE,mBAAmB;YACzByJ,GAAG,EAAE9I,CAAC,CAAClC,KAAK;YACZ2J,KAAK,EAAEtC,CAAC;YACRwE,QAAQ,EAAEvJ,CAAC;YACX+J,QAAQ,EAAEvI;UACZ,CAAC;QACH,CAAC,EAAE,YAAY;MACjB,CAAC,CAAC;IACJ;IACAjE,CAAC,CAACsM,EAAE,EAAE,uBAAuB,CAAC;IAC9B,IAAIG,EAAE,GAAG,CACP,GAAG3D,EAAE,EACL6B,EAAE,CAAC;QACDG,uBAAuB,EAAE,CAAC,CAAC;QAC3BF,oBAAoB,EAAE,CAAC,MAAM,EAAE,KAAK,CAAC;QACrCC,iBAAiB,EAAE,CAAC,CAAC;QACrBE,yBAAyB,EAAE,CAAC;MAC9B,CAAC,CAAC,EACFb,CAAC,EACDC,EAAE,CAAC;QACDC,YAAY,EAAE,CAAC,QAAQ,EAAE,UAAU,EAAE,OAAO,CAAC;QAC7ClB,WAAW,EAAEqB;MACf,CAAC,CAAC,EACFe,EAAE,CAAC;QACDE,sBAAsB,EAAE,CAAC,CAAC;QAC1BD,YAAY,EAAE,CAAC;MACjB,CAAC,CAAC,EACFvB,CAAC,CAAC;QACAC,uBAAuB,EAAE,CAAC,OAAO;MACnC,CAAC,CAAC,EACFyB,EAAE,EACFC,EAAE,EACF5C,EAAE,CAAC;QACDC,4BAA4B,EAAE,CAAC,CAAC;QAChCC,mBAAmB,EAAE,CAAC,CAAC;QACvBC,WAAW,EAAEqB;MACf,CAAC,CAAC,CACH;MAAEmC,EAAE,GAAG,CACN,GAAGD,EAAE,EACLb,EAAE,CAAC;QACD;QACA;QACAC,kBAAkB,EAAE,CAClB7B,CAAC,CAAC;UACAC,uBAAuB,EAAE,CAAC,QAAQ,EAAE,IAAI;QAC1C,CAAC,CAAC,EACFiC,EAAE,CAAC;UACDC,sBAAsB,EAAE,CAAC,CAAC;UAC1BL,aAAa,EAAE,CAAC,CAAC;UACjBO,aAAa,EAAE,CAAC,CAAC;UACjBD,aAAa,EAAE,CAAC;QAClB,CAAC,CAAC,EACF,GAAGK,EAAE,CACN;QACDX,aAAa,EAAE,CAAC;MAClB,CAAC,CAAC,EACFQ,EAAE,CAAC;QACDD,aAAa,EAAE,CAAC,CAAC;QACjBE,aAAa,EAAE,CAAC;MAClB,CAAC,CAAC,CACH;MAAEI,EAAE,GAAGpF,CAAC,CAAC;QACRM,IAAI,EAAE,eAAe;QACrBJ,MAAM,EAAE,eAAgBzH,CAAC,CAAEwB,CAAC,IAAKA,CAAC,KAAK,QAAQ,EAAE,QAAQ,CAAC;QAC1DkG,WAAW,EAAE,eAAgB1H,CAAC,CAAEwB,CAAC,KAAMA,CAAC,CAACqF,OAAO,CAAC,QAAQ,CAAC,EAAE;UAC1DnF,IAAI,EAAE,iBAAiB;UACvBiD,OAAO,EAAEL,CAAC,CAAC9C,CAAC,CAACiF,SAAS,CAAC5B,CAAC,CAACc,cAAc,CAAC;QAC1C,CAAC,CAAC,EAAE,aAAa;MACnB,CAAC,CAAC;MAAEiH,EAAE,GAAG,CACP5C,CAAC,CAAC;QACAC,uBAAuB,EAAE,CAAC,QAAQ,EAAE,OAAO,EAAE,OAAO,EAAE,UAAU,EAAE,IAAI;MACxE,CAAC,CAAC,EACF7C,EAAE,EACFU,CAAC,EACDoC,CAAC,EACDnC,CAAC,EACDmE,EAAE,CAAC;QACDC,sBAAsB,EAAE,CAAC,CAAC;QAC1BL,aAAa,EAAE,CAAC,CAAC;QACjBO,aAAa,EAAE,CAAC,CAAC;QACjBD,aAAa,EAAE,CAAC;MAClB,CAAC,CAAC,CACH;MAAES,EAAE,GAAG,CACN,GAAG/D,EAAE,EACL8C,EAAE,CAAC;QACDE,aAAa,EAAE,CAAC,CAAC;QACjBD,kBAAkB,EAAEe;MACtB,CAAC,CAAC,EACF5C,CAAC,CAAC;QACAC,uBAAuB,EAAE,CAAC,OAAO,EAAE,UAAU,EAAE,IAAI;MACrD,CAAC,CAAC,EACF0C,EAAE,EACFhC,EAAE,CAAC;QACDG,uBAAuB,EAAE,CAAC,CAAC;QAC3BF,oBAAoB,EAAE,CAAC,MAAM,EAAE,KAAK,CAAC;QACrCC,iBAAiB,EAAE,CAAC,CAAC;QACrBE,yBAAyB,EAAE,CAAC;MAC9B,CAAC,CAAC,EACFO,EAAE,CAAC;QACDE,sBAAsB,EAAE,CAAC,CAAC;QAC1BD,YAAY,EAAE,CAAC;MACjB,CAAC,CAAC;MACF;MACAvB,CAAC,CAAC;QACAC,uBAAuB,EAAE,CAAC,OAAO;MACnC,CAAC,CAAC,EACFE,EAAE,CAAC;QACDC,YAAY,EAAE,CAAC,QAAQ,CAAC;QACxBlB,WAAW,EAAEqB;MACf,CAAC,CAAC,EACFxB,EAAE,CAAC;QACDC,4BAA4B,EAAE,CAAC,CAAC;QAChCC,mBAAmB,EAAE,CAAC,CAAC;QACvBC,WAAW,EAAEqB;MACf,CAAC,CAAC,EACF+B,EAAE,CAAC;QACDD,aAAa,EAAE,CAAC,CAAC;QACjBE,aAAa,EAAE,CAAC;MAClB,CAAC,CAAC,EACFb,EAAE,CACH;MAAEoB,EAAE,GAAGvF,CAAC,CAAC;QACRM,IAAI,EAAE,gBAAgB;QACtBJ,MAAM,EAAE,eAAgBzH,CAAC,CAAEwB,CAAC,IAAKA,CAAC,KAAK,SAAS,EAAE,QAAQ,CAAC;QAC3DkG,WAAW,EAAE,eAAgB1H,CAAC,CAAEwB,CAAC,IAAK;UACpCA,CAAC,CAACqF,OAAO,CAAC,SAAS,CAAC;UACpB,IAAI/E,CAAC,GAAGN,CAAC,CAACkF,qBAAqB,CAAC7B,CAAC,CAACW,MAAM,CAAC;UACzC,IAAI1D,CAAC,CAACJ,IAAI,KAAK,eAAe,EAC5B,MAAM,IAAIhB,CAAC,CAACoB,CAAC,EAAE,kEAAkE,CAAC;UACpF,OAAON,CAAC,CAACqF,OAAO,CAAC,IAAI,CAAC,EAAE;YACtBnF,IAAI,EAAE,kBAAkB;YACxBgH,IAAI,EAAE5G,CAAC;YACPgI,KAAK,EAAExF,CAAC,CAAC9C,CAAC,CAACkF,qBAAqB,CAAC7B,CAAC,CAACS,KAAK,CAAC;UAC3C,CAAC;QACH,CAAC,EAAE,aAAa;MAClB,CAAC,CAAC;IACF,SAASyH,EAAEA,CAAC;MAAEC,iBAAiB,EAAExL;IAAE,CAAC,EAAE;MACpC,OAAO+F,CAAC,CAAC;QACPM,IAAI,EAAE,cAAc;QACpBJ,MAAM,EAAE,eAAgBzH,CAAC,CAAE8B,CAAC,IAAKA,CAAC,KAAK,GAAG,EAAE,QAAQ,CAAC;QACrD4F,WAAW,EAAE,eAAgB1H,CAAC,CAAE8B,CAAC,IAAK;UACpCA,CAAC,CAAC+E,OAAO,CAAC,GAAG,CAAC;UACd,IAAIzE,CAAC,GAAG;YACNV,IAAI,EAAE,gBAAgB;YACtBwG,QAAQ,EAAE;UACZ,CAAC;UACD,IAAIpG,CAAC,CAAC+E,OAAO,CAAC,GAAG,CAAC,EAChB,OAAOzE,CAAC;UACV,IAAIC,CAAC,GAAGP,CAAC,CAAC4E,qBAAqB,CAAC7B,CAAC,CAACC,GAAG,CAAC;UACtC,IAAIzC,CAAC,CAACX,IAAI,KAAK,wBAAwB,GAAGW,CAAC,CAAC6F,QAAQ,CAAC,CAAC,CAAC,CAACxG,IAAI,KAAK,mBAAmB,GAAGU,CAAC,CAAC8F,QAAQ,GAAG7F,CAAC,CAAC6F,QAAQ,CAACuC,GAAG,CAACjG,CAAC,CAAC,GAAGpC,CAAC,CAAC8F,QAAQ,GAClI7F,CAAC,CAAC6F,QAAQ,CAACuC,GAAG,CAACnG,CAAC,CAAC,GAAGjC,CAAC,CAACX,IAAI,KAAK,mBAAmB,GAAGU,CAAC,CAAC8F,QAAQ,GAAG,CAAC1D,CAAC,CAACnC,CAAC,CAAC,CAAC,GAAGD,CAAC,CAAC8F,QAAQ,GAAG,CAAC5D,CAAC,CAACjC,CAAC,CAAC,CAAC,EAAE,CAACP,CAAC,CAAC+E,OAAO,CAAC,GAAG,CAAC,EAC7G,MAAM,IAAIjF,KAAK,CAAC,kBAAkB,CAAC;UACrC,IAAI,CAACJ,CAAC,IAAIY,CAAC,CAAC8F,QAAQ,CAACM,IAAI,CAAE/F,CAAC,IAAKA,CAAC,CAACf,IAAI,KAAK,kBAAkB,CAAC,EAC7D,MAAM,IAAIE,KAAK,CAAC,oCAAoC,CAAC;UACvD,OAAOQ,CAAC;QACV,CAAC,EAAE,aAAa;MAClB,CAAC,CAAC;IACJ;IACApC,CAAC,CAAC+M,EAAE,EAAE,oBAAoB,CAAC;IAC3B,IAAIE,EAAE,GAAG1F,CAAC,CAAC;QACTM,IAAI,EAAE,cAAc;QACpBJ,MAAM,EAAE,eAAgBzH,CAAC,CAAEwB,CAAC,IAAKA,CAAC,KAAK,OAAO,EAAE,QAAQ,CAAC;QACzDkG,WAAW,EAAE,eAAgB1H,CAAC,CAAEwB,CAAC,KAAMA,CAAC,CAACqF,OAAO,CAAC,OAAO,CAAC,EAAE;UACzDnF,IAAI,EAAE,gBAAgB;UACtBiD,OAAO,EAAEL,CAAC,CAAC9C,CAAC,CAACiF,SAAS,CAAC5B,CAAC,CAACc,cAAc,CAAC;QAC1C,CAAC,CAAC,EAAE,aAAa;MACnB,CAAC,CAAC;MAAEuH,EAAE,GAAG3F,CAAC,CAAC;QACTM,IAAI,EAAE,eAAe;QACrBJ,MAAM,EAAE,eAAgBzH,CAAC,CAAEwB,CAAC,IAAKA,CAAC,KAAK,QAAQ,EAAE,QAAQ,CAAC;QAC1DkG,WAAW,EAAE,eAAgB1H,CAAC,CAAEwB,CAAC,IAAK;UACpC,IAAIA,CAAC,CAACqF,OAAO,CAAC,QAAQ,CAAC,EAAE,CAACrF,CAAC,CAACqF,OAAO,CAAC,GAAG,CAAC,EACtC,MAAM,IAAIjF,KAAK,CAAC,0CAA0C,CAAC;UAC7D,IAAIE,CAAC,GAAGN,CAAC,CAACiF,SAAS,CAAC5B,CAAC,CAACQ,MAAM,CAAC;UAC7B,IAAIvD,CAAC,CAACJ,IAAI,KAAK,sBAAsB,EACnC,MAAM,IAAIE,KAAK,CAAC,qDAAqD,CAAC;UACxE,IAAI,CAACJ,CAAC,CAACqF,OAAO,CAAC,GAAG,CAAC,EACjB,MAAM,IAAIjF,KAAK,CAAC,kDAAkD,CAAC;UACrE,OAAO;YACLF,IAAI,EAAE,iBAAiB;YACvBiD,OAAO,EAAE7C;UACX,CAAC;QACH,CAAC,EAAE,aAAa;MAClB,CAAC,CAAC;MAAEqL,EAAE,GAAG5F,CAAC,CAAC;QACTM,IAAI,EAAE,yBAAyB;QAC/BJ,MAAM,EAAE,eAAgBzH,CAAC,CAAEwB,CAAC,IAAKA,CAAC,KAAK,UAAU,EAAE,QAAQ,CAAC;QAC5DkG,WAAW,EAAE,eAAgB1H,CAAC,CAAEwB,CAAC,KAAMA,CAAC,CAACqF,OAAO,CAAC,UAAU,CAAC,EAAE;UAC5DnF,IAAI,EAAE,2BAA2B;UACjCiD,OAAO,EAAEnD,CAAC,CAACiF,SAAS,CAAC5B,CAAC,CAACI,SAAS;QAClC,CAAC,CAAC,EAAE,aAAa;MACnB,CAAC,CAAC;MAAEmI,EAAE,GAAG7F,CAAC,CAAC;QACTM,IAAI,EAAE,sBAAsB;QAC5BF,UAAU,EAAE9C,CAAC,CAACgB,KAAK;QACnB4B,MAAM,EAAE,eAAgBzH,CAAC,CAAEwB,CAAC,IAAKA,CAAC,KAAK,IAAI,EAAE,QAAQ,CAAC;QACtDoG,UAAU,EAAE,eAAgB5H,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,MAAMN,CAAC,CAACqF,OAAO,CAAC,IAAI,CAAC,EAAE;UACxDnF,IAAI,EAAE,mBAAmB;UACzBsJ,UAAU,EAAER,EAAE,CAAC1I,CAAC,CAAC,CAAC2I,GAAG,CAAChG,EAAE,CAAC;UACzBwG,KAAK,EAAE,CAAC,CAAC;UACTpJ,WAAW,EAAE,CAAC,CAAC;UACfqJ,WAAW,EAAE,CAAC,CAAC;UACfG,UAAU,EAAE7J,CAAC,CAACiF,SAAS,CAAC5B,CAAC,CAACG,MAAM;QAClC,CAAC,CAAC,EAAE,YAAY;MAClB,CAAC,CAAC;MAAEqI,EAAE,GAAG9F,CAAC,CAAC;QACTM,IAAI,EAAE,qBAAqB;QAC3BJ,MAAM,EAAE,eAAgBzH,CAAC,CAAEwB,CAAC,IAAKA,CAAC,KAAK,GAAG,EAAE,QAAQ,CAAC;QACrDmG,UAAU,EAAE9C,CAAC,CAACO,YAAY;QAC1BwC,UAAU,EAAE,eAAgB5H,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAK;UACtCN,CAAC,CAACqF,OAAO,CAAC,GAAG,CAAC;UACd,IAAIzE,CAAC,GAAG,EAAE;UACV,GACEA,CAAC,CAACmG,IAAI,CAAC/G,CAAC,CAACiF,SAAS,CAAC5B,CAAC,CAACO,YAAY,CAAC,CAAC,CAAC,QAC/B5D,CAAC,CAACqF,OAAO,CAAC,GAAG,CAAC;UACrB,OAAO;YACLnF,IAAI,EAAE,uBAAuB;YAC7BwG,QAAQ,EAAE,CAAC5D,CAAC,CAACxC,CAAC,CAAC,EAAE,GAAGM,CAAC;UACvB,CAAC;QACH,CAAC,EAAE,YAAY;MACjB,CAAC,CAAC;MAAEkL,EAAE,GAAG/F,CAAC,CAAC;QACTM,IAAI,EAAE,kBAAkB;QACxBF,UAAU,EAAE9C,CAAC,CAACS,KAAK;QACnBmC,MAAM,EAAE,eAAgBzH,CAAC,CAAEwB,CAAC,IAAKA,CAAC,KAAK,IAAI,EAAE,QAAQ,CAAC;QACtDoG,UAAU,EAAE,eAAgB5H,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAK;UACtC,IAAIA,CAAC,CAACJ,IAAI,KAAK,eAAe,EAC5B,MAAM,IAAIhB,CAAC,CAACoB,CAAC,EAAE,oEAAoE,CAAC;UACtF,OAAON,CAAC,CAACqF,OAAO,CAAC,IAAI,CAAC,EAAE;YACtBnF,IAAI,EAAE,oBAAoB;YAC1BgH,IAAI,EAAE5G,CAAC;YACPgI,KAAK,EAAExF,CAAC,CAAC9C,CAAC,CAACkF,qBAAqB,CAAC7B,CAAC,CAACS,KAAK,CAAC;UAC3C,CAAC;QACH,CAAC,EAAE,YAAY;MACjB,CAAC,CAAC;MAAEiI,EAAE,GAAGhG,CAAC,CAAC;QACTM,IAAI,EAAE,oCAAoC;QAC1CJ,MAAM,EAAE,eAAgBzH,CAAC,CAAEwB,CAAC,IAAKA,CAAC,KAAK,GAAG,EAAE,QAAQ,CAAC;QACrDkG,WAAW,EAAE,eAAgB1H,CAAC,CAAEwB,CAAC,IAAK;UACpC,IAAIA,CAAC,CAAC8E,UAAU,KAAK,KAAK,CAAC,EACzB,MAAM,IAAI1E,KAAK,CAAC,oCAAoC,CAAC;UACvDJ,CAAC,CAACqF,OAAO,CAAC,GAAG,CAAC;UACd,IAAI/E,CAAC,GAAGN,CAAC,CAAC+E,KAAK,CAACzC,OAAO,CAACrC,IAAI;UAC5BD,CAAC,CAACqF,OAAO,CAAC,YAAY,CAAC;UACvB,IAAIzE,CAAC;UACL,IAAIZ,CAAC,CAACqF,OAAO,CAAC,GAAG,CAAC,EAAE;YAClB,IAAIxE,CAAC,GAAGb,CAAC,CAAC8E,UAAU;YACpBjE,CAAC,CAAC4E,gBAAgB,CAACzF,CAAC,CAAC,EAAEY,CAAC,GAAG;cACzBV,IAAI,EAAE,yBAAyB;cAC/ByJ,GAAG,EAAErJ,CAAC;cACNgI,KAAK,EAAEzH,CAAC,CAACoE,SAAS,CAAC5B,CAAC,CAACK,cAAc;YACrC,CAAC,EAAE1D,CAAC,CAACyF,gBAAgB,CAAC5E,CAAC,CAAC;UAC1B,CAAC,MAAM,IAAIb,CAAC,CAACqF,OAAO,CAAC,IAAI,CAAC,EAAE;YAC1B,IAAIxE,CAAC,GAAGb,CAAC,CAAC8E,UAAU;YACpBjE,CAAC,CAAC4E,gBAAgB,CAACzF,CAAC,CAAC,EAAEY,CAAC,GAAG;cACzBV,IAAI,EAAE,qBAAqB;cAC3ByJ,GAAG,EAAErJ,CAAC;cACNgI,KAAK,EAAEzH,CAAC,CAACoE,SAAS,CAAC5B,CAAC,CAACiB,cAAc;YACrC,CAAC,EAAEtE,CAAC,CAACyF,gBAAgB,CAAC5E,CAAC,CAAC;UAC1B,CAAC,MACC,MAAM,IAAIT,KAAK,CAAC,uDAAuD,CAAC;UAC1E,IAAI,CAACJ,CAAC,CAACqF,OAAO,CAAC,GAAG,CAAC,EACjB,MAAM,IAAIjF,KAAK,CAAC,8BAA8B,CAAC;UACjD,OAAOQ,CAAC;QACV,CAAC,EAAE,aAAa;MAClB,CAAC,CAAC;MAAEoL,EAAE,GAAG,CACPL,EAAE,EACFnD,CAAC,CAAC;QACAC,uBAAuB,EAAE,CAAC,QAAQ,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,UAAU,EAAE,IAAI;MACjF,CAAC,CAAC,EACF7C,EAAE,EACFU,CAAC,EACDoC,CAAC,EACDnC,CAAC,EACDmE,EAAE,CAAC;QACDC,sBAAsB,EAAE,CAAC,CAAC;QAC1BL,aAAa,EAAE,CAAC,CAAC;QACjBO,aAAa,EAAE,CAAC,CAAC;QACjBD,aAAa,EAAE,CAAC;MAClB,CAAC,CAAC,EACFmB,EAAE,CACH;MAAEE,EAAE,GAAG,CACN,GAAG3E,EAAE,EACL8C,EAAE,CAAC;QACDE,aAAa,EAAE,CAAC,CAAC;QACjBD,kBAAkB,EAAE2B;MACtB,CAAC,CAAC,EACFb,EAAE,EACFM,EAAE,EACFC,EAAE,EACFhD,CAAC,EACDS,EAAE,CAAC;QACDG,uBAAuB,EAAE,CAAC,CAAC;QAC3BD,iBAAiB,EAAE,CAAC,CAAC;QACrBD,oBAAoB,EAAE,CAAC,MAAM,EAAE,KAAK,EAAE,MAAM,CAAC;QAC7CG,yBAAyB,EAAE,CAAC;MAC9B,CAAC,CAAC,EACFgC,EAAE,CAAC;QACDC,iBAAiB,EAAE,CAAC;MACtB,CAAC,CAAC,EACF1B,EAAE,CAAC;QACDE,sBAAsB,EAAE,CAAC,CAAC;QAC1BD,YAAY,EAAE,CAAC;MACjB,CAAC,CAAC,EACFuB,EAAE,EACF9C,CAAC,CAAC;QACAC,uBAAuB,EAAE,CAAC,OAAO,EAAE,UAAU,EAAE,IAAI;MACrD,CAAC,CAAC,EACFE,EAAE,CAAC;QACDC,YAAY,EAAE,CAAC,QAAQ,CAAC;QACxBlB,WAAW,EAAEqB;MACf,CAAC,CAAC,EACFoB,EAAE,EACFyB,EAAE,EACFrE,EAAE,CAAC;QACDC,4BAA4B,EAAE,CAAC,CAAC;QAChCC,mBAAmB,EAAE,CAAC,CAAC;QACvBC,WAAW,EAAEqB;MACf,CAAC,CAAC,EACF8C,EAAE,EACFC,EAAE,EACFhB,EAAE,CAAC;QACDC,aAAa,EAAE,CAAC,CAAC;QACjBF,aAAa,EAAE,CAAC;MAClB,CAAC,CAAC,CACH;IACD,SAASqB,EAAEA,CAAClM,CAAC,EAAEM,CAAC,EAAE;MAChB,QAAQA,CAAC;QACP,KAAK,SAAS;UACZ,OAAO,IAAIoF,CAAC,CAAC2F,EAAE,EAAErL,CAAC,CAAC,CAACgF,KAAK,CAAC,CAAC;QAC7B,KAAK,OAAO;UACV,OAAO,IAAIU,CAAC,CAACwF,EAAE,EAAElL,CAAC,CAAC,CAACgF,KAAK,CAAC,CAAC;QAC7B,KAAK,YAAY;UACf,OAAO,IAAIU,CAAC,CAACuG,EAAE,EAAEjM,CAAC,CAAC,CAACgF,KAAK,CAAC,CAAC;MAC/B;IACF;IACAxG,CAAC,CAAC0N,EAAE,EAAE,OAAO,CAAC;IACd,SAASC,EAAEA,CAACnM,CAAC,EAAEM,CAAC,GAAG,CAAC,YAAY,EAAE,SAAS,EAAE,OAAO,CAAC,EAAE;MACrD,IAAIM,CAAC;MACL,KAAK,IAAIC,CAAC,IAAIP,CAAC,EACb,IAAI;QACF,OAAO4L,EAAE,CAAClM,CAAC,EAAEa,CAAC,CAAC;MACjB,CAAC,CAAC,OAAOI,CAAC,EAAE;QACVL,CAAC,GAAGK,CAAC;MACP;MACF,MAAML,CAAC;IACT;IACApC,CAAC,CAAC2N,EAAE,EAAE,UAAU,CAAC;IACjB,SAASC,CAACA,CAACpM,CAAC,EAAEM,CAAC,EAAE;MACf,IAAIM,CAAC,GAAGZ,CAAC,CAACM,CAAC,CAACJ,IAAI,CAAC;MACjB,IAAIU,CAAC,KAAK,KAAK,CAAC,EACd,MAAM,IAAIR,KAAK,CAAC,0DAA0DE,CAAC,CAACJ,IAAI,GAAG,CAAC;MACtF,OAAOU,CAAC,CAACN,CAAC,EAAGO,CAAC,IAAKuL,CAAC,CAACpM,CAAC,EAAEa,CAAC,CAAC,CAAC;IAC7B;IACArC,CAAC,CAAC4N,CAAC,EAAE,WAAW,CAAC;IACjB,SAASC,CAACA,CAACrM,CAAC,EAAE;MACZ,MAAM,IAAII,KAAK,CAAC,2EAA2E,CAAC;IAC9F;IACA5B,CAAC,CAAC6N,CAAC,EAAE,uBAAuB,CAAC;IAC7B,SAASC,EAAEA,CAACtM,CAAC,EAAE;MACb,IAAIM,CAAC,GAAG;QACNiM,MAAM,EAAE;MACV,CAAC;MACD,KAAK,IAAI3L,CAAC,IAAIZ,CAAC,CAACwJ,UAAU,EACxB5I,CAAC,CAACV,IAAI,KAAK,mBAAmB,GAAGU,CAAC,CAAC+I,GAAG,KAAK,MAAM,GAAGrJ,CAAC,CAACkM,IAAI,GAAG5L,CAAC,CAAC0H,KAAK,GAAG1H,CAAC,CAAC+I,GAAG,KAAK,KAAK,GAAGrJ,CAAC,CAACmM,GAAG,GAAG7L,CAAC,CAAC0H,KAAK,GAAGhI,CAAC,CAACiM,MAAM,CAACxF,IAAI,CAACnG,CAAC,CAAC,GAAGN,CAAC,CAACiM,MAAM,CACtIxF,IAAI,CAACnG,CAAC,CAAC;MACT,OAAON,CAAC;IACV;IACA9B,CAAC,CAAC8N,EAAE,EAAE,sBAAsB,CAAC;IAC7B,SAASI,EAAEA,CAAC1M,CAAC,EAAEM,CAAC,EAAEM,CAAC,EAAE;MACnB,OAAOZ,CAAC,KAAK,QAAQ,GAAGY,CAAC,GAAGN,CAAC,GAAGA,CAAC,GAAGM,CAAC;IACvC;IACApC,CAAC,CAACkO,EAAE,EAAE,eAAe,CAAC;IACtB,SAASC,CAACA,CAAC3M,CAAC,EAAEM,CAAC,EAAE;MACf,QAAQA,CAAC;QACP,KAAK,QAAQ;UACX,OAAO,IAAIN,CAAC,GAAG;QACjB,KAAK,QAAQ;UACX,OAAO,IAAIA,CAAC,GAAG;QACjB,KAAK,KAAK,CAAC;UACT,OAAOA,CAAC;MACZ;IACF;IACAxB,CAAC,CAACmO,CAAC,EAAE,OAAO,CAAC;IACb,SAASC,EAAEA,CAAA,EAAG;MACZ,OAAO;QACLC,oBAAoB,EAAE,eAAgBrO,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAK,IAAIN,CAAC,CAACmD,OAAO,KAAK,KAAK,CAAC,GAAG7C,CAAC,CAACN,CAAC,CAACmD,OAAO,CAAC,GAAG,EAAE,GAAG,EAAE,sBAAsB,CAAC;QAC1H2J,cAAc,EAAE,eAAgBtO,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAK,SAASA,CAAC,CAACN,CAAC,CAACmD,OAAO,CAAC,EAAE,EAAE,gBAAgB,CAAC;QACtF4J,iBAAiB,EAAE,eAAgBvO,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAK;UAC7C,IAAIN,CAAC,CAACyJ,KAAK,EAAE;YACX,IAAIzJ,CAAC,CAAC6J,UAAU,KAAK,KAAK,CAAC,EACzB,MAAM,IAAIzJ,KAAK,CAAC,qCAAqC,CAAC;YACxD,IAAIQ,CAAC,GAAG,IAAIZ,CAAC,CAACwJ,UAAU,CAACP,GAAG,CAAC3I,CAAC,CAAC,CAACsJ,IAAI,CAAC,IAAI,CAAC,QAAQtJ,CAAC,CAACN,CAAC,CAAC6J,UAAU,CAAC,EAAE;YACnE,OAAO7J,CAAC,CAACK,WAAW,KAAKO,CAAC,GAAG,MAAM,GAAGA,CAAC,CAAC,EAAEA,CAAC;UAC7C,CAAC,MAAM;YACL,IAAIA,CAAC,GAAGZ,CAAC,CAACK,WAAW,GAAG,KAAK,GAAG,UAAU;YAC1C,OAAOL,CAAC,CAAC0J,WAAW,KAAK9I,CAAC,IAAI,IAAIZ,CAAC,CAACwJ,UAAU,CAACP,GAAG,CAAC3I,CAAC,CAAC,CAACsJ,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE5J,CAAC,CAAC6J,UAAU,KAAK,KAAK,CAAC,KAAKjJ,CAAC,IAAI,KAAKN,CAAC,CAACN,CAAC,CAAC6J,UAAU,CAAC,EAAE,CAAC,CAAC,EAAEjJ,CAAC;UACnI;QACF,CAAC,EAAE,mBAAmB,CAAC;QACvBoM,aAAa,EAAE,eAAgBxO,CAAC,CAAEwB,CAAC,IAAKA,CAAC,CAACrB,KAAK,EAAE,eAAe,CAAC;QACjEsO,cAAc,EAAE,eAAgBzO,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAK,IAAIN,CAAC,CAAC0G,QAAQ,CAACuC,GAAG,CAAC3I,CAAC,CAAC,CAACsJ,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,gBAAgB,CAAC;QAClGsD,iBAAiB,EAAE,eAAgB1O,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAKN,CAAC,CAAC6F,IAAI,CAACC,QAAQ,KAAK,KAAK,CAAC,GAAG,KAAK,GAAG4G,EAAE,CAAC1M,CAAC,CAAC6F,IAAI,CAACC,QAAQ,EAAExF,CAAC,CAACN,CAAC,CAACmD,OAAO,CAAC,EAAE,KAAK,CAAC,EAAE;AACtI,aAAa,CAAC;QACNgK,iBAAiB,EAAE,eAAgB3O,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAK;UAC7C,IAAIM,CAAC,GAAGN,CAAC,CAACN,CAAC,CAACkH,IAAI,CAAC;YAAErG,CAAC,GAAGP,CAAC,CAACN,CAAC,CAACsI,KAAK,CAAC;UACjC,QAAQtI,CAAC,CAACuI,QAAQ;YAChB,KAAK,OAAO;cACV,OAAO,GAAG3H,CAAC,IAAIC,CAAC,EAAE;YACpB,KAAK,UAAU;cACb,OAAO,GAAGD,CAAC,IAAIC,CAAC,EAAE;YACpB,KAAK,UAAU;cACb,OAAO,GAAGD,CAAC,IAAIC,CAAC,EAAE;YACpB,KAAK,mBAAmB;cACtB,OAAO,GAAGD,CAAC,IAAIC,CAAC,GAAG;UACvB;QACF,CAAC,EAAE,mBAAmB,CAAC;QACvBuM,oBAAoB,EAAE,eAAgB5O,CAAC,CAAEwB,CAAC,IAAK2M,CAAC,CAAC3M,CAAC,CAACrB,KAAK,EAAEqB,CAAC,CAAC6F,IAAI,CAACqC,KAAK,CAAC,EAAE,sBAAsB,CAAC;QAChGmF,YAAY,EAAE,eAAgB7O,CAAC,CAAC,MAAM,GAAG,EAAE,cAAc,CAAC;QAC1D8O,gBAAgB,EAAE,eAAgB9O,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAK;UAC5C,IAAIN,CAAC,CAAC6F,IAAI,CAACsB,QAAQ,KAAK,QAAQ,EAAE;YAChC,IAAIvG,CAAC,GAAGZ,CAAC,CAAC0G,QAAQ,CAAC,CAAC,CAAC;cAAE7F,CAAC,GAAGP,CAAC,CAACM,CAAC,CAAC;YAC/B,OAAOA,CAAC,CAACV,IAAI,KAAK,gBAAgB,IAAIU,CAAC,CAACV,IAAI,KAAK,uBAAuB,GAAG,IAAIW,CAAC,KAAK,GAAG,GAAGA,CAAC,IAAI;UAClG,CAAC,MACC,OAAO,GAAGP,CAAC,CAACN,CAAC,CAACkH,IAAI,CAAC,GAAGlH,CAAC,CAAC6F,IAAI,CAACuB,GAAG,GAAG,GAAG,GAAG,EAAE,IAAIpH,CAAC,CAAC0G,QAAQ,CAACuC,GAAG,CAAC3I,CAAC,CAAC,CAACsJ,IAAI,CAAC,IAAI,CAAC,GAAG;QAClF,CAAC,EAAE,kBAAkB,CAAC;QACtB2D,eAAe,EAAE,eAAgB/O,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAK,UAAUA,CAAC,CAACN,CAAC,CAACmD,OAAO,CAAC,GAAG,EAAE,iBAAiB,CAAC;QAC1FqK,oBAAoB,EAAE,eAAgBhP,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAK;UAChD,IAAIM,CAAC,GAAG,EAAE;UACV,OAAOZ,CAAC,CAACyK,QAAQ,KAAK7J,CAAC,IAAI,WAAW,CAAC,EAAE,OAAOZ,CAAC,CAAC2J,GAAG,IAAI,QAAQ,GAAG/I,CAAC,IAAI+L,CAAC,CAAC3M,CAAC,CAAC2J,GAAG,EAAE3J,CAAC,CAAC6F,IAAI,CAACqC,KAAK,CAAC,GAAGtH,CAAC,IAAIN,CAAC,CAACN,CAAC,CAAC2J,GAAG,CAAC,EAAE3J,CAAC,CAACwK,QAAQ,KAAK5J,CAAC,IACjI,GAAG,CAAC,EAAEZ,CAAC,CAACsI,KAAK,KAAK,KAAK,CAAC,GAAG1H,CAAC,GAAGA,CAAC,GAAG,KAAKN,CAAC,CAACN,CAAC,CAACsI,KAAK,CAAC,EAAE;QACtD,CAAC,EAAE,sBAAsB,CAAC;QAC1BmF,yBAAyB,EAAE,eAAgBjP,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAK,GAAGA,CAAC,CAACN,CAAC,CAACkH,IAAI,CAAC,KAAK5G,CAAC,CAACN,CAAC,CAACsI,KAAK,CAAC,EAAE,EAAE,2BAA2B,CAAC;QAClHoF,iBAAiB,EAAE,eAAgBlP,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAK;UAC7C,IAAIM,CAAC,GAAGZ,CAAC,CAAC2J,GAAG;UACb,OAAO3J,CAAC,CAACwK,QAAQ,KAAK5J,CAAC,IAAI,GAAG,CAAC,EAAEZ,CAAC,CAACgL,QAAQ,KAAKpK,CAAC,GAAG,KAAK,GAAGA,CAAC,CAAC,EAAEZ,CAAC,CAACsI,KAAK,KAAK,KAAK,CAAC,GAAG1H,CAAC,GAAGA,CAAC,GAAG,KAAKN,CAAC,CAACN,CAAC,CAACsI,KAAK,CAAC,EAAE;QAChH,CAAC,EAAE,mBAAmB,CAAC;QACvBqF,wBAAwB,EAAE,eAAgBnP,CAAC,CAAEwB,CAAC,IAAK,GAAGA,CAAC,CAACoI,WAAW,IAAIuE,CAAC,CAAC3M,CAAC,CAACrB,KAAK,EAAEqB,CAAC,CAAC6F,IAAI,CAACqC,KAAK,CAAC,EAAE,EAAE,0BAA0B,CAAC;QAC9H0F,oBAAoB,EAAE,eAAgBpP,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAKoM,EAAE,CAAC1M,CAAC,CAAC6F,IAAI,CAACC,QAAQ,EAAExF,CAAC,CAACN,CAAC,CAACmD,OAAO,CAAC,EAAE,GAAG,CAAC,EAAE,sBAAsB,CAAC;QACjH0K,aAAa,EAAE,eAAgBrP,CAAC,CAAC,MAAM,MAAM,EAAE,eAAe,CAAC;QAC/DsP,iBAAiB,EAAE,eAAgBtP,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAKoM,EAAE,CAAC1M,CAAC,CAAC6F,IAAI,CAACC,QAAQ,EAAExF,CAAC,CAACN,CAAC,CAACmD,OAAO,CAAC,EAAE,GAAG,CAAC,EAAE,mBAAmB,CAAC;QAC3G4K,eAAe,EAAE,eAAgBvP,CAAC,CAAEwB,CAAC,IAAKA,CAAC,CAACrB,KAAK,CAACwJ,QAAQ,CAAC,CAAC,EAAE,iBAAiB,CAAC;QAChF6F,eAAe,EAAE,eAAgBxP,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAK,IAAIN,CAAC,CAAC0G,QAAQ,CAACuC,GAAG,CAAC3I,CAAC,CAAC,CAACsJ,IAAI,CAAC,CAAC5J,CAAC,CAAC6F,IAAI,CAAC0E,SAAS,KAAK,OAAO,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,CAAC,GAAG,EAAE;AACtI,WAAW,CAAC;QACJ0D,iBAAiB,EAAE,eAAgBzP,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAKoM,EAAE,CAAC1M,CAAC,CAAC6F,IAAI,CAACC,QAAQ,EAAExF,CAAC,CAACN,CAAC,CAACmD,OAAO,CAAC,EAAE,GAAG,CAAC,EAAE,mBAAmB,CAAC;QAC3G+K,eAAe,EAAE,eAAgB1P,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAK,GAAGN,CAAC,CAACrB,KAAK,IAAIqB,CAAC,CAACmD,OAAO,KAAK,KAAK,CAAC,GAAG7C,CAAC,CAACN,CAAC,CAACmD,OAAO,CAAC,GAAG,EAAE,GAAG,EAAE,iBAAiB,CAAC;QAC1HgL,eAAe,EAAE,eAAgB3P,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAK,UAAUA,CAAC,CAACN,CAAC,CAACmD,OAAO,CAAC,EAAE,EAAE,iBAAiB,CAAC;QACzFiL,kBAAkB,EAAE,eAAgB5P,CAAC,CAAC,MAAM,WAAW,EAAE,oBAAoB,CAAC;QAC9E6P,cAAc,EAAE,eAAgB7P,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAKN,CAAC,CAAC0G,QAAQ,CAACuC,GAAG,CAAC3I,CAAC,CAAC,CAACsJ,IAAI,CAAC,KAAK,CAAC,EAAE,gBAAgB,CAAC;QAC5F0E,gBAAgB,EAAE,eAAgB9P,CAAC,CAAC,MAAM,GAAG,EAAE,kBAAkB,CAAC;QAClE+P,qBAAqB,EAAE,eAAgB/P,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAKN,CAAC,CAAC0G,QAAQ,CAACuC,GAAG,CAAC3I,CAAC,CAAC,CAACsJ,IAAI,CAAC,KAAK,CAAC,EAAE,uBAAuB,CAAC;QAC1G4E,iBAAiB,EAAE,eAAgBhQ,CAAC,CAAEwB,CAAC,IAAK2M,CAAC,CAAC3M,CAAC,CAACrB,KAAK,EAAEqB,CAAC,CAAC6F,IAAI,CAACqC,KAAK,CAAC,EAAE,mBAAmB,CAAC;QAC1FuG,kBAAkB,EAAE,eAAgBjQ,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAK,GAAGA,CAAC,CAACN,CAAC,CAACkH,IAAI,CAAC,OAAO5G,CAAC,CAACN,CAAC,CAACsI,KAAK,CAAC,EAAE,EAAE,oBAAoB,CAAC;QACtGoG,uBAAuB,EAAE,eAAgBlQ,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAK,IAAIN,CAAC,CAAC2J,GAAG,KAAKrJ,CAAC,CAACN,CAAC,CAACsI,KAAK,CAAC,GAAG,EAAE,yBAAyB,CAAC;QAC5GqG,mBAAmB,EAAE,eAAgBnQ,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAK,IAAIN,CAAC,CAAC2J,GAAG,OAAOrJ,CAAC,CAACN,CAAC,CAACsI,KAAK,CAAC,GAAG,EAAE,qBAAqB,CAAC;QACtGsG,gBAAgB,EAAE,eAAgBpQ,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAK,WAAWA,CAAC,CAACN,CAAC,CAACkH,IAAI,CAAC,OAAO5G,CAAC,CAACN,CAAC,CAACsI,KAAK,CAAC,EAAE,EAAE,kBAAkB;MAC3G,CAAC;IACH;IACA9J,CAAC,CAACoO,EAAE,EAAE,gBAAgB,CAAC;IACvB,IAAIiC,EAAE,GAAGjC,EAAE,CAAC,CAAC;IACb,SAASkC,EAAEA,CAAC9O,CAAC,EAAE;MACb,OAAOoM,CAAC,CAACyC,EAAE,EAAE7O,CAAC,CAAC;IACjB;IACAxB,CAAC,CAACsQ,EAAE,EAAE,WAAW,CAAC;IAClB,IAAIC,EAAE,GAAG,CACP,MAAM,EACN,MAAM,EACN,OAAO,EACP,OAAO,EACP,MAAM,EACN,OAAO,EACP,OAAO,EACP,OAAO,EACP,UAAU,EACV,UAAU,EACV,SAAS,EACT,QAAQ,EACR,IAAI,EACJ,MAAM,EACN,QAAQ,EACR,SAAS,EACT,SAAS,EACT,KAAK,EACL,UAAU,EACV,IAAI,EACJ,QAAQ,EACR,IAAI,EACJ,YAAY,EACZ,KAAK,EACL,QAAQ,EACR,OAAO,EACP,QAAQ,EACR,MAAM,EACN,OAAO,EACP,KAAK,EACL,QAAQ,EACR,KAAK,EACL,MAAM,EACN,OAAO,EACP,MAAM,EACN,OAAO,CACR;IACD,SAASC,CAACA,CAAChP,CAAC,EAAE;MACZ,IAAIM,CAAC,GAAG;QACNJ,IAAI,EAAE,gBAAgB;QACtBmG,IAAI,EAAErG;MACR,CAAC;MACD,OAAO+O,EAAE,CAACvJ,QAAQ,CAACxF,CAAC,CAAC,KAAKM,CAAC,CAAC2O,YAAY,GAAG,CAAC,CAAC,CAAC,EAAE3O,CAAC;IACnD;IACA9B,CAAC,CAACwQ,CAAC,EAAE,UAAU,CAAC;IAChB,IAAIE,EAAE,GAAG;MACPjB,iBAAiB,EAAE,eAAgBzP,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAK;QAC7C,IAAIM,CAAC,GAAGN,CAAC,CAACN,CAAC,CAACmD,OAAO,CAAC;QACpB,OAAOvC,CAAC,CAAC4J,QAAQ,GAAG,CAAC,CAAC,EAAE5J,CAAC;MAC3B,CAAC,EAAE,mBAAmB,CAAC;MACvBkN,iBAAiB,EAAE,eAAgBtP,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAK;QAC7C,IAAIM,CAAC,GAAGN,CAAC,CAACN,CAAC,CAACmD,OAAO,CAAC;QACpB,OAAOvC,CAAC,CAACuO,QAAQ,GAAG,CAAC,CAAC,EAAEvO,CAAC;MAC3B,CAAC,EAAE,mBAAmB,CAAC;MACvBgN,oBAAoB,EAAE,eAAgBpP,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAK;QAChD,IAAIM,CAAC,GAAGN,CAAC,CAACN,CAAC,CAACmD,OAAO,CAAC;QACpB,OAAOvC,CAAC,CAACuO,QAAQ,GAAG,CAAC,CAAC,EAAEvO,CAAC;MAC3B,CAAC,EAAE,sBAAsB,CAAC;MAC1BsM,iBAAiB,EAAE,eAAgB1O,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAK;QAC7C,IAAIN,CAAC,CAACmD,OAAO,KAAK,KAAK,CAAC,EACtB,MAAM,IAAI/C,KAAK,CAAC,sDAAsD,CAAC;QACzE,IAAIQ,CAAC,GAAGN,CAAC,CAACN,CAAC,CAACmD,OAAO,CAAC;QACpB,OAAOvC,CAAC,CAACwO,UAAU,GAAG,CAAC,CAAC,EAAExO,CAAC;MAC7B,CAAC,EAAE,mBAAmB,CAAC;MACvByM,YAAY,EAAE,eAAgB7O,CAAC,CAAC,OAAO;QACrC0B,IAAI,EAAE;MACR,CAAC,CAAC,EAAE,cAAc,CAAC;MACnB2N,aAAa,EAAE,eAAgBrP,CAAC,CAAC,OAAO;QACtC0B,IAAI,EAAE;MACR,CAAC,CAAC,EAAE,eAAe,CAAC;MACpBkN,oBAAoB,EAAE,eAAgB5O,CAAC,CAAEwB,CAAC,IAAKgP,CAAC,CAACrC,CAAC,CAAC3M,CAAC,CAACrB,KAAK,EAAEqB,CAAC,CAAC6F,IAAI,CAACqC,KAAK,CAAC,CAAC,EAAE,sBAAsB,CAAC;MACnGkG,kBAAkB,EAAE,eAAgB5P,CAAC,CAAC,OAAO;QAC3C0B,IAAI,EAAE;MACR,CAAC,CAAC,EAAE,oBAAoB,CAAC;MACzBoO,gBAAgB,EAAE,eAAgB9P,CAAC,CAAC,OAAO;QACzC0B,IAAI,EAAE;MACR,CAAC,CAAC,EAAE,kBAAkB,CAAC;MACvB6M,iBAAiB,EAAE,eAAgBvO,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAK;QAC7C,IAAIM,CAAC,GAAG0L,EAAE,CAACtM,CAAC,CAAC;UAAEa,CAAC,GAAG;YACjBX,IAAI,EAAE,cAAc;YACpBqM,MAAM,EAAE3L,CAAC,CAAC2L,MAAM,CAACtD,GAAG,CAAC3I,CAAC;UACxB,CAAC;QACD,OAAOM,CAAC,CAAC4L,IAAI,KAAK,KAAK,CAAC,KAAK3L,CAAC,CAAC2L,IAAI,GAAGlM,CAAC,CAACM,CAAC,CAAC4L,IAAI,CAAC,CAAC,EAAE5L,CAAC,CAAC6L,GAAG,KAAK,KAAK,CAAC,KAAK5L,CAAC,CAAC4L,GAAG,GAAGnM,CAAC,CAACM,CAAC,CAAC6L,GAAG,CAAC,CAAC,EAAEzM,CAAC,CAAC6J,UAAU,KAAK,KAAK,CAAC,KAAKhJ,CAAC,CAACwO,MAAM,GAAG/O,CAAC,CAACN,CAAC,CACpI6J,UAAU,CAAC,CAAC,EAAEhJ,CAAC;MACjB,CAAC,EAAE,mBAAmB,CAAC;MACvByM,gBAAgB,EAAE,eAAgB9O,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,MAAM;QAC7CJ,IAAI,EAAE,iBAAiB;QACvBoP,YAAY,EAAEtP,CAAC,CAAC0G,QAAQ,CAACuC,GAAG,CAAErI,CAAC,IAAKN,CAAC,CAACM,CAAC,CAAC,CAAC;QACzC2O,UAAU,EAAEjP,CAAC,CAACN,CAAC,CAACkH,IAAI;MACtB,CAAC,CAAC,EAAE,kBAAkB,CAAC;MACvByG,wBAAwB,EAAE,eAAgBnP,CAAC,CAAEwB,CAAC,IAAKgP,CAAC,CAAChP,CAAC,CAACoI,WAAW,GAAG,GAAG,GAAGuE,CAAC,CAAC3M,CAAC,CAACrB,KAAK,EAAEqB,CAAC,CAAC6F,IAAI,CAACqC,KAAK,CAAC,CAAC,EAAE,0BAA0B,CAAC;MACjI8E,aAAa,EAAE,eAAgBxO,CAAC,CAAEwB,CAAC,IAAKA,CAAC,CAACrB,KAAK,KAAK,UAAU,GAAGqQ,CAAC,CAAChP,CAAC,CAACrB,KAAK,CAAC,GAAG;QAC5EuB,IAAI,EAAE,cAAc;QACpBqM,MAAM,EAAE;MACV,CAAC,EAAE,eAAe,CAAC;MACnBwB,eAAe,EAAE,eAAgBvP,CAAC,CAAEwB,CAAC,IAAKgP,CAAC,CAAChP,CAAC,CAACrB,KAAK,CAACwJ,QAAQ,CAAC,CAAC,CAAC,EAAE,iBAAiB,CAAC;MACnF6F,eAAe,EAAE,eAAgBxP,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAK;QAC3C,IAAIM,CAAC,GAAG;UACNV,IAAI,EAAE,YAAY;UAClBsP,MAAM,EAAE;QACV,CAAC;QACD,KAAK,IAAI3O,CAAC,IAAIb,CAAC,CAAC0G,QAAQ,EACtB7F,CAAC,CAACX,IAAI,KAAK,sBAAsB,IAAIW,CAAC,CAACX,IAAI,KAAK,2BAA2B,GAAGU,CAAC,CAAC4O,MAAM,CAACzI,IAAI,CAAC;UAC1F7G,IAAI,EAAE,WAAW;UACjByJ,GAAG,EAAErJ,CAAC,CAACO,CAAC,CAAC;UACTlC,KAAK,EAAE,KAAK;QACd,CAAC,CAAC,GAAGiC,CAAC,CAAC4O,MAAM,CAACzI,IAAI,CAACzG,CAAC,CAACO,CAAC,CAAC,CAAC;QAC1B,OAAOD,CAAC;MACV,CAAC,EAAE,iBAAiB,CAAC;MACrB4M,oBAAoB,EAAE,eAAgBhP,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAK;QAChD,IAAI,OAAON,CAAC,CAAC2J,GAAG,IAAI,QAAQ,EAC1B,MAAM,IAAIvJ,KAAK,CAAC,qDAAqD,CAAC;QACxE,OAAO;UACLF,IAAI,EAAE,WAAW;UACjByJ,GAAG,EAAEqF,CAAC,CAACrC,CAAC,CAAC3M,CAAC,CAAC2J,GAAG,EAAE3J,CAAC,CAAC6F,IAAI,CAACqC,KAAK,CAAC,CAAC;UAC9BvJ,KAAK,EAAEqB,CAAC,CAACsI,KAAK,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGhI,CAAC,CAACN,CAAC,CAACsI,KAAK;QAChD,CAAC;MACH,CAAC,EAAE,sBAAsB,CAAC;MAC1BmF,yBAAyB,EAAE,eAAgBjP,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,MAAM;QACtDJ,IAAI,EAAE,WAAW;QACjByJ,GAAG,EAAErJ,CAAC,CAACN,CAAC,CAACkH,IAAI,CAAC;QACdvI,KAAK,EAAE2B,CAAC,CAACN,CAAC,CAACsI,KAAK;MAClB,CAAC,CAAC,EAAE,2BAA2B,CAAC;MAChC+F,cAAc,EAAE,eAAgB7P,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,MAAM;QAC3CJ,IAAI,EAAE,WAAW;QACjBwG,QAAQ,EAAE1G,CAAC,CAAC0G,QAAQ,CAACuC,GAAG,CAAErI,CAAC,IAAKN,CAAC,CAACM,CAAC,CAAC;MACtC,CAAC,CAAC,EAAE,gBAAgB,CAAC;MACrB8M,iBAAiB,EAAE,eAAgBlP,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,MAAM;QAC9CJ,IAAI,EAAE,WAAW;QACjByJ,GAAG,EAAEqF,CAAC,CAAChP,CAAC,CAAC2J,GAAG,CAAC;QACbhL,KAAK,EAAEqB,CAAC,CAACsI,KAAK,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGhI,CAAC,CAACN,CAAC,CAACsI,KAAK;MAChD,CAAC,CAAC,EAAE,mBAAmB,CAAC;MACxB6E,iBAAiB,EAAE,eAAgB3O,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAK;QAC7C,IAAIM,CAAC,GAAGN,CAAC,CAACN,CAAC,CAACkH,IAAI,CAAC;UAAErG,CAAC;QACpBb,CAAC,CAACsI,KAAK,CAACpI,IAAI,KAAK,0BAA0B,GAAGW,CAAC,GAAGP,CAAC,CAACN,CAAC,CAACsI,KAAK,CAAC,CAACjC,IAAI,GAAGxF,CAAC,GAAG8L,CAAC,CAAC3M,CAAC,CAACsI,KAAK,CAAC3J,KAAK,EAAEqB,CAAC,CAACsI,KAAK,CAACzC,IAAI,CAACqC,KAAK,CAAC;QAC5G,IAAIjH,CAAC,GAAGjB,CAAC,CAACuI,QAAQ,KAAK,OAAO,GAAG,GAAG,GAAGvI,CAAC,CAACuI,QAAQ,KAAK,UAAU,GAAG,GAAG,GAAG,GAAG;QAC5E,OAAOyG,CAAC,CAAC,GAAGpO,CAAC,CAACyF,IAAI,GAAGpF,CAAC,GAAGJ,CAAC,EAAE,CAAC;MAC/B,CAAC,EAAE,mBAAmB,CAAC;MACvBqN,eAAe,EAAE,eAAgB1P,CAAC,CAAEwB,CAAC,IAAK;QACxC,IAAIM,CAAC,GAAG,EAAE;UAAEM,CAAC,GAAGZ,CAAC,CAACmD,OAAO;UAAEtC,CAAC,GAAG,CAAC,CAAC;QACjC,OAAOD,CAAC,EAAEV,IAAI,KAAK,mBAAmB,KAAKU,CAAC,CAACiF,IAAI,CAACC,QAAQ,KAAK,QAAQ,GAAGxF,CAAC,GAAG,KAAK,GAAGO,CAAC,GAAG,CAAC,CAAC,EAAED,CAAC,GAAGA,CAAC,CAACuC,OAAO,CAAC,EAAEvC,CAAC,EAAEV,IAAI,KAAK;AAClI,KAAK,GAAGI,CAAC,IAAIM,CAAC,CAACjC,KAAK,GAAGiC,CAAC,EAAEV,IAAI,KAAK,iBAAiB,KAAKI,CAAC,IAAIM,CAAC,CAACjC,KAAK,CAACwJ,QAAQ,CAAC,CAAC,CAAC,EAAEtH,CAAC,KAAKP,CAAC,IAAI,KAAK,CAAC,EAAE0O,CAAC,CAAC,GAAGhP,CAAC,CAACrB,KAAK,IAAI2B,CAAC,GAAG,CAAC;MACrH,CAAC,EAAE,iBAAiB,CAAC;MACrBuM,oBAAoB,EAAE,eAAgBrO,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAKA,CAAC,CAACwC,CAAC,CAAC9C,CAAC,CAACmD,OAAO,CAAC,CAAC,EAAE,sBAAsB,CAAC;MAC1FwL,mBAAmB,EAAEtC,CAAC;MACtBqC,uBAAuB,EAAErC,CAAC;MAC1BkB,eAAe,EAAElB,CAAC;MAClBS,cAAc,EAAET,CAAC;MACjBY,cAAc,EAAEZ,CAAC;MACjB8B,eAAe,EAAE9B,CAAC;MAClBkC,qBAAqB,EAAElC,CAAC;MACxBmC,iBAAiB,EAAEnC,CAAC;MACpBoC,kBAAkB,EAAEpC,CAAC;MACrBuC,gBAAgB,EAAEvC;IACpB,CAAC;IACD,SAASoD,EAAEA,CAACzP,CAAC,EAAE;MACb,OAAOoM,CAAC,CAAC8C,EAAE,EAAElP,CAAC,CAAC;IACjB;IACAxB,CAAC,CAACiR,EAAE,EAAE,oBAAoB,CAAC;IAC3B,SAASC,CAACA,CAAC1P,CAAC,EAAE;MACZ,QAAQA,CAAC;QACP,KAAK,KAAK,CAAC;UACT,OAAO,MAAM;QACf,KAAK,QAAQ;UACX,OAAO,QAAQ;QACjB,KAAK,QAAQ;UACX,OAAO,QAAQ;MACnB;IACF;IACAxB,CAAC,CAACkR,CAAC,EAAE,eAAe,CAAC;IACrB,SAASC,EAAEA,CAAC3P,CAAC,EAAE;MACb,QAAQA,CAAC;QACP,KAAK,OAAO;UACV,OAAO,cAAc;QACvB,KAAK,UAAU;UACb,OAAO,iBAAiB;QAC1B,KAAK,UAAU;UACb,OAAO,QAAQ;QACjB,KAAK,mBAAmB;UACtB,OAAO,QAAQ;MACnB;IACF;IACAxB,CAAC,CAACmR,EAAE,EAAE,eAAe,CAAC;IACtB,SAASC,EAAEA,CAAC5P,CAAC,EAAEM,CAAC,EAAE;MAChB,OAAOA,CAAC,CAACY,MAAM,KAAK,CAAC,GAAG;QACtBhB,IAAI,EAAEF,CAAC;QACPkH,IAAI,EAAE5G,CAAC,CAAC,CAAC,CAAC;QACVgI,KAAK,EAAEhI,CAAC,CAAC,CAAC;MACZ,CAAC,GAAG;QACFJ,IAAI,EAAEF,CAAC;QACPkH,IAAI,EAAE5G,CAAC,CAAC,CAAC,CAAC;QACVgI,KAAK,EAAEsH,EAAE,CAAC5P,CAAC,EAAEM,CAAC,CAACa,KAAK,CAAC,CAAC,CAAC;MACzB,CAAC;IACH;IACA3C,CAAC,CAACoR,EAAE,EAAE,aAAa,CAAC;IACpB,IAAIC,EAAE,GAAG;MACP5B,iBAAiB,EAAE,eAAgBzP,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,MAAM;QAC9CJ,IAAI,EAAE,UAAU;QAChBvB,KAAK,EAAE2B,CAAC,CAACN,CAAC,CAACmD,OAAO,CAAC;QACnB0C,IAAI,EAAE;UACJiK,MAAM,EAAE9P,CAAC,CAAC6F,IAAI,CAACC,QAAQ,KAAK,QAAQ,GAAG,mBAAmB,GAAG;QAC/D;MACF,CAAC,CAAC,EAAE,mBAAmB,CAAC;MACxBgI,iBAAiB,EAAE,eAAgBtP,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,MAAM;QAC9CJ,IAAI,EAAE,UAAU;QAChBvB,KAAK,EAAE2B,CAAC,CAACN,CAAC,CAACmD,OAAO,CAAC;QACnB0C,IAAI,EAAE;UACJiK,MAAM,EAAE9P,CAAC,CAAC6F,IAAI,CAACC,QAAQ,KAAK,QAAQ,GAAG,sBAAsB,GAAG;QAClE;MACF,CAAC,CAAC,EAAE,mBAAmB,CAAC;MACxB8H,oBAAoB,EAAE,eAAgBpP,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,MAAM;QACjDJ,IAAI,EAAE,cAAc;QACpBvB,KAAK,EAAE2B,CAAC,CAACN,CAAC,CAACmD,OAAO,CAAC;QACnB0C,IAAI,EAAE;UACJiK,MAAM,EAAE9P,CAAC,CAAC6F,IAAI,CAACC,QAAQ,KAAK,QAAQ,GAAG,aAAa,GAAG;QACzD;MACF,CAAC,CAAC,EAAE,sBAAsB,CAAC;MAC3BoH,iBAAiB,EAAE,eAAgB1O,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAK;QAC7C,IAAIM,CAAC,GAAG;UACNV,IAAI,EAAE,UAAU;UAChB2F,IAAI,EAAE;YACJiK,MAAM,EAAE9P,CAAC,CAAC6F,IAAI,CAACC,QAAQ,KAAK,QAAQ,GAAG,aAAa,GAAG9F,CAAC,CAAC6F,IAAI,CAACC,QAAQ,KAAK,QAAQ,GAAG,aAAa,GAAG;UACxG;QACF,CAAC;QACD,OAAO9F,CAAC,CAACmD,OAAO,KAAK,KAAK,CAAC,KAAKvC,CAAC,CAACjC,KAAK,GAAG2B,CAAC,CAACN,CAAC,CAACmD,OAAO,CAAC,CAAC,EAAEvC,CAAC;MAC5D,CAAC,EAAE,mBAAmB,CAAC;MACvBoM,aAAa,EAAE,eAAgBxO,CAAC,CAAEwB,CAAC,KAAM;QACvCE,IAAI,EAAE,MAAM;QACZmG,IAAI,EAAErG,CAAC,CAACrB;MACV,CAAC,CAAC,EAAE,eAAe,CAAC;MACpBwP,eAAe,EAAE,eAAgB3P,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,MAAM;QAC5CJ,IAAI,EAAE,YAAY;QAClBmG,IAAI,EAAE/F,CAAC,CAACN,CAAC,CAACmD,OAAO;MACnB,CAAC,CAAC,EAAE,iBAAiB,CAAC;MACtB8J,cAAc,EAAE,eAAgBzO,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,MAAM;QAC3CJ,IAAI,EAAE,OAAO;QACb6P,OAAO,EAAE/P,CAAC,CAAC0G,QAAQ,CAACuC,GAAG,CAAC3I,CAAC;MAC3B,CAAC,CAAC,EAAE,gBAAgB,CAAC;MACrBwM,cAAc,EAAE,eAAgBtO,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,MAAM;QAC3CJ,IAAI,EAAE,WAAW;QACjBvB,KAAK,EAAE2B,CAAC,CAACN,CAAC,CAACmD,OAAO;MACpB,CAAC,CAAC,EAAE,gBAAgB,CAAC;MACrBoK,eAAe,EAAE,eAAgB/O,CAAC,CAAEwB,CAAC,KAAM;QACzCE,IAAI,EAAE,QAAQ;QACd8P,IAAI,EAAE;UACJ9P,IAAI,EAAE,cAAc;UACpB+P,UAAU,EAAEP,CAAC,CAAC1P,CAAC,CAACmD,OAAO,CAAC0C,IAAI,CAACqC,KAAK,CAAC;UACnCgI,MAAM,EAAElQ,CAAC,CAACmD,OAAO,CAACxE;QACpB;MACF,CAAC,CAAC,EAAE,iBAAiB,CAAC;MACtByP,kBAAkB,EAAE,eAAgB5P,CAAC,CAAC,OAAO;QAC3C0B,IAAI,EAAE,MAAM;QACZmG,IAAI,EAAE;MACR,CAAC,CAAC,EAAE,oBAAoB,CAAC;MACzBgH,YAAY,EAAE,eAAgB7O,CAAC,CAAC,OAAO;QACrC0B,IAAI,EAAE;MACR,CAAC,CAAC,EAAE,cAAc,CAAC;MACnB6M,iBAAiB,EAAE,eAAgBvO,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAK;QAC7C,IAAIM,CAAC,GAAG0L,EAAE,CAACtM,CAAC,CAAC;UAAEa,CAAC,GAAG;YACjBX,IAAI,EAAEF,CAAC,CAACyJ,KAAK,GAAG,OAAO,GAAG,UAAU;YACpC8C,MAAM,EAAE3L,CAAC,CAAC2L,MAAM,CAACtD,GAAG,CAAEhI,CAAC,IAAK;cAC1B,IAAIA,CAAC,CAACf,IAAI,KAAK,mBAAmB,EAAE;gBAClC,IAAIe,CAAC,CAACqH,KAAK,KAAK,KAAK,CAAC,EACpB,MAAM,IAAIlI,KAAK,CAAC,kEAAkE,CAAC;gBACrF,OAAO;kBACLF,IAAI,EAAE,iBAAiB;kBACvBmG,IAAI,EAAEpF,CAAC,CAAC0I,GAAG;kBACXwG,QAAQ,EAAE7P,CAAC,CAACW,CAAC,CAACqH,KAAK;gBACrB,CAAC;cACH,CAAC,MACC,OAAOhI,CAAC,CAACW,CAAC,CAAC;YACf,CAAC,CAAC;YACFwL,GAAG,EAAE,IAAI;YACT2D,OAAO,EAAE;UACX,CAAC;QACD,OAAOxP,CAAC,CAAC4L,IAAI,KAAK,KAAK,CAAC,GAAG3L,CAAC,CAAC2L,IAAI,GAAGlM,CAAC,CAACM,CAAC,CAAC4L,IAAI,CAAC,GAAGxM,CAAC,CAACyJ,KAAK,KAAK5I,CAAC,CAAC2L,IAAI,GAAG,IAAI,CAAC,EAAE5L,CAAC,CAAC6L,GAAG,KAAK,KAAK,CAAC,KAAK5L,CAAC,CAAC4L,GAAG,GAAGnM,CAAC,CAACM,CAAC,CAAC6L,GAAG,CAAC,CAAC,EAAEzM,CAAC,CAAC6J,UAAU,KAChI,KAAK,CAAC,KAAKhJ,CAAC,CAACuP,OAAO,GAAG9P,CAAC,CAACN,CAAC,CAAC6J,UAAU,CAAC,CAAC,EAAEhJ,CAAC;MAC5C,CAAC,EAAE,mBAAmB,CAAC;MACvByM,gBAAgB,EAAE,eAAgB9O,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAK;QAC5C,IAAIM,CAAC,GAAG;UACNV,IAAI,EAAE,SAAS;UACfmQ,OAAO,EAAE/P,CAAC,CAACN,CAAC,CAACkH,IAAI,CAAC;UAClBoJ,OAAO,EAAEtQ,CAAC,CAAC0G,QAAQ,CAACuC,GAAG,CAAC3I,CAAC,CAAC;UAC1BuF,IAAI,EAAE;YACJiK,MAAM,EAAE9P,CAAC,CAAC6F,IAAI,CAACsB,QAAQ,KAAK,QAAQ,GAAG,gBAAgB,GAAGnH,CAAC,CAAC6F,IAAI,CAACuB,GAAG,GAAG,wBAAwB,GAAG;UACpG;QACF,CAAC;QACD,OAAOpH,CAAC,CAAC6F,IAAI,CAACsB,QAAQ,KAAK,QAAQ,IAAInH,CAAC,CAAC0G,QAAQ,CAAC,CAAC,CAAC,CAACxG,IAAI,KAAK,mBAAmB,IAAI,CAACF,CAAC,CAAC0G,QAAQ,CAAC,CAAC,CAAC,CAACgD,WAAW,KAAK9I,CAAC,CAAC0P,OAAO,CAAC,CAAC,CAAC,GAAG;UACjIpQ,IAAI,EAAE,MAAM;UACZmG,IAAI,EAAE;QACR,CAAC,CAAC,EAAEzF,CAAC;MACP,CAAC,EAAE,kBAAkB,CAAC;MACtB4M,oBAAoB,EAAE,eAAgBhP,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAK;QAChD,IAAI,OAAON,CAAC,CAAC2J,GAAG,IAAI,QAAQ,EAC1B,MAAM,IAAIvJ,KAAK,CAAC,qDAAqD,CAAC;QACxE,IAAIJ,CAAC,CAACsI,KAAK,KAAK,KAAK,CAAC,EACpB,OAAO;UACLpI,IAAI,EAAE,cAAc;UACpByJ,GAAG,EAAE3J,CAAC,CAAC2J,GAAG;UACVsG,UAAU,EAAEP,CAAC,CAAC1P,CAAC,CAAC6F,IAAI,CAACqC,KAAK,CAAC;UAC3BvJ,KAAK,EAAE,IAAI;UACX8L,QAAQ,EAAE,CAAC;QACb,CAAC;QACH,IAAI7J,CAAC,GAAGN,CAAC,CAACN,CAAC,CAACsI,KAAK,CAAC;QAClB,OAAOtI,CAAC,CAACwK,QAAQ,KAAK5J,CAAC,GAAG;UACxBV,IAAI,EAAE,UAAU;UAChBvB,KAAK,EAAEiC,CAAC;UACRiF,IAAI,EAAE;YACJiK,MAAM,EAAE;UACV;QACF,CAAC,CAAC,EAAE;UACF5P,IAAI,EAAE,cAAc;UACpByJ,GAAG,EAAE3J,CAAC,CAAC2J,GAAG,CAACxB,QAAQ,CAAC,CAAC;UACrB8H,UAAU,EAAEP,CAAC,CAAC1P,CAAC,CAAC6F,IAAI,CAACqC,KAAK,CAAC;UAC3BvJ,KAAK,EAAEiC,CAAC;UACR6J,QAAQ,EAAE,CAAC;QACb,CAAC;MACH,CAAC,EAAE,sBAAsB,CAAC;MAC1BgD,yBAAyB,EAAE,eAAgBjP,CAAC,CAAC,MAAM;QACjD,MAAM,IAAI4B,KAAK,CAAC,2CAA2C,CAAC;MAC9D,CAAC,EAAE,2BAA2B,CAAC;MAC/BsN,iBAAiB,EAAE,eAAgBlP,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAK;QAC7C,IAAIN,CAAC,CAACsI,KAAK,KAAK,KAAK,CAAC,EACpB,OAAO;UACLpI,IAAI,EAAE,cAAc;UACpByJ,GAAG,EAAE3J,CAAC,CAAC2J,GAAG;UACVsG,UAAU,EAAE,MAAM;UAClBtR,KAAK,EAAE,IAAI;UACX8L,QAAQ,EAAE,CAAC;QACb,CAAC;QACH,IAAI7J,CAAC,GAAGN,CAAC,CAACN,CAAC,CAACsI,KAAK,CAAC;QAClB,OAAOtI,CAAC,CAACwK,QAAQ,KAAK5J,CAAC,GAAG;UACxBV,IAAI,EAAE,UAAU;UAChBvB,KAAK,EAAEiC,CAAC;UACRiF,IAAI,EAAE;YACJiK,MAAM,EAAE;UACV;QACF,CAAC,CAAC,EAAE;UACF5P,IAAI,EAAE,cAAc;UACpByJ,GAAG,EAAE3J,CAAC,CAAC2J,GAAG;UACVsG,UAAU,EAAE,MAAM;UAClBtR,KAAK,EAAEiC,CAAC;UACR6J,QAAQ,EAAE,CAAC;QACb,CAAC;MACH,CAAC,EAAE,mBAAmB,CAAC;MACvBuD,eAAe,EAAE,eAAgBxP,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAK;QAC3C,IAAIM,CAAC,GAAG,EAAE;QACV,KAAK,IAAIC,CAAC,IAAIb,CAAC,CAAC0G,QAAQ,EACtB,CAAC7F,CAAC,CAACX,IAAI,KAAK,sBAAsB,IAAIW,CAAC,CAACX,IAAI,KAAK,2BAA2B,KAAKU,CAAC,CAACmG,IAAI,CAACzG,CAAC,CAACO,CAAC,CAAC,CAAC;QAC/F,OAAO;UACLX,IAAI,EAAE,QAAQ;UACd6P,OAAO,EAAEnP;QACX,CAAC;MACH,CAAC,EAAE,iBAAiB,CAAC;MACrB+M,wBAAwB,EAAE,eAAgBnP,CAAC,CAAEwB,CAAC,IAAK;QACjD,IAAIA,CAAC,CAACoI,WAAW,KAAK,QAAQ,EAC5B,MAAM,IAAIhI,KAAK,CAAC,yCAAyCJ,CAAC,CAACoI,WAAW,iBAAiB,CAAC;QAC1F,OAAO;UACLlI,IAAI,EAAE,QAAQ;UACdvB,KAAK,EAAE;YACLuB,IAAI,EAAE,WAAW;YACjB+P,UAAU,EAAEP,CAAC,CAAC1P,CAAC,CAAC6F,IAAI,CAACqC,KAAK,CAAC;YAC3B8H,IAAI,EAAEhQ,CAAC,CAACrB;UACV;QACF,CAAC;MACH,CAAC,EAAE,0BAA0B,CAAC;MAC9BwO,iBAAiB,EAAE,eAAgB3O,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAK;QAC7C,IAAIM,CAAC,GAAG,CAAC,CAAC;UAAEC,CAAC;UAAEI,CAAC;QAChBjB,CAAC,CAACsI,KAAK,CAACpI,IAAI,KAAK,0BAA0B,IAAIF,CAAC,CAACsI,KAAK,CAACF,WAAW,KAAK,OAAO,IAAIxH,CAAC,GAAG,CAAC,CAAC,EAAEC,CAAC,GAAGb,CAAC,CAACsI,KAAK,CAAC3J,KAAK,EAAEsC,CAAC,GAAGyO,CAAC,CAAC1P,CAAC,CAACsI,KAAK,CAACzC,IAAI,CAACqC,KAAK,CAAC,KACrIrH,CAAC,GAAGb,CAAC,CAACsI,KAAK,CAAC3J,KAAK,EAAEsC,CAAC,GAAGyO,CAAC,CAAC1P,CAAC,CAACsI,KAAK,CAACzC,IAAI,CAACqC,KAAK,CAAC,CAAC;QAC9C,IAAIzF,CAAC,GAAG;UACNvC,IAAI,EAAEyP,EAAE,CAAC3P,CAAC,CAACuI,QAAQ,CAAC;UACpBgI,KAAK,EAAEjQ,CAAC,CAACN,CAAC,CAACkH,IAAI,CAAC;UAChBb,IAAI,EAAExF,CAAC;UACPoP,UAAU,EAAEhP,CAAC;UACbuP,cAAc,EAAE5P;QAClB,CAAC;QACD,IAAI6B,CAAC,CAAC8N,KAAK,CAACrQ,IAAI,KAAK,QAAQ,EAAE;UAC7B,IAAI8F,CAAC,GAAGvD,CAAC,CAAC8N,KAAK;UACf,OAAO9N,CAAC,CAAC8N,KAAK,GAAG9N,CAAC,CAAC8N,KAAK,CAAC5R,KAAK,EAAEqH,CAAC,CAACrH,KAAK,GAAG8D,CAAC,EAAEuD,CAAC;QAChD,CAAC,MACC,OAAOvD,CAAC;MACZ,CAAC,EAAE,mBAAmB,CAAC;MACvB4L,cAAc,EAAE,eAAgB7P,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAKsP,EAAE,CAAC,OAAO,EAAE5P,CAAC,CAAC0G,QAAQ,CAACuC,GAAG,CAAC3I,CAAC,CAAC,CAAC,EAAE,gBAAgB,CAAC;MAC7FuM,oBAAoB,EAAE,eAAgBrO,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,MAAM;QACjDJ,IAAI,EAAE,aAAa;QACnBvB,KAAK,EAAE2B,CAAC,CAACwC,CAAC,CAAC9C,CAAC,CAACmD,OAAO,CAAC;MACvB,CAAC,CAAC,EAAE,sBAAsB,CAAC;MAC3B0K,aAAa,EAAE,eAAgBrP,CAAC,CAAC,OAAO;QACtC0B,IAAI,EAAE,MAAM;QACZmG,IAAI,EAAE;MACR,CAAC,CAAC,EAAE,eAAe,CAAC;MACpBiI,gBAAgB,EAAE,eAAgB9P,CAAC,CAAC,OAAO;QACzC0B,IAAI,EAAE;MACR,CAAC,CAAC,EAAE,kBAAkB,CAAC;MACvBkN,oBAAoB,EAAE,eAAgB5O,CAAC,CAAEwB,CAAC,KAAM;QAC9CE,IAAI,EAAE,cAAc;QACpB+P,UAAU,EAAEP,CAAC,CAAC1P,CAAC,CAAC6F,IAAI,CAACqC,KAAK,CAAC;QAC3BgI,MAAM,EAAElQ,CAAC,CAACrB;MACZ,CAAC,CAAC,EAAE,sBAAsB,CAAC;MAC3B4P,qBAAqB,EAAE,eAAgB/P,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAKsP,EAAE,CAAC,cAAc,EAAE5P,CAAC,CAAC0G,QAAQ,CAACuC,GAAG,CAAC3I,CAAC,CAAC,CAAC,EAAE,uBAAuB,CAAC;MAClHyN,eAAe,EAAE,eAAgBvP,CAAC,CAAEwB,CAAC,KAAM;QACzCE,IAAI,EAAE,cAAc;QACpBuQ,MAAM,EAAEzQ,CAAC,CAACrB,KAAK,CAACwJ,QAAQ,CAAC;MAC3B,CAAC,CAAC,EAAE,iBAAiB,CAAC;MACtB+F,eAAe,EAAE7B,CAAC;MAClBmC,iBAAiB,EAAEnC,CAAC;MACpBoC,kBAAkB,EAAEpC,CAAC;MACrBsC,mBAAmB,EAAEtC,CAAC;MACtBqC,uBAAuB,EAAErC,CAAC;MAC1BuC,gBAAgB,EAAEvC;IACpB,CAAC;IACD,SAASqE,EAAEA,CAAC1Q,CAAC,EAAE;MACb,OAAOoM,CAAC,CAACyD,EAAE,EAAE7P,CAAC,CAAC;IACjB;IACAxB,CAAC,CAACkS,EAAE,EAAE,cAAc,CAAC;IACrB,SAASC,EAAEA,CAAA,EAAG;MACZ,OAAO;QACLpC,qBAAqB,EAAE,eAAgB/P,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,MAAM;UAClDJ,IAAI,EAAE,uBAAuB;UAC7BwG,QAAQ,EAAE1G,CAAC,CAAC0G,QAAQ,CAACuC,GAAG,CAAC3I,CAAC;QAC5B,CAAC,CAAC,EAAE,uBAAuB,CAAC;QAC5BgN,gBAAgB,EAAE,eAAgB9O,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,MAAM;UAC7CJ,IAAI,EAAE,kBAAkB;UACxBgH,IAAI,EAAE5G,CAAC,CAACN,CAAC,CAACkH,IAAI,CAAC;UACfR,QAAQ,EAAE1G,CAAC,CAAC0G,QAAQ,CAACuC,GAAG,CAAC3I,CAAC,CAAC;UAC3BuF,IAAI,EAAE;YACJuB,GAAG,EAAEpH,CAAC,CAAC6F,IAAI,CAACuB,GAAG;YACfD,QAAQ,EAAEnH,CAAC,CAAC6F,IAAI,CAACsB;UACnB;QACF,CAAC,CAAC,EAAE,kBAAkB,CAAC;QACvB2G,iBAAiB,EAAE,eAAgBtP,CAAC,CAAEwB,CAAC,IAAKA,CAAC,EAAE,mBAAmB,CAAC;QACnEqO,cAAc,EAAE,eAAgB7P,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,MAAM;UAC3CJ,IAAI,EAAE,gBAAgB;UACtBwG,QAAQ,EAAE1G,CAAC,CAAC0G,QAAQ,CAACuC,GAAG,CAAC3I,CAAC;QAC5B,CAAC,CAAC,EAAE,gBAAgB,CAAC;QACrBgO,gBAAgB,EAAE,eAAgB9P,CAAC,CAAEwB,CAAC,IAAKA,CAAC,EAAE,kBAAkB,CAAC;QACjEoO,kBAAkB,EAAE,eAAgB5P,CAAC,CAAEwB,CAAC,IAAKA,CAAC,EAAE,oBAAoB,CAAC;QACrEmO,eAAe,EAAE,eAAgB3P,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,MAAM;UAC5CJ,IAAI,EAAE,iBAAiB;UACvBiD,OAAO,EAAE7C,CAAC,CAACN,CAAC,CAACmD,OAAO;QACtB,CAAC,CAAC,EAAE,iBAAiB,CAAC;QACtB+K,eAAe,EAAE,eAAgB1P,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAK;UAC3C,IAAIM,CAAC,GAAG;YACNV,IAAI,EAAE,iBAAiB;YACvBvB,KAAK,EAAEqB,CAAC,CAACrB;UACX,CAAC;UACD,OAAOqB,CAAC,CAACmD,OAAO,KAAK,KAAK,CAAC,KAAKvC,CAAC,CAACuC,OAAO,GAAG7C,CAAC,CAACN,CAAC,CAACmD,OAAO,CAAC,CAAC,EAAEvC,CAAC;QAC9D,CAAC,EAAE,iBAAiB,CAAC;QACrBqN,iBAAiB,EAAE,eAAgBzP,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,MAAM;UAC9CJ,IAAI,EAAE,mBAAmB;UACzBiD,OAAO,EAAE7C,CAAC,CAACN,CAAC,CAACmD,OAAO,CAAC;UACrB0C,IAAI,EAAE;YACJC,QAAQ,EAAE9F,CAAC,CAAC6F,IAAI,CAACC;UACnB;QACF,CAAC,CAAC,EAAE,mBAAmB,CAAC;QACxBkI,eAAe,EAAE,eAAgBxP,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,MAAM;UAC5CJ,IAAI,EAAE,iBAAiB;UACvB2F,IAAI,EAAE;YACJ0E,SAAS,EAAE;UACb,CAAC;UACD7D,QAAQ,EAAE1G,CAAC,CAAC0G,QAAQ,CAACuC,GAAG,CAAC3I,CAAC;QAC5B,CAAC,CAAC,EAAE,iBAAiB,CAAC;QACtByN,eAAe,EAAE,eAAgBvP,CAAC,CAAEwB,CAAC,IAAKA,CAAC,EAAE,iBAAiB,CAAC;QAC/D6N,aAAa,EAAE,eAAgBrP,CAAC,CAAEwB,CAAC,IAAKA,CAAC,EAAE,eAAe,CAAC;QAC3D4N,oBAAoB,EAAE,eAAgBpP,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,MAAM;UACjDJ,IAAI,EAAE,sBAAsB;UAC5BiD,OAAO,EAAE7C,CAAC,CAACN,CAAC,CAACmD,OAAO,CAAC;UACrB0C,IAAI,EAAE;YACJC,QAAQ,EAAE9F,CAAC,CAAC6F,IAAI,CAACC;UACnB;QACF,CAAC,CAAC,EAAE,sBAAsB,CAAC;QAC3B6H,wBAAwB,EAAE,eAAgBnP,CAAC,CAAEwB,CAAC,IAAKA,CAAC,EAAE,0BAA0B,CAAC;QACjFwN,oBAAoB,EAAE,eAAgBhP,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,MAAM;UACjDJ,IAAI,EAAE,sBAAsB;UAC5ByJ,GAAG,EAAE3J,CAAC,CAAC2J,GAAG;UACVrB,KAAK,EAAEtI,CAAC,CAACsI,KAAK,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGhI,CAAC,CAACN,CAAC,CAACsI,KAAK,CAAC;UAC/CkC,QAAQ,EAAExK,CAAC,CAACwK,QAAQ;UACpBC,QAAQ,EAAEzK,CAAC,CAACyK,QAAQ;UACpB5E,IAAI,EAAE7F,CAAC,CAAC6F;QACV,CAAC,CAAC,EAAE,sBAAsB,CAAC;QAC3B4H,yBAAyB,EAAE,eAAgBjP,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,MAAM;UACtDJ,IAAI,EAAE,2BAA2B;UACjCgH,IAAI,EAAE5G,CAAC,CAACN,CAAC,CAACkH,IAAI,CAAC;UACfoB,KAAK,EAAEhI,CAAC,CAACN,CAAC,CAACsI,KAAK;QAClB,CAAC,CAAC,EAAE,2BAA2B,CAAC;QAChCoF,iBAAiB,EAAE,eAAgBlP,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,MAAM;UAC9CJ,IAAI,EAAE,mBAAmB;UACzByJ,GAAG,EAAE3J,CAAC,CAAC2J,GAAG;UACVrB,KAAK,EAAEtI,CAAC,CAACsI,KAAK,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGhI,CAAC,CAACN,CAAC,CAACsI,KAAK,CAAC;UAC/CkC,QAAQ,EAAExK,CAAC,CAACwK,QAAQ;UACpBQ,QAAQ,EAAEhL,CAAC,CAACgL;QACd,CAAC,CAAC,EAAE,mBAAmB,CAAC;QACxBuC,eAAe,EAAE,eAAgB/O,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,MAAM;UAC5CJ,IAAI,EAAE,iBAAiB;UACvBiD,OAAO,EAAE7C,CAAC,CAACN,CAAC,CAACmD,OAAO;QACtB,CAAC,CAAC,EAAE,iBAAiB,CAAC;QACtBkK,YAAY,EAAE,eAAgB7O,CAAC,CAAEwB,CAAC,IAAKA,CAAC,EAAE,cAAc,CAAC;QACzDoN,oBAAoB,EAAE,eAAgB5O,CAAC,CAAEwB,CAAC,IAAKA,CAAC,EAAE,sBAAsB,CAAC;QACzEmN,iBAAiB,EAAE,eAAgB3O,CAAC,CAAEwB,CAAC,IAAKA,CAAC,EAAE,mBAAmB,CAAC;QACnEkN,iBAAiB,EAAE,eAAgB1O,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAK;UAC7C,IAAIM,CAAC,GAAG;YACNV,IAAI,EAAE,mBAAmB;YACzB2F,IAAI,EAAE;cACJC,QAAQ,EAAE9F,CAAC,CAAC6F,IAAI,CAACC,QAAQ;cACzBmE,cAAc,EAAEjK,CAAC,CAAC6F,IAAI,CAACoE;YACzB;UACF,CAAC;UACD,OAAOjK,CAAC,CAACmD,OAAO,KAAK,KAAK,CAAC,KAAKvC,CAAC,CAACuC,OAAO,GAAG7C,CAAC,CAACN,CAAC,CAACmD,OAAO,CAAC,CAAC,EAAEvC,CAAC;QAC9D,CAAC,EAAE,mBAAmB,CAAC;QACvBqM,cAAc,EAAE,eAAgBzO,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,MAAM;UAC3CJ,IAAI,EAAE,gBAAgB;UACtBwG,QAAQ,EAAE1G,CAAC,CAAC0G,QAAQ,CAACuC,GAAG,CAAC3I,CAAC;QAC5B,CAAC,CAAC,EAAE,gBAAgB,CAAC;QACrB0M,aAAa,EAAE,eAAgBxO,CAAC,CAAEwB,CAAC,IAAKA,CAAC,EAAE,eAAe,CAAC;QAC3D+M,iBAAiB,EAAE,eAAgBvO,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,KAAK;UAC7C,IAAIM,CAAC,GAAG;YACNV,IAAI,EAAE,mBAAmB;YACzBuJ,KAAK,EAAEzJ,CAAC,CAACyJ,KAAK;YACdD,UAAU,EAAExJ,CAAC,CAACwJ,UAAU,CAACP,GAAG,CAAC3I,CAAC,CAAC;YAC/BD,WAAW,EAAEL,CAAC,CAACK,WAAW;YAC1BqJ,WAAW,EAAE1J,CAAC,CAAC0J;UACjB,CAAC;UACD,OAAO1J,CAAC,CAAC6J,UAAU,KAAK,KAAK,CAAC,KAAKjJ,CAAC,CAACiJ,UAAU,GAAGvJ,CAAC,CAACN,CAAC,CAAC6J,UAAU,CAAC,CAAC,EAAEjJ,CAAC;QACvE,CAAC,EAAE,mBAAmB,CAAC;QACvBkM,cAAc,EAAE,eAAgBtO,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,MAAM;UAC3CJ,IAAI,EAAE,gBAAgB;UACtBiD,OAAO,EAAE7C,CAAC,CAACN,CAAC,CAACmD,OAAO;QACtB,CAAC,CAAC,EAAE,gBAAgB,CAAC;QACrB0J,oBAAoB,EAAE,eAAgBrO,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,MAAM;UACjDJ,IAAI,EAAE,sBAAsB;UAC5BiD,OAAO,EAAE7C,CAAC,CAACN,CAAC,CAACmD,OAAO;QACtB,CAAC,CAAC,EAAE,sBAAsB,CAAC;QAC3BqL,iBAAiB,EAAE,eAAgBhQ,CAAC,CAAEwB,CAAC,IAAKA,CAAC,EAAE,mBAAmB,CAAC;QACnEyO,kBAAkB,EAAE,eAAgBjQ,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,MAAM;UAC/CJ,IAAI,EAAE,oBAAoB;UAC1BgH,IAAI,EAAE5G,CAAC,CAACN,CAAC,CAACkH,IAAI,CAAC;UACfoB,KAAK,EAAEhI,CAAC,CAACN,CAAC,CAACsI,KAAK;QAClB,CAAC,CAAC,EAAE,oBAAoB,CAAC;QACzBoG,uBAAuB,EAAE,eAAgBlQ,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,MAAM;UACpDJ,IAAI,EAAE,yBAAyB;UAC/ByJ,GAAG,EAAE3J,CAAC,CAAC2J,GAAG;UACVrB,KAAK,EAAEhI,CAAC,CAACN,CAAC,CAACsI,KAAK;QAClB,CAAC,CAAC,EAAE,yBAAyB,CAAC;QAC9BqG,mBAAmB,EAAE,eAAgBnQ,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,MAAM;UAChDJ,IAAI,EAAE,qBAAqB;UAC3ByJ,GAAG,EAAE3J,CAAC,CAAC2J,GAAG;UACVrB,KAAK,EAAEhI,CAAC,CAACN,CAAC,CAACsI,KAAK;QAClB,CAAC,CAAC,EAAE,qBAAqB,CAAC;QAC1BsG,gBAAgB,EAAE,eAAgBpQ,CAAC,CAAC,CAACwB,CAAC,EAAEM,CAAC,MAAM;UAC7CJ,IAAI,EAAE,kBAAkB;UACxBgH,IAAI,EAAE5G,CAAC,CAACN,CAAC,CAACkH,IAAI,CAAC;UACfoB,KAAK,EAAEhI,CAAC,CAACN,CAAC,CAACsI,KAAK;QAClB,CAAC,CAAC,EAAE,kBAAkB;MACxB,CAAC;IACH;IACA9J,CAAC,CAACmS,EAAE,EAAE,wBAAwB,CAAC;IAC/B,IAAIC,EAAE,GAAG;MACPvD,YAAY,EAAE,EAAE;MAChBN,iBAAiB,EAAE,CAAC,YAAY,EAAE,YAAY,CAAC;MAC/CO,gBAAgB,EAAE,CAAC,MAAM,EAAE,UAAU,CAAC;MACtCC,eAAe,EAAE,EAAE;MACnBmB,uBAAuB,EAAE,CAAC,OAAO,CAAC;MAClCH,qBAAqB,EAAE,CAAC,UAAU,CAAC;MACnCzB,cAAc,EAAE,CAAC,SAAS,CAAC;MAC3BY,iBAAiB,EAAE,CAAC,OAAO,CAAC;MAC5BiB,mBAAmB,EAAE,CAAC,OAAO,CAAC;MAC9B3B,aAAa,EAAE,EAAE;MACjBG,iBAAiB,EAAE,CAAC,MAAM,EAAE,OAAO,CAAC;MACpCS,oBAAoB,EAAE,CAAC,SAAS,CAAC;MACjCC,aAAa,EAAE,EAAE;MACjBC,iBAAiB,EAAE,CAAC,SAAS,CAAC;MAC9BC,eAAe,EAAE,EAAE;MACnBC,eAAe,EAAE,CAAC,UAAU,CAAC;MAC7BR,oBAAoB,EAAE,CAAC,OAAO,CAAC;MAC/BC,yBAAyB,EAAE,CAAC,MAAM,EAAE,OAAO,CAAC;MAC5CQ,iBAAiB,EAAE,CAAC,SAAS,CAAC;MAC9BpB,oBAAoB,EAAE,CAAC,SAAS,CAAC;MACjCc,wBAAwB,EAAE,EAAE;MAC5BP,oBAAoB,EAAE,EAAE;MACxBc,eAAe,EAAE,CAAC,SAAS,CAAC;MAC5BjB,cAAc,EAAE,CAAC,UAAU,CAAC;MAC5BkB,eAAe,EAAE,CAAC,SAAS,CAAC;MAC5BC,kBAAkB,EAAE,EAAE;MACtBC,cAAc,EAAE,CAAC,UAAU,CAAC;MAC5BC,gBAAgB,EAAE,EAAE;MACpBpB,iBAAiB,EAAE,CAAC,SAAS,CAAC;MAC9BsB,iBAAiB,EAAE,EAAE;MACrBC,kBAAkB,EAAE,CAAC,MAAM,EAAE,OAAO,CAAC;MACrCG,gBAAgB,EAAE,CAAC,MAAM,EAAE,OAAO;IACpC,CAAC;IACD,SAASiC,EAAEA,CAAC7Q,CAAC,EAAEM,CAAC,EAAEM,CAAC,EAAEC,CAAC,EAAEI,CAAC,EAAE;MACzBJ,CAAC,GAAGb,CAAC,EAAEM,CAAC,EAAEM,CAAC,CAAC;MACZ,IAAI6B,CAAC,GAAGmO,EAAE,CAAC5Q,CAAC,CAACE,IAAI,CAAC;MAClB,KAAK,IAAI8F,CAAC,IAAIvD,CAAC,EAAE;QACf,IAAIkF,CAAC,GAAG3H,CAAC,CAACgG,CAAC,CAAC;QACZ,IAAI2B,CAAC,KAAK,KAAK,CAAC,EACd,IAAIrC,KAAK,CAACC,OAAO,CAACoC,CAAC,CAAC,EAClB,KAAK,IAAIC,CAAC,IAAID,CAAC,EACbkJ,EAAE,CAACjJ,CAAC,EAAE5H,CAAC,EAAEgG,CAAC,EAAEnF,CAAC,EAAEI,CAAC,CAAC,CAAC,KAEpB4P,EAAE,CAAClJ,CAAC,EAAE3H,CAAC,EAAEgG,CAAC,EAAEnF,CAAC,EAAEI,CAAC,CAAC;MACvB;MACAA,CAAC,GAAGjB,CAAC,EAAEM,CAAC,EAAEM,CAAC,CAAC;IACd;IACApC,CAAC,CAACqS,EAAE,EAAE,WAAW,CAAC;IAClB,SAASC,EAAEA,CAAC9Q,CAAC,EAAEM,CAAC,EAAEM,CAAC,EAAE;MACnBiQ,EAAE,CAAC7Q,CAAC,EAAE,KAAK,CAAC,EAAE,KAAK,CAAC,EAAEM,CAAC,EAAEM,CAAC,CAAC;IAC7B;IACApC,CAAC,CAACsS,EAAE,EAAE,UAAU,CAAC,EAAErS,CAAC,CAACsS,kBAAkB,GAAGtB,EAAE,EAAEhR,CAAC,CAACuS,sBAAsB,GAAGL,EAAE,EAAElS,CAAC,CAACwS,YAAY,GAAGP,EAAE,EAAEjS,CAAC,CAACuG,KAAK,GAAGkH,EAAE,EAAEzN,CAAC,CAACyS,SAAS,GAAGpC,EAAE,EAAErQ,CAAC,CAAC0S,cAAc,GAClJvE,EAAE,EAAEnO,CAAC,CAAC2S,SAAS,GAAGhF,CAAC,EAAE3N,CAAC,CAAC4S,QAAQ,GAAGP,EAAE,EAAErS,CAAC,CAAC6S,QAAQ,GAAGnF,EAAE,EAAE1N,CAAC,CAAC8S,WAAW,GAAGX,EAAE;EAC3E,CAAC,CAAC;AACJ,CAAC,CAAC;;AAEF;AACA,SAASY,oBAAoB,IAAIC,EAAE,QAAQ,mCAAmC;AAC9E,IAAIC,EAAE,GAAG,eAAgBlT,CAAC,CAAEC,CAAC,IAAKA,CAAC,CAAC4H,IAAI,KAAK,SAAS,EAAE,WAAW,CAAC;EAAEsL,EAAE,GAAG,eAAgBnT,CAAC,CAAEC,CAAC,IAAKA,CAAC,CAACE,KAAK,CAACiT,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,EAAE;AACnI,KAAK,CAAC;EAAEC,EAAE,GAAG,eAAgBrT,CAAC,CAAEC,CAAC,IAAK;IACpC,QAAQA,CAAC,CAACyB,IAAI;MACZ,KAAK,UAAU;QACb,OAAO;UAAEmG,IAAI,EAAE;QAAW,CAAC;MAC7B,KAAK,QAAQ;QACX,IAAI3H,CAAC,GAAG,CAAC,CAAC;QACV,OAAOD,CAAC,CAACqT,SAAS,CAACC,UAAU,CAACC,OAAO,CAAEhT,CAAC,IAAK;UAC3CN,CAAC,CAACM,CAAC,CAAC2K,GAAG,CAAC,GAAGsI,CAAC,CAACjT,CAAC,CAACL,KAAK,CAAC;QACvB,CAAC,CAAC,EAAE;UACF0H,IAAI,EAAE,QAAQ;UACd1H,KAAK,EAAED;QACT,CAAC;MACH;QACE,MAAM,IAAI+S,EAAE,CAAC;UAAEvR,IAAI,EAAEzB,CAAC;UAAEyT,QAAQ,EAAE;QAAO,CAAC,CAAC;IAC/C;EACF,CAAC,EAAE,YAAY,CAAC;EAAED,CAAC,GAAG,eAAgBzT,CAAC,CAAEC,CAAC,IAAK;IAC7C,IAAI;QAAE4H,IAAI,EAAE3H,CAAC;QAAEyT,GAAG,EAAEnT;MAAE,CAAC,GAAGP,CAAC;MAAEQ,CAAC,GAAG,CAAC,CAAC;IACnC,QAAQ,OAAOD,CAAC,GAAG,GAAG,KAAKC,CAAC,CAACkT,GAAG,GAAGnT,CAAC,CAAC,EAAEP,CAAC,CAAC4H,IAAI;MAC3C,KAAK,SAAS;QACZ,OAAO;UAAE,GAAGpH,CAAC;UAAEoH,IAAI,EAAE,OAAO;UAAE1H,KAAK,EAAEF,CAAC,CAACE;QAAM,CAAC;MAChD,KAAK,QAAQ;MACb,KAAK,QAAQ;MACb,KAAK,QAAQ;MACb,KAAK,SAAS;QACZ,OAAO;UAAE,GAAGM,CAAC;UAAEoH,IAAI,EAAE3H;QAAE,CAAC;MAC1B,KAAK,OAAO;QACV,OAAO;UAAE,GAAGO,CAAC;UAAEoH,IAAI,EAAE,OAAO;UAAE1H,KAAK,EAAEF,CAAC,CAACiI,QAAQ,CAACuC,GAAG,CAACgJ,CAAC;QAAE,CAAC;MAC1D,KAAK,WAAW;QACd,OAAO;UAAE,GAAGhT,CAAC;UAAE,GAAG4S,EAAE,CAACpT,CAAC;QAAE,CAAC;MAC3B,KAAK,OAAO;QACV,OAAOA,CAAC,CAACiI,QAAQ,EAAE0L,KAAK,CAACV,EAAE,CAAC,GAAG;UAAE,GAAGzS,CAAC;UAAEoH,IAAI,EAAE,MAAM;UAAE1H,KAAK,EAAEF,CAAC,CAACiI,QAAQ,EAAEuC,GAAG,CAAC0I,EAAE;QAAE,CAAC,GAAG;UAAE,GAAG1S,CAAC;UAAEoH,IAAI,EAAE3H,CAAC;UAAEC,KAAK,EAAEF,CAAC,CAACiI,QAAQ,EAAEuC,GAAG,CAACgJ,CAAC;QAAE,CAAC;MAClI,KAAK,cAAc;QACjB,OAAO;UAAE,GAAGhT,CAAC;UAAEoH,IAAI,EAAE3H,CAAC;UAAEC,KAAK,EAAEF,CAAC,CAACiI,QAAQ,EAAEuC,GAAG,CAACgJ,CAAC;QAAE,CAAC;MACrD;QACE,OAAO;UAAE,GAAGhT,CAAC;UAAEoH,IAAI,EAAE,OAAO;UAAE1H,KAAK,EAAED;QAAE,CAAC;IAC5C;EACF,CAAC,EAAE,SAAS,CAAC;;AAEb;AACA,SAAS2T,CAACA,CAAC5T,CAAC,EAAE;EACZ,IAAI,CAACA,CAAC,IAAI,OAAOA,CAAC,IAAI,QAAQ,EAC5B,OAAO,CAAC,CAAC;EACX,IAAIC,CAAC,GAAGf,MAAM,CAACS,cAAc,CAACK,CAAC,CAAC;EAChC,OAAOC,CAAC,KAAK,IAAI,IAAIA,CAAC,KAAKf,MAAM,CAACW,SAAS,IAAIX,MAAM,CAACS,cAAc,CAACM,CAAC,CAAC,KAAK,IAAI,GAAGf,MAAM,CAACW,SAAS,CAAC6J,QAAQ,CAAChJ,IAAI,CAACV,CAAC,CAAC,KAAK,iBAAiB,GAC1I,CAAC,CAAC;AACJ;AACAD,CAAC,CAAC6T,CAAC,EAAE,eAAe,CAAC;;AAErB;AACA,SAASC,EAAEA,CAAC7T,CAAC,EAAEC,CAAC,EAAE;EAChB,IAAIM,CAAC,GAAG,CAAC,CAAC;IAAEC,CAAC,GAAGtB,MAAM,CAAC4U,IAAI,CAAC9T,CAAC,CAAC;EAC9B,KAAK,IAAIS,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,CAAC,CAACiC,MAAM,EAAEhC,CAAC,EAAE,EAAE;IACjC,IAAI4B,CAAC,GAAG7B,CAAC,CAACC,CAAC,CAAC;MAAE8B,CAAC,GAAGvC,CAAC,CAACqC,CAAC,CAAC;IACtB9B,CAAC,CAAC8B,CAAC,CAAC,GAAGpC,CAAC,CAACsC,CAAC,EAAEF,CAAC,EAAErC,CAAC,CAAC;EACnB;EACA,OAAOO,CAAC;AACV;AACAR,CAAC,CAAC8T,EAAE,EAAE,WAAW,CAAC;;AAElB;AACA,IAAIE,EAAE,GAAG,cAAc;EAAEC,EAAE,GAAG,eAAgBjU,CAAC,CAAEC,CAAC,IAAKA,CAAC,CAACmT,OAAO,CAACY,EAAE,EAAE,EAAE,CAAC,EAAE,YAAY,CAAC;EAAEE,EAAE,GAAG,eAAgBlU,CAAC,CAAEC,CAAC,IAAK+T,EAAE,CAAChR,IAAI,CAAC/C,CAAC,CAAC,EAAE;AACnI,OAAO,CAAC;EAAEkU,EAAE,GAAG,eAAgBnU,CAAC,CAAEC,CAAC,IAAK;IACtC,IAAIC,CAAC,GAAG+T,EAAE,CAAChU,CAAC,CAAC;IACb,OAAOiU,EAAE,CAACjU,CAAC,CAAC,IAAImU,MAAM,CAACC,KAAK,CAACD,MAAM,CAAClU,CAAC,CAAC,CAAC,GAAGA,CAAC,GAAGkU,MAAM,CAAClU,CAAC,CAAC;EACzD,CAAC,EAAE,cAAc,CAAC;;AAElB;AACA,IAAIoU,EAAE,GAAG,aAAa;EAAEC,CAAC,GAAG,eAAgBvU,CAAC,CAAEC,CAAC,IAAK;IACnD,IAAI;QAAE4H,IAAI,EAAE3H,CAAC;QAAEyT,GAAG,EAAEnT,CAAC;QAAEgU,QAAQ,EAAE/T,CAAC;QAAEN,KAAK,EAAEO;MAAE,CAAC,GAAGT,CAAC;MAAEqC,CAAC,GAAG,CAAC,CAAC;IAC1D,QAAQ,OAAO9B,CAAC,GAAG,GAAG,KAAK8B,CAAC,CAACqR,GAAG,GAAGnT,CAAC,CAAC,EAAEN,CAAC;MACtC,KAAK,MAAM;QAAE;UACX,IAAI0C,CAAC,GAAGnC,CAAC,GAAGC,CAAC,GAAGA,CAAC,CAAC+J,GAAG,CAAE3H,CAAC,IAAKqR,EAAE,CAACrR,CAAC,CAAC3C,KAAK,CAAC,CAAC;UACzC,OAAO;YAAE,GAAGmC,CAAC;YAAEuF,IAAI,EAAE3H,CAAC;YAAEC,KAAK,EAAEyC;UAAE,CAAC;QACpC;MACA,KAAK,QAAQ;MACb,KAAK,QAAQ;MACb,KAAK,QAAQ;QACX,OAAO;UAAE,GAAGN,CAAC;UAAEuF,IAAI,EAAE3H;QAAE,CAAC;MAC1B,KAAK,MAAM;QACT,OAAO;UAAE,GAAGoC,CAAC;UAAEuF,IAAI,EAAE;QAAW,CAAC;MACnC,KAAK,MAAM;MACX,KAAK,SAAS;QACZ,OAAO;UAAE,GAAGvF,CAAC;UAAEuF,IAAI,EAAE;QAAU,CAAC;MAClC,KAAK,SAAS;MACd,KAAK,OAAO;QACV,OAAO;UAAE,GAAGvF,CAAC;UAAEuF,IAAI,EAAE,OAAO;UAAE1H,KAAK,EAAEO,CAAC,IAAI6T,CAAC,CAAC7T,CAAC;QAAE,CAAC;MAClD,KAAK,QAAQ;QACX,OAAO;UAAE,GAAG4B,CAAC;UAAEuF,IAAI,EAAE3H;QAAE,CAAC;MAC1B,KAAK,UAAU;QACb,OAAO;UAAE,GAAGoC,CAAC;UAAEuF,IAAI,EAAE3H,CAAC;UAAEC,KAAK,EAAEoU,CAAC,CAAC7T,CAAC;QAAE,CAAC;MACvC,KAAK,OAAO;MACZ,KAAK,OAAO;QACV,IAAI8B,CAAC,GAAGsR,EAAE,CAACpT,CAAC,EAAGkC,CAAC,IAAK2R,CAAC,CAAC3R,CAAC,CAAC,CAAC;QAC1B,OAAO;UAAE,GAAGN,CAAC;UAAEuF,IAAI,EAAE,QAAQ;UAAE1H,KAAK,EAAEqC;QAAE,CAAC;MAC3C,KAAK,OAAO;QACV,OAAO;UAAE,GAAGF,CAAC;UAAEuF,IAAI,EAAE,OAAO;UAAE1H,KAAK,EAAEO,CAAC,CAAC+J,GAAG,CAAE7H,CAAC,IAAK2R,CAAC,CAAC3R,CAAC,CAAC;QAAE,CAAC;MAC3D,KAAK,YAAY;MACjB,KAAK,SAAS;MACd,KAAK,aAAa;MAClB;QAAS;UACP,IAAI1C,CAAC,EAAEuU,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,EACrB,IAAI;YACF,IAAI1R,CAAC,GAAG7C,CAAC,CAACwU,KAAK,CAAC,GAAG,CAAC,CAACjK,GAAG,CAAExH,CAAC,IAAK0R,IAAI,CAACnO,KAAK,CAACvD,CAAC,CAAC,CAAC;YAC9C,OAAO;cAAE,GAAGX,CAAC;cAAEuF,IAAI,EAAE,MAAM;cAAE1H,KAAK,EAAE4C;YAAE,CAAC;UACzC,CAAC,CAAC,MAAM,CACR;UACF,IAAIH,CAAC,GAAGlC,CAAC,GAAG,GAAGR,CAAC,IAAIQ,CAAC,GAAG,GAAGR,CAAC;YAAE4C,CAAC,GAAGwR,EAAE,CAACtR,IAAI,CAAC9C,CAAC,CAAC,GAAG,UAAU,GAAG,OAAO;UACnE,OAAO;YAAE,GAAGoC,CAAC;YAAEuF,IAAI,EAAE/E,CAAC;YAAE3C,KAAK,EAAEyC;UAAE,CAAC;QACpC;IACF;EACF,CAAC,EAAE,SAAS,CAAC;;AAEb;AACA,SAASoQ,oBAAoB,IAAI4B,EAAE,QAAQ,mCAAmC;AAC9E,IAAIC,EAAE,GAAG,eAAgB7U,CAAC,CAAEC,CAAC,IAAK;IAChC,QAAQA,CAAC,CAACyB,IAAI;MACZ,KAAK,UAAU;QACb,OAAO;UAAEmG,IAAI,EAAE;QAAW,CAAC;MAC7B,KAAK,QAAQ;QACX,IAAI3H,CAAC,GAAG,CAAC,CAAC;QACV,OAAOD,CAAC,CAACqT,SAAS,CAACC,UAAU,CAACC,OAAO,CAAEhT,CAAC,IAAK;UAC3CN,CAAC,CAACM,CAAC,CAAC2K,GAAG,CAAC,GAAG2J,CAAC,CAACtU,CAAC,CAACL,KAAK,CAAC;QACvB,CAAC,CAAC,EAAE;UACF0H,IAAI,EAAE,QAAQ;UACd1H,KAAK,EAAED;QACT,CAAC;MACH;QACE,MAAM,IAAI0U,EAAE,CAAC;UAAElT,IAAI,EAAEzB,CAAC;UAAEyT,QAAQ,EAAE;QAAa,CAAC,CAAC;IACrD;EACF,CAAC,EAAE,YAAY,CAAC;EAAEoB,CAAC,GAAG,eAAgB9U,CAAC,CAAEC,CAAC,IAAK;IAC7C,IAAI;QAAE4H,IAAI,EAAE3H,CAAC;QAAEyT,GAAG,EAAEnT;MAAE,CAAC,GAAGP,CAAC;MAAEQ,CAAC,GAAG,CAAC,CAAC;IACnC,QAAQ,OAAOD,CAAC,GAAG,GAAG,KAAKC,CAAC,CAACkT,GAAG,GAAGnT,CAAC,CAAC,EAAEP,CAAC,CAAC4H,IAAI;MAC3C,KAAK,QAAQ;MACb,KAAK,QAAQ;MACb,KAAK,QAAQ;MACb,KAAK,SAAS;QACZ,OAAO;UAAE,GAAGpH,CAAC;UAAEoH,IAAI,EAAE3H;QAAE,CAAC;MAC1B,KAAK,OAAO;QACV,OAAO;UAAE,GAAGO,CAAC;UAAEoH,IAAI,EAAE,OAAO;UAAE1H,KAAK,EAAEF,CAAC,CAACiI,QAAQ,CAACuC,GAAG,CAACqK,CAAC;QAAE,CAAC;MAC1D,KAAK,WAAW;QACd,OAAO;UAAE,GAAGrU,CAAC;UAAE,GAAGoU,EAAE,CAAC5U,CAAC;QAAE,CAAC;MAC3B,KAAK,OAAO;QACV,IAAIS,CAAC;QACL,OAAOT,CAAC,CAACiI,QAAQ,EAAE0L,KAAK,CAAEtR,CAAC,IAAKA,CAAC,CAACuF,IAAI,KAAK,SAAS,CAAC,GAAGnH,CAAC,GAAG;UAC1D,GAAGD,CAAC;UACJoH,IAAI,EAAE,MAAM;UACZ;UACA1H,KAAK,EAAEF,CAAC,CAACiI,QAAQ,EAAEuC,GAAG,CAAEnI,CAAC,IAAK6R,EAAE,CAAC7R,CAAC,CAACnC,KAAK,CAAC;QAC3C,CAAC,GAAGO,CAAC,GAAG;UAAE,GAAGD,CAAC;UAAEoH,IAAI,EAAE3H,CAAC;UAAEC,KAAK,EAAEF,CAAC,CAACiI,QAAQ,EAAEuC,GAAG,CAACqK,CAAC;QAAE,CAAC,EAAEpU,CAAC;MACzD,KAAK,cAAc;QACjB,OAAO;UAAE,GAAGD,CAAC;UAAEoH,IAAI,EAAE3H,CAAC;UAAEC,KAAK,EAAEF,CAAC,CAACiI,QAAQ,EAAEuC,GAAG,CAACqK,CAAC;QAAE,CAAC;MACrD;QACE,OAAO;UAAE,GAAGrU,CAAC;UAAEoH,IAAI,EAAE,OAAO;UAAE1H,KAAK,EAAED;QAAE,CAAC;IAC5C;EACF,CAAC,EAAE,SAAS,CAAC;;AAEb;AACA,IAAI6U,EAAE,GAAG,eAAgB/U,CAAC,CAAEC,CAAC,IAAK;EAChC,IAAI;IAAEyB,IAAI,EAAExB,CAAC;IAAE8U,MAAM,EAAExU,CAAC;IAAEyU,QAAQ,EAAExU;EAAE,CAAC,GAAGR,CAAC;EAC3C,IAAI;IACF,IAAIC,CAAC,IAAI,IAAI,EACX,OAAOqU,CAAC,CAACrU,CAAC,CAAC;IACb,IAAIM,CAAC,IAAI,IAAI,EACX,OAAOsU,CAAC,CAACtU,CAAC,CAAC;IACb,IAAIC,CAAC,IAAI,IAAI,EACX,OAAOgT,CAAC,CAAChT,CAAC,CAAC;EACf,CAAC,CAAC,OAAOC,CAAC,EAAE;IACVwU,OAAO,CAACC,KAAK,CAACzU,CAAC,CAAC;EAClB;EACA,OAAO,IAAI;AACb,CAAC,EAAE,SAAS,CAAC;;AAEb;AACA,IAAI0U,EAAE,GAAG,eAAgB,CAAE1U,CAAC,KAAMA,CAAC,CAAC2U,UAAU,GAAG,YAAY,EAAE3U,CAAC,CAAC4U,IAAI,GAAG,MAAM,EAAE5U,CAAC,CAAC6U,UAAU,GAAG,YAAY,EAAE7U,CAAC,CAAC8U,OAAO,GAAG,SAAS,EAAE9U,CAAC,CAAC,EAAE0U,EAAE,IAC1I,CAAC,CAAC,CAAC;;AAEH;AACA,IAAIK,EAAE,GAAG,CAAC,MAAM,EAAE,WAAW,CAAC;AAC9B,SAASC,CAACA,CAACzV,CAAC,EAAE;EACZ,OAAOwV,EAAE,CAACjN,IAAI,CAAEtI,CAAC,IAAKA,CAAC,KAAKD,CAAC,CAAC;AAChC;AACAD,CAAC,CAAC0V,CAAC,EAAE,2BAA2B,CAAC;;AAEjC;AACA,IAAIC,EAAE,GAAG,eAAgB3V,CAAC,CAAEC,CAAC,IAAK;EAChC,IAAI,CAACA,CAAC,EACJ,OAAO,EAAE;EACX,IAAI,OAAOA,CAAC,IAAI,QAAQ,EACtB,OAAOA,CAAC;EACV,MAAM,IAAI2B,KAAK,CAAC,sCAAsC+S,IAAI,CAACjC,SAAS,CAACzS,CAAC,CAAC,EAAE,CAAC;AAC5E,CAAC,EAAE,KAAK,CAAC;;AAET;AACA,SAAS2V,EAAEA,CAAC3V,CAAC,EAAE;EACb,OAAO,CAAC,CAACA,CAAC,CAAC4V,YAAY;AACzB;AACA7V,CAAC,CAAC4V,EAAE,EAAE,WAAW,CAAC;AAClB,SAASE,EAAEA,CAAC7V,CAAC,EAAE;EACb,OAAOA,CAAC,IAAI,IAAI,IAAId,MAAM,CAAC4U,IAAI,CAAC9T,CAAC,CAAC,CAACyC,MAAM,GAAG,CAAC;AAC/C;AACA1C,CAAC,CAAC8V,EAAE,EAAE,sBAAsB,CAAC;AAC7B,SAASC,EAAEA,CAAC9V,CAAC,EAAEC,CAAC,EAAE;EAChB,OAAO0V,EAAE,CAAC3V,CAAC,CAAC,GAAGA,CAAC,CAAC4V,YAAY,CAAC3V,CAAC,CAAC,GAAG,IAAI;AACzC;AACAF,CAAC,CAAC+V,EAAE,EAAE,kBAAkB,CAAC;AACzB,SAASC,EAAEA,CAAC/V,CAAC,EAAE;EACb,OAAO2V,EAAE,CAAC3V,CAAC,CAAC,GAAG0V,EAAE,CAAC1V,CAAC,CAAC4V,YAAY,CAACI,WAAW,CAAC,GAAG,EAAE;AACpD;AACAjW,CAAC,CAACgW,EAAE,EAAE,sBAAsB,CAAC;;AAE7B;AACA,IAAIE,CAAC;AACL,CAAC,UAASjW,CAAC,EAAE;EACXA,CAAC,CAACkW,KAAK,GAAG,KAAK,EAAElW,CAAC,CAACmW,OAAO,GAAG,MAAM,EAAEnW,CAAC,CAACoW,KAAK,GAAG,GAAG,EAAEpW,CAAC,CAACqW,GAAG,GAAG,IAAI;AAClE,CAAC,EAAEJ,CAAC,GAAGA,CAAC,KAAKA,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;;AAErB;AACA,SAASK,EAAEA,CAACtW,CAAC,EAAE;EACb,OAAO,OAAO,CAAC+C,IAAI,CAAC/C,CAAC,CAAC;AACxB;AACAD,CAAC,CAACuW,EAAE,EAAE,SAAS,CAAC;AAChB,SAASC,EAAEA,CAACvW,CAAC,EAAE;EACb,IAAIC,CAAC,GAAGD,CAAC,CAACwW,KAAK,CAAC,MAAM,CAAC;EACvB,OAAOvW,CAAC,IAAI,IAAI,GAAG,CAAC,EAAE,EAAED,CAAC,CAAC,GAAG,CAACA,CAAC,CAAC0C,KAAK,CAAC,CAACzC,CAAC,CAAC,CAAC,CAAC,CAACwC,MAAM,CAAC,EAAEzC,CAAC,CAAC0C,KAAK,CAAC,CAAC,EAAE,CAACzC,CAAC,CAAC,CAAC,CAAC,CAACwC,MAAM,CAAC,CAAC;AAChF;AACA1C,CAAC,CAACwW,EAAE,EAAE,SAAS,CAAC;AAChB,SAASE,CAACA,CAACzW,CAAC,EAAE;EACZ,IAAIC,CAAC,GAAGD,CAAC,CAACwW,KAAK,CAAC,MAAM,CAAC;EACvB,OAAOvW,CAAC,IAAI,IAAI,GAAG,CAAC,EAAE,EAAED,CAAC,CAAC,GAAG,CAACA,CAAC,CAAC0C,KAAK,CAAC,CAAC,EAAEzC,CAAC,CAAC,CAAC,CAAC,CAACwC,MAAM,CAAC,EAAEzC,CAAC,CAAC0C,KAAK,CAACzC,CAAC,CAAC,CAAC,CAAC,CAACwC,MAAM,CAAC,CAAC;AAC9E;AACA1C,CAAC,CAAC0W,CAAC,EAAE,YAAY,CAAC;AAClB,SAASC,EAAEA,CAAC1W,CAAC,EAAE;EACb,OAAOA,CAAC,CAACyU,KAAK,CAAC,IAAI,CAAC;AACtB;AACA1U,CAAC,CAAC2W,EAAE,EAAE,YAAY,CAAC;AACnB,SAASC,EAAEA,CAAC3W,CAAC,GAAG,CAAC,CAAC,EAAE;EAClB,OAAOd,MAAM,CAAC+E,MAAM,CAAC;IAAE2S,GAAG,EAAE,EAAE;IAAEhP,IAAI,EAAE,EAAE;IAAEnG,IAAI,EAAE,EAAE;IAAEsK,QAAQ,EAAE,CAAC,CAAC;IAAEiK,WAAW,EAAE,EAAE;IAAEa,QAAQ,EAAE,EAAE;IAAEC,MAAM,EAAE;EAAG,CAAC,EAAE9W,CAAC,CAAC;AACnH;AACAD,CAAC,CAAC4W,EAAE,EAAE,UAAU,CAAC;AACjB,SAASI,EAAEA,CAAC/W,CAAC,GAAG,CAAC,CAAC,EAAE;EAClB,OAAOd,MAAM,CAAC+E,MAAM,CAAC;IAAEiS,KAAK,EAAE,EAAE;IAAEc,SAAS,EAAE,EAAE;IAAEC,aAAa,EAAE,EAAE;IAAEL,GAAG,EAAE,EAAE;IAAEM,OAAO,EAAE,EAAE;IAAEtP,IAAI,EAAE,EAAE;IAAEuP,QAAQ,EAAE,EAAE;IAAE1V,IAAI,EAAE,EAAE;IAAE2V,QAAQ,EAAE,EAAE;IAAEpB,WAAW,EAAE,EAAE;IACzJK,GAAG,EAAE,EAAE;IAAEgB,OAAO,EAAE;EAAG,CAAC,EAAErX,CAAC,CAAC;AAC5B;AACAD,CAAC,CAACgX,EAAE,EAAE,YAAY,CAAC;;AAEnB;AACA,IAAIO,EAAE,GAAG,OAAO;AAChB,SAASC,EAAEA,CAAC;EAAEC,KAAK,EAAExX,CAAC,GAAG;AAAM,CAAC,GAAG,CAAC,CAAC,EAAE;EACrC,IAAIC,CAAC,GAAGwX,EAAE,CAACzX,CAAC,CAAC;IAAEO,CAAC,GAAG,eAAgBR,CAAC,CAAC,CAACS,CAAC,EAAEC,CAAC,KAAKR,CAAC,CAACO,CAAC,CAAC,GAAG,CAACC,CAAC,GAAGA,CAAC,EAAE,aAAa,CAAC;EAC5E,OAAO,eAAgBV,CAAC,CAAC,UAASU,CAAC,EAAE;IACnC,IAAI4B,CAAC,GAAG,CAAC,EAAE,CAAC;MAAEE,CAAC,GAAG,CAAC,CAAC;IACpB,KAAK,IAAII,CAAC,IAAIlC,CAAC,EACb6W,EAAE,CAACvU,IAAI,CAACJ,CAAC,CAAC+U,MAAM,CAAC1B,WAAW,CAAC,IAAI,CAACzT,CAAC,GAAGF,CAAC,CAACiG,IAAI,CAAC,CAAC3F,CAAC,CAAC,CAAC,GAAGN,CAAC,CAACA,CAAC,CAACI,MAAM,GAAG,CAAC,CAAC,CAAC6F,IAAI,CAAC3F,CAAC,CAAC,EAAEJ,CAAC,GAAGhC,CAAC,CAACoC,CAAC,CAAC+U,MAAM,CAAC1B,WAAW,EAAEzT,CAAC,CAAC;IAC7G,OAAOF,CAAC;EACV,CAAC,EAAE,YAAY,CAAC;AAClB;AACAtC,CAAC,CAACwX,EAAE,EAAE,WAAW,CAAC;AAClB,SAASE,EAAEA,CAACzX,CAAC,EAAE;EACb,OAAO,OAAOA,CAAC,IAAI,QAAQ,GAAIC,CAAC,IAAKA,CAAC,CAACwU,KAAK,CAACzU,CAAC,CAAC,CAACyC,MAAM,GAAG,CAAC,KAAK,CAAC,GAAGzC,CAAC;AACtE;AACAD,CAAC,CAAC0X,EAAE,EAAE,WAAW,CAAC;;AAElB;AACA,SAASE,EAAEA,CAAC;EAAEC,SAAS,EAAE5X,CAAC,GAAG,CAAC;EAAE6X,OAAO,EAAE5X,CAAC,GAAGgW;AAAE,CAAC,GAAG,CAAC,CAAC,EAAE;EACrD,IAAI1V,CAAC,GAAG,IAAI;IAAEC,CAAC,GAAGR,CAAC;EACnB,OAAO,eAAgBD,CAAC,CAAC,UAASsC,CAAC,EAAE;IACnC,IAAIE,CAAC,GAAGF,CAAC;MAAEM,CAAC,GAAGoU,EAAE,CAAC,CAAC;IACnB,IAAI,CAACpU,CAAC,CAAC0U,OAAO,EAAE9U,CAAC,CAAC,GAAGgU,EAAE,CAAChU,CAAC,CAAC,EAAE,CAACI,CAAC,CAACuT,KAAK,EAAE3T,CAAC,CAAC,GAAGkU,CAAC,CAAClU,CAAC,CAAC,EAAEhC,CAAC,KAAK,IAAI,IAAIgC,CAAC,CAACD,UAAU,CAACrC,CAAC,CAACiW,KAAK,CAAC,IAAI,CAAC3T,CAAC,CAACD,UAAU,CAACrC,CAAC,CAACkW,OAAO,CAAC,KAAK5V,CAAC,GAAG,EAAE,EAAEoC,CAAC,CAACqU,SAAS,GACxIzU,CAAC,CAACG,KAAK,CAAC,CAAC,EAAEzC,CAAC,CAACiW,KAAK,CAACzT,MAAM,CAAC,EAAEF,CAAC,GAAGA,CAAC,CAACG,KAAK,CAACzC,CAAC,CAACiW,KAAK,CAACzT,MAAM,CAAC,EAAE,CAACE,CAAC,CAACsU,aAAa,EAAE1U,CAAC,CAAC,GAAGkU,CAAC,CAAClU,CAAC,CAAC,CAAC,EAAEhC,CAAC,KAAK,IAAI,EAC/F,OAAOC,CAAC,EAAE,EAAE,IAAI;IAClB,IAAIqC,CAAC,GAAGN,CAAC,CAACuV,SAAS,CAAC,CAAC,CAACC,QAAQ,CAAC9X,CAAC,CAACoW,GAAG,CAAC;IACrC,IAAI1T,CAAC,CAACqU,SAAS,KAAK,EAAE,IAAIzU,CAAC,CAACD,UAAU,CAACrC,CAAC,CAACmW,KAAK,CAAC,IAAI,CAAC7T,CAAC,CAACD,UAAU,CAACrC,CAAC,CAACoW,GAAG,CAAC,KAAK1T,CAAC,CAACqU,SAAS,GAAG/W,CAAC,CAACmW,KAAK,EAAE7T,CAAC,GAAGA,CAAC,CAACG,KAAK,CAACzC,CAAC,CAACmW,KAAK,CAAC3T,MAAM,CAAC,EAAE,CAACE,CAAC,CAACsU,aAAa,EAChJ1U,CAAC,CAAC,GAAGkU,CAAC,CAAClU,CAAC,CAAC,CAAC,EAAEM,CAAC,EAAE;MACb,IAAIC,CAAC,GAAGP,CAAC,CAACuV,SAAS,CAAC,CAAC;MACrBnV,CAAC,CAAC0T,GAAG,GAAG9T,CAAC,CAACG,KAAK,CAACI,CAAC,CAACL,MAAM,GAAGxC,CAAC,CAACoW,GAAG,CAAC5T,MAAM,CAAC,EAAEF,CAAC,GAAGO,CAAC,CAACJ,KAAK,CAAC,CAAC,EAAE,CAACzC,CAAC,CAACoW,GAAG,CAAC5T,MAAM,CAAC;IACzE;IACA,IAAIE,CAAC,CAACqT,WAAW,GAAGzT,CAAC,EAAEhC,CAAC,CAAC+H,IAAI,CAAC;MAAE0J,MAAM,EAAExR,CAAC;MAAEsW,MAAM,EAAEzU,CAAC;MAAEqV,MAAM,EAAE/U;IAAE,CAAC,CAAC,EAAEnC,CAAC,EAAE,EAAEqC,CAAC,EAAE;MAC1E,IAAIC,CAAC,GAAGvC,CAAC,CAACmC,KAAK,CAAC,CAAC;MACjB,OAAOnC,CAAC,GAAG,IAAI,EAAEuC,CAAC;IACpB;IACA,OAAO,IAAI;EACb,CAAC,EAAE,aAAa,CAAC;AACnB;AACA/C,CAAC,CAAC4X,EAAE,EAAE,WAAW,CAAC;;AAElB;AACA,SAASK,EAAEA,CAAC;EAAEC,UAAU,EAAEjY;AAAE,CAAC,EAAE;EAC7B,OAAO,eAAgBD,CAAC,CAAC,UAASQ,CAAC,EAAE;IACnC,IAAIC,CAAC;IACL,IAAIC,CAAC,GAAGkW,EAAE,CAAC;MAAEG,MAAM,EAAEvW;IAAE,CAAC,CAAC;IACzB,KAAK,IAAI8B,CAAC,IAAIrC,CAAC,EACb,IAAIS,CAAC,GAAG4B,CAAC,CAAC5B,CAAC,CAAC,EAAE,EAAE,CAACD,CAAC,GAAGC,CAAC,CAACoW,QAAQ,CAACpW,CAAC,CAACoW,QAAQ,CAACpU,MAAM,GAAG,CAAC,CAAC,MAAM,IAAI,IAAIjC,CAAC,KAAK,KAAK,CAAC,CAAC,IAAIA,CAAC,CAAC0X,QAAQ,EAC7F;IACJ,OAAOzX,CAAC;EACV,CAAC,EAAE,WAAW,CAAC;AACjB;AACAV,CAAC,CAACiY,EAAE,EAAE,WAAW,CAAC;;AAElB;AACA,SAASG,EAAEA,CAAA,EAAG;EACZ,OAAQnY,CAAC,IAAK;IACZ,IAAI;QAAE0X,MAAM,EAAEzX;MAAE,CAAC,GAAGD,CAAC,CAAC8W,MAAM,CAAC,CAAC,CAAC;MAAEvW,CAAC,GAAGN,CAAC,CAAC+V,WAAW,CAACQ,KAAK,CAAC,kBAAkB,CAAC;IAC5E,OAAOjW,CAAC,KAAK,IAAI,IAAIP,CAAC,CAAC6W,QAAQ,CAACvO,IAAI,CAAC;MACnC8P,IAAI,EAAE,iBAAiB;MACvBC,OAAO,EAAE,kCAAkC;MAC3CC,IAAI,EAAEtY,CAAC,CAAC8W,MAAM,CAAC,CAAC,CAAC,CAAC9E,MAAM;MACxBkG,QAAQ,EAAE,CAAC;IACb,CAAC,CAAC,EAAElY,CAAC,KAAKC,CAAC,CAAC2W,GAAG,GAAGrW,CAAC,CAAC,CAAC,CAAC,EAAEN,CAAC,CAACiX,OAAO,GAAG3W,CAAC,CAAC,CAAC,CAAC,EAAEN,CAAC,CAAC+V,WAAW,GAAG/V,CAAC,CAAC+V,WAAW,CAACtT,KAAK,CAACnC,CAAC,CAAC,CAAC,CAAC,CAACkC,MAAM,CAAC,EAAEzC,CAAC,CAAC4W,GAAG,GAAGrW,CAAC,CAAC,CAAC,CAAC,EAAEP,CAAC,CAAC;EAC9G,CAAC;AACH;AACAD,CAAC,CAACoY,EAAE,EAAE,cAAc,CAAC;;AAErB;AACA,SAASI,EAAEA,CAACvY,CAAC,GAAG,SAAS,EAAE;EACzB,IAAIC,CAAC,GAAGuY,EAAE,CAACxY,CAAC,CAAC;EACb,OAAQO,CAAC,IAAK;IACZ,IAAIC,CAAC,GAAG,CAAC;MAAEC,CAAC,GAAG,EAAE;IACjB,KAAK,IAAI,CAACkC,CAAC,EAAE;MAAE+U,MAAM,EAAE7U;IAAE,CAAC,CAAC,IAAItC,CAAC,CAACuW,MAAM,CAACxF,OAAO,CAAC,CAAC,EAAE;MACjD,IAAIxO,CAAC,GAAG,EAAE;MACV,IAAIH,CAAC,KAAK,CAAC,IAAIE,CAAC,CAACmT,WAAW,CAAC,CAAC,CAAC,KAAK,GAAG,EACrC,OAAOzV,CAAC;MACV,KAAK,IAAIyC,CAAC,IAAIH,CAAC,CAACmT,WAAW,EACzB,IAAIhT,CAAC,KAAK,GAAG,IAAIxC,CAAC,EAAE,EAAEwC,CAAC,KAAK,GAAG,IAAIxC,CAAC,EAAE,EAAEsC,CAAC,IAAIE,CAAC,EAAExC,CAAC,KAAK,CAAC,EACrD;MACJ,IAAIC,CAAC,CAAC6H,IAAI,CAAC,CAACzF,CAAC,EAAEC,CAAC,CAAC,CAAC,EAAEtC,CAAC,KAAK,CAAC,EACzB;IACJ;IACA,IAAIA,CAAC,KAAK,CAAC,EACT,OAAOD,CAAC,CAACsW,QAAQ,CAACvO,IAAI,CAAC;MACrB8P,IAAI,EAAE,4BAA4B;MAClCC,OAAO,EAAE,kBAAkB;MAC3BC,IAAI,EAAE/X,CAAC,CAACuW,MAAM,CAAC,CAAC,CAAC,CAAC9E,MAAM;MACxBkG,QAAQ,EAAE,CAAC;IACb,CAAC,CAAC,EAAE3X,CAAC;IACP,IAAI8B,CAAC,GAAG,EAAE;MAAEE,CAAC,GAAG9B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAACwW,aAAa,CAACxU,MAAM;IAC5C,KAAK,IAAI,CAACE,CAAC,EAAE,CAACE,CAAC,EAAEC,CAAC,CAAC,CAAC,IAAIrC,CAAC,CAAC6Q,OAAO,CAAC,CAAC,EACjCzO,CAAC,CAACpB,IAAI,GAAGqB,CAAC,EAAEH,CAAC,GAAG,CAAC,KAAKE,CAAC,CAACpB,IAAI,GAAGoB,CAAC,CAACoU,aAAa,CAACvU,KAAK,CAACH,CAAC,CAAC,GAAGO,CAAC,EAAED,CAAC,CAACoU,aAAa,GAAGpU,CAAC,CAACoU,aAAa,CAACvU,KAAK,CAAC,CAAC,EAAEH,CAAC,CAAC,CAAC,EAAE,CAACM,CAAC,CAACuU,QAAQ,EAAEvU,CAAC,CAACmT,WAAW,CAAC,GACxIS,CAAC,CAAC5T,CAAC,CAACmT,WAAW,CAACtT,KAAK,CAACI,CAAC,CAACL,MAAM,CAAC,CAAC,EAAEJ,CAAC,CAACiG,IAAI,CAACzF,CAAC,CAACpB,IAAI,CAAC;IAClD,OAAOY,CAAC,CAAC,CAAC,CAAC,GAAGA,CAAC,CAAC,CAAC,CAAC,CAACK,KAAK,CAAC,CAAC,CAAC,EAAEL,CAAC,CAACA,CAAC,CAACI,MAAM,GAAG,CAAC,CAAC,GAAGJ,CAAC,CAACA,CAAC,CAACI,MAAM,GAAG,CAAC,CAAC,CAACC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAEnC,CAAC,CAACkB,IAAI,GAAGxB,CAAC,CAACoC,CAAC,CAAC,EAAE9B,CAAC;EAC/F,CAAC;AACH;AACAR,CAAC,CAACwY,EAAE,EAAE,eAAe,CAAC;AACtB,IAAIE,EAAE,GAAG,eAAgB1Y,CAAC,CAAEC,CAAC,IAAKA,CAAC,CAAC+D,IAAI,CAAC,CAAC,EAAE,MAAM,CAAC;AACnD,SAASyU,EAAEA,CAACxY,CAAC,EAAE;EACb,OAAOA,CAAC,KAAK,SAAS,GAAIC,CAAC,IAAKA,CAAC,CAACuK,GAAG,CAACiO,EAAE,CAAC,CAACtN,IAAI,CAAC,EAAE,CAAC,GAAGnL,CAAC,KAAK,UAAU,GAAIC,CAAC,IAAKA,CAAC,CAACkL,IAAI,CAAC;AACxF,CAAC,CAAC,GAAGnL,CAAC;AACN;AACAD,CAAC,CAACyY,EAAE,EAAE,WAAW,CAAC;;AAElB;AACA,IAAIE,EAAE,GAAG,eAAgB3Y,CAAC,CAAEC,CAAC,IAAKA,CAAC,IAAIA,CAAC,CAACsC,UAAU,CAAC,GAAG,CAAC,IAAItC,CAAC,CAAC+X,QAAQ,CAAC,GAAG,CAAC,EAAE,UAAU,CAAC;AACxF,SAASY,EAAEA,CAAA,EAAG;EACZ,IAAI3Y,CAAC,GAAG,eAAgBD,CAAC,CAAC,CAACE,CAAC,EAAE;IAAEyX,MAAM,EAAEnX;EAAE,CAAC,EAAEC,CAAC,KAAKD,CAAC,CAACkB,IAAI,KAAK,EAAE,GAAGxB,CAAC,GAAGO,CAAC,EAAE,SAAS,CAAC;EACpF,OAAQP,CAAC,IAAK;IACZ,IAAI;QAAEyX,MAAM,EAAEnX;MAAE,CAAC,GAAGN,CAAC,CAAC6W,MAAM,CAAC7W,CAAC,CAAC6W,MAAM,CAAC8B,MAAM,CAAC5Y,CAAC,EAAE,CAAC,CAAC,CAAC;MAAEQ,CAAC,GAAGD,CAAC,CAACyV,WAAW,CAAC6C,QAAQ,CAAC,CAAC;MAAEpY,CAAC,GAAGD,CAAC,CAACiU,KAAK,CAAC,GAAG,CAAC;IACnG,IAAIhU,CAAC,CAACgC,MAAM,GAAG,CAAC,IAAIhC,CAAC,CAAC,CAAC,CAAC,KAAK,EAAE,IAAIA,CAAC,CAACgC,MAAM,GAAG,CAAC,KAAK,CAAC,EACnD,OAAOxC,CAAC,CAAC2H,IAAI,GAAGnH,CAAC,CAAC,CAAC,CAAC,EAAEF,CAAC,CAACqH,IAAI,GAAG,IAAInH,CAAC,CAAC,CAAC,CAAC,GAAG,EAAE,CAACF,CAAC,CAAC4W,QAAQ,EAAE5W,CAAC,CAACyV,WAAW,CAAC,GAAGS,CAAC,CAACjW,CAAC,CAACkC,KAAK,CAACnC,CAAC,CAACqH,IAAI,CAACnF,MAAM,CAAC,CAAC,EAAExC,CAAC;IACxG,IAAIoC,CAAC,GAAG,CAAC;MAAEE,CAAC,GAAG,EAAE;MAAEI,CAAC,GAAG,CAAC,CAAC;MAAEE,CAAC;IAC5B,KAAK,IAAIG,CAAC,IAAIxC,CAAC,EAAE;MACf,IAAI6B,CAAC,KAAK,CAAC,IAAIiU,EAAE,CAACtT,CAAC,CAAC,EAClB;MACFA,CAAC,KAAK,GAAG,IAAIX,CAAC,EAAE,EAAEW,CAAC,KAAK,GAAG,IAAIX,CAAC,EAAE,EAAEE,CAAC,IAAIS,CAAC;IAC5C;IACA,IAAIX,CAAC,KAAK,CAAC,EACT,OAAOpC,CAAC,CAAC4W,QAAQ,CAACvO,IAAI,CAAC;MACrB8P,IAAI,EAAE,6BAA6B;MACnCC,OAAO,EAAE,mBAAmB;MAC5BC,IAAI,EAAErY,CAAC,CAAC6W,MAAM,CAAC,CAAC,CAAC,CAAC9E,MAAM;MACxBkG,QAAQ,EAAE,CAAC;IACb,CAAC,CAAC,EAAEjY,CAAC;IACP,IAAI6C,CAAC,GAAGP,CAAC;IACT,IAAIA,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,IAAIA,CAAC,CAACA,CAAC,CAACE,MAAM,GAAG,CAAC,CAAC,KAAK,GAAG,EAAE;MAC3CE,CAAC,GAAG,CAAC,CAAC,EAAEJ,CAAC,GAAGA,CAAC,CAACG,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;MAC1B,IAAIM,CAAC,GAAGT,CAAC,CAACkS,KAAK,CAAC,GAAG,CAAC;MACpB,IAAIlS,CAAC,GAAGS,CAAC,CAAC,CAAC,CAAC,CAACe,IAAI,CAAC,CAAC,EAAEf,CAAC,CAAC,CAAC,CAAC,KAAK,KAAK,CAAC,KAAKH,CAAC,GAAGG,CAAC,CAACN,KAAK,CAAC,CAAC,CAAC,CAACyI,IAAI,CAAC,GAAG,CAAC,CAACpH,IAAI,CAAC,CAAC,CAAC,EAAExB,CAAC,KAAK,EAAE,EACjF,OAAOtC,CAAC,CAAC4W,QAAQ,CAACvO,IAAI,CAAC;QACrB8P,IAAI,EAAE,sBAAsB;QAC5BC,OAAO,EAAE,YAAY;QACrBC,IAAI,EAAErY,CAAC,CAAC6W,MAAM,CAAC,CAAC,CAAC,CAAC9E,MAAM;QACxBkG,QAAQ,EAAE,CAAC;MACb,CAAC,CAAC,EAAEjY,CAAC;MACP,IAAI4C,CAAC,KAAK,EAAE,EACV,OAAO5C,CAAC,CAAC4W,QAAQ,CAACvO,IAAI,CAAC;QACrB8P,IAAI,EAAE,yBAAyB;QAC/BC,OAAO,EAAE,qBAAqB;QAC9BC,IAAI,EAAErY,CAAC,CAAC6W,MAAM,CAAC,CAAC,CAAC,CAAC9E,MAAM;QACxBkG,QAAQ,EAAE,CAAC;MACb,CAAC,CAAC,EAAEjY,CAAC;MACP,IAAI,CAACyY,EAAE,CAAC7V,CAAC,CAAC,IAAI,QAAQ,CAACE,IAAI,CAACF,CAAC,CAAC,EAC5B,OAAO5C,CAAC,CAAC4W,QAAQ,CAACvO,IAAI,CAAC;QACrB8P,IAAI,EAAE,2BAA2B;QACjCC,OAAO,EAAE,8BAA8B;QACvCC,IAAI,EAAErY,CAAC,CAAC6W,MAAM,CAAC,CAAC,CAAC,CAAC9E,MAAM;QACxBkG,QAAQ,EAAE,CAAC;MACb,CAAC,CAAC,EAAEjY,CAAC;IACT;IACA,OAAOA,CAAC,CAAC8L,QAAQ,GAAGpJ,CAAC,EAAE1C,CAAC,CAAC2H,IAAI,GAAGrF,CAAC,EAAEhC,CAAC,CAACqH,IAAI,GAAG9E,CAAC,EAAED,CAAC,KAAK,KAAK,CAAC,KAAK5C,CAAC,CAAC6Y,OAAO,GAAGjW,CAAC,CAAC,EAAE,CAACtC,CAAC,CAAC4W,QAAQ,EAAE5W,CAAC,CAACyV,WAAW,CAAC,GAAGS,CAAC,CAACjW,CAAC,CAACkC,KAAK,CAACnC,CAAC,CAACqH,IAAI,CAACnF,MAAM,CAAC,CAAC,EACvIxC,CAAC;EACH,CAAC;AACH;AACAF,CAAC,CAAC4Y,EAAE,EAAE,eAAe,CAAC;;AAEtB;AACA,SAASI,EAAEA,CAAC/Y,CAAC,GAAG,SAAS,EAAEC,CAAC,GAAGgW,CAAC,EAAE;EAChC,IAAI1V,CAAC,GAAGyY,EAAE,CAAChZ,CAAC,CAAC;EACb,OAAQQ,CAAC,KAAMA,CAAC,CAACwV,WAAW,GAAGzV,CAAC,CAACC,CAAC,CAACsW,MAAM,EAAE7W,CAAC,CAAC,EAAEO,CAAC,CAAC;AACnD;AACAT,CAAC,CAACgZ,EAAE,EAAE,sBAAsB,CAAC;AAC7B,SAASC,EAAEA,CAAChZ,CAAC,EAAE;EACb,OAAOA,CAAC,KAAK,SAAS,GAAGiZ,EAAE,GAAGjZ,CAAC,KAAK,UAAU,GAAGkZ,EAAE,GAAGlZ,CAAC;AACzD;AACAD,CAAC,CAACiZ,EAAE,EAAE,WAAW,CAAC;AAClB,SAASC,EAAEA,CAACjZ,CAAC,EAAEC,CAAC,GAAGgW,CAAC,EAAE;EACpB,OAAOjW,CAAC,CAACwK,GAAG,CAAC,CAAC;IAAEkN,MAAM,EAAE;MAAE1B,WAAW,EAAEzV;IAAE;EAAE,CAAC,KAAKA,CAAC,CAACwD,IAAI,CAAC,CAAC,CAAC,CAACoV,MAAM,CAAE5Y,CAAC,IAAKA,CAAC,KAAK,EAAE,CAAC,CAAC4K,IAAI,CAAC,GAAG,CAAC;AAC9F;AACApL,CAAC,CAACkZ,EAAE,EAAE,eAAe,CAAC;AACtB,IAAIG,EAAE,GAAG,eAAgBrZ,CAAC,CAAC,CAACC,CAAC,EAAE;IAAE0X,MAAM,EAAEzX;EAAE,CAAC,EAAEM,CAAC,KAAKN,CAAC,CAACwB,IAAI,KAAK,EAAE,GAAGzB,CAAC,GAAGO,CAAC,EAAE,QAAQ,CAAC;EAAE8Y,EAAE,GAAG,eAAgBtZ,CAAC,CAAC,CAAC;IAAE2X,MAAM,EAAE1X;EAAE,CAAC,KAAK,CAACA,CAAC,CAACgX,SAAS,KAC5I,EAAE,GAAGhX,CAAC,CAACkW,KAAK,GAAGlW,CAAC,CAACiX,aAAa,CAACvU,KAAK,CAAC,CAAC,CAAC,IAAI1C,CAAC,CAACgW,WAAW,EAAE,gBAAgB,CAAC;AAC3E,SAASkD,EAAEA,CAAClZ,CAAC,EAAEC,CAAC,GAAGgW,CAAC,EAAE;EACpB,IAAIjW,CAAC,CAACyC,MAAM,KAAK,CAAC,EAChB,OAAO,EAAE;EACXzC,CAAC,CAAC,CAAC,CAAC,CAAC0X,MAAM,CAAC1B,WAAW,KAAK,EAAE,IAAIhW,CAAC,CAAC,CAAC,CAAC,CAAC0X,MAAM,CAACV,SAAS,KAAK/W,CAAC,CAACiW,KAAK,KAAKlW,CAAC,GAAGA,CAAC,CAAC0C,KAAK,CAAC,CAAC,CAAC,CAAC;EACvF,IAAInC,CAAC,GAAGP,CAAC,CAACA,CAAC,CAACyC,MAAM,GAAG,CAAC,CAAC;EACvB,OAAOlC,CAAC,KAAK,KAAK,CAAC,IAAIA,CAAC,CAACmX,MAAM,CAAC1B,WAAW,KAAK,EAAE,IAAIzV,CAAC,CAACmX,MAAM,CAACrB,GAAG,CAAC0B,QAAQ,CAAC9X,CAAC,CAACoW,GAAG,CAAC,KAAKrW,CAAC,GAAGA,CAAC,CAAC0C,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE1C,CAAC,GAAGA,CAAC,CAAC0C,KAAK,CAAC1C,CAAC,CAAC4Y,MAAM,CAACQ,EAAE,EAAE,CAAC,CAAC,CAAC,EAAEpZ,CAAC,CAC3IwK,GAAG,CAAC6O,EAAE,CAAC,CAAClO,IAAI,CAAC;AACf,CAAC,CAAC;AACF;AACApL,CAAC,CAACmZ,EAAE,EAAE,gBAAgB,CAAC;;AAEvB;AACA,SAASI,EAAEA,CAAC;EAAE1B,SAAS,EAAE5X,CAAC,GAAG,CAAC;EAAEwX,KAAK,EAAEvX,CAAC,GAAG,KAAK;EAAEsZ,OAAO,EAAEhZ,CAAC,GAAG,SAAS;EAAEsX,OAAO,EAAErX,CAAC,GAAGyV,CAAC;EAAEgC,UAAU,EAAExX,CAAC,GAAG,CACxG0X,EAAE,CAAC,CAAC,EACJI,EAAE,CAAChY,CAAC,CAAC,EACLoY,EAAE,CAAC,CAAC,EACJI,EAAE,CAACxY,CAAC,CAAC;AACL,CAAC,GAAG,CAAC,CAAC,EAAE;EACR,IAAIP,CAAC,GAAG,CAAC,IAAIA,CAAC,GAAG,CAAC,GAAG,CAAC,EACpB,MAAM,IAAI2B,KAAK,CAAC,mBAAmB,CAAC;EACtC,IAAIU,CAAC,GAAGsV,EAAE,CAAC;MAAEC,SAAS,EAAE5X,CAAC;MAAE6X,OAAO,EAAErX;IAAE,CAAC,CAAC;IAAE+B,CAAC,GAAGgV,EAAE,CAAC;MAAEC,KAAK,EAAEvX;IAAE,CAAC,CAAC;IAAE0C,CAAC,GAAGqV,EAAE,CAAC;MAAEC,UAAU,EAAExX;IAAE,CAAC,CAAC;IAAEoC,CAAC,GAAGmW,EAAE,CAACzY,CAAC,CAAC;EACpG,OAAO,UAASuC,CAAC,EAAE;IACjB,IAAIE,CAAC,GAAG,EAAE;IACV,KAAK,IAAIC,EAAE,IAAIyT,EAAE,CAAC5T,CAAC,CAAC,EAAE;MACpB,IAAIK,CAAC,GAAGd,CAAC,CAACY,EAAE,CAAC;MACb,IAAIE,CAAC,KAAK,IAAI,EACZ;MACF,IAAIC,CAAC,GAAGb,CAAC,CAACY,CAAC,CAAC;QAAEE,CAAC,GAAGD,CAAC,CAACV,KAAK,CAAC,CAAC,CAAC,CAAC8H,GAAG,CAAC7H,CAAC,CAAC;MACnCK,CAAC,CAACsF,IAAI,CAAC;QACL0N,WAAW,EAAEnT,CAAC,CAACO,CAAC,CAAC,CAAC,CAAC,EAAE5C,CAAC,CAAC;QACvBgZ,IAAI,EAAEnW,CAAC;QACPyT,MAAM,EAAE3T,CAAC;QACT0T,QAAQ,EAAExT,CAAC,CAACuV,MAAM,CAAC,CAACtV,EAAE,EAAEC,EAAE,KAAKD,EAAE,CAACmW,MAAM,CAAClW,EAAE,CAACsT,QAAQ,CAAC,EAAE,EAAE;MAC3D,CAAC,CAAC;IACJ;IACA,OAAO7T,CAAC;EACV,CAAC;AACH;AACAjD,CAAC,CAACuZ,EAAE,EAAE,WAAW,CAAC;;AAElB;AACA,SAASI,EAAEA,CAAC1Z,CAAC,EAAE;EACb,OAAOA,CAAC,CAACkW,KAAK,GAAGlW,CAAC,CAACgX,SAAS,GAAGhX,CAAC,CAACiX,aAAa,GAAGjX,CAAC,CAAC4W,GAAG,GAAG5W,CAAC,CAACkX,OAAO,GAAGlX,CAAC,CAACyB,IAAI,GAAGzB,CAAC,CAACoX,QAAQ,GAAGpX,CAAC,CAAC4H,IAAI,GAAG5H,CAAC,CAACmX,QAAQ,GAAGnX,CAAC,CAACgW,WAAW,GAAGhW,CAAC,CAACqW,GAAG,GAAGrW,CAAC,CAC1IqX,OAAO;AACT;AACAtX,CAAC,CAAC2Z,EAAE,EAAE,MAAM,CAAC;AACb,SAASC,EAAEA,CAAA,EAAG;EACZ,OAAQ3Z,CAAC,IAAKA,CAAC,CAAC8W,MAAM,CAACtM,GAAG,CAAC,CAAC;IAAEkN,MAAM,EAAEzX;EAAE,CAAC,KAAKyZ,EAAE,CAACzZ,CAAC,CAAC,CAAC,CAACkL,IAAI,CAAC;AAC5D,CAAC,CAAC;AACF;AACApL,CAAC,CAAC4Z,EAAE,EAAE,gBAAgB,CAAC;;AAEvB;AACA,IAAIC,EAAE,GAAG;EACPtB,IAAI,EAAE,CAAC;EACPpC,KAAK,EAAE,CAAC;EACRc,SAAS,EAAE,CAAC;EACZC,aAAa,EAAE,CAAC;EAChBL,GAAG,EAAE,CAAC;EACNM,OAAO,EAAE,CAAC;EACVtP,IAAI,EAAE,CAAC;EACPuP,QAAQ,EAAE,CAAC;EACX1V,IAAI,EAAE,CAAC;EACP2V,QAAQ,EAAE,CAAC;EACXpB,WAAW,EAAE,CAAC;EACdK,GAAG,EAAE,CAAC;EACNgB,OAAO,EAAE;AACX,CAAC;AACD,IAAIwC,EAAE,GAAG3a,MAAM,CAAC4U,IAAI,CAAC8F,EAAE,CAAC;;AAExB;AACA,SAASE,EAAEA,CAAC9Z,CAAC,EAAEC,CAAC,GAAG,CAAC,CAAC,EAAE;EACrB,OAAOqZ,EAAE,CAACrZ,CAAC,CAAC,CAACD,CAAC,CAAC;AACjB;AACAD,CAAC,CAAC+Z,EAAE,EAAE,OAAO,CAAC;AACd,IAAIC,EAAE,GAAGJ,EAAE,CAAC,CAAC;;AAEb;AACA,IAAIK,CAAC,GAAGnZ,EAAE,CAACE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;AACnB,SAASkZ,EAAEA,CAACja,CAAC,EAAE;EACb,OAAOA,CAAC,IAAI,IAAI,IAAIA,CAAC,CAAC+G,QAAQ,CAAC,GAAG,CAAC;AACrC;AACAhH,CAAC,CAACka,EAAE,EAAE,eAAe,CAAC;AACtB,SAASC,EAAEA,CAACla,CAAC,EAAE;EACb,IAAIQ,CAAC,GAAG;AACV,CAAC,GAAG,CAACR,CAAC,IAAI,EAAE,EAAEyU,KAAK,CAAC;AACpB,CAAC,CAAC,CAACjK,GAAG,CAAEnI,CAAC,IAAK,MAAMA,CAAC,EAAE,CAAC,CAAC8I,IAAI,CAAC;AAC9B,CAAC,CAAC,GAAG;AACL,GAAG;IAAE1K,CAAC,GAAGqZ,EAAE,CAACtZ,CAAC,EAAE;MACX+Y,OAAO,EAAE;IACX,CAAC,CAAC;EACF,IAAI,CAAC9Y,CAAC,IAAIA,CAAC,CAACgC,MAAM,KAAK,CAAC,EACtB,MAAM,IAAId,KAAK,CAAC,0BAA0B,CAAC;EAC7C,OAAOlB,CAAC,CAAC,CAAC,CAAC;AACb;AACAV,CAAC,CAACma,EAAE,EAAE,OAAO,CAAC;AACd,IAAIC,EAAE,GAAG;IACPX,IAAI,EAAE,CAAC,OAAO,EAAE,KAAK,EAAE,UAAU,EAAE,SAAS,EAAE,QAAQ,EAAE,YAAY;EACtE,CAAC;EAAEY,EAAE,GAAG,eAAgBra,CAAC,CAAC,CAACC,CAAC,EAAEC,CAAC,GAAGka,EAAE,KAAK;IACvC,IAAI,CAACF,EAAE,CAACja,CAAC,CAAC,EACR,OAAO;MACLqa,aAAa,EAAE,CAAC,CAAC;MACjBC,MAAM,EAAE,CAAC;IACX,CAAC;IACH,IAAI/Z,CAAC,GAAG2Z,EAAE,CAACla,CAAC,CAAC;MAAEQ,CAAC,GAAG+Z,EAAE,CAACha,CAAC,EAAEN,CAAC,CAACuZ,IAAI,CAAC;IAChC,OAAOhZ,CAAC,CAAC8Z,MAAM,GAAG;MAChBD,aAAa,EAAE,CAAC,CAAC;MACjBC,MAAM,EAAE,CAAC;IACX,CAAC,GAAG;MACFD,aAAa,EAAE,CAAC,CAAC;MACjBC,MAAM,EAAE,CAAC,CAAC;MACV;MACAtE,WAAW,EAAEzV,CAAC,CAACyV,WAAW,CAACjS,IAAI,CAAC,CAAC;MACjCyW,aAAa,EAAEha;IACjB,CAAC;EACH,CAAC,EAAE,YAAY,CAAC;AAChB,SAAS+Z,EAAEA,CAACva,CAAC,EAAEC,CAAC,EAAE;EAChB,IAAIM,CAAC,GAAG;IACNuN,MAAM,EAAE,IAAI;IACZ2M,UAAU,EAAE,IAAI;IAChB9I,OAAO,EAAE,IAAI;IACb2I,MAAM,EAAE,CAAC;EACX,CAAC;EACD,KAAK,IAAI9Z,CAAC,IAAIR,CAAC,CAACwZ,IAAI,EAClB,IAAI,EAAEvZ,CAAC,KAAK,KAAK,CAAC,IAAI,CAACA,CAAC,CAAC8G,QAAQ,CAACvG,CAAC,CAACoW,GAAG,CAAC,CAAC,EACvC,IAAIpW,CAAC,CAACoW,GAAG,KAAK,QAAQ,EAAE;IACtBrW,CAAC,CAAC+Z,MAAM,GAAG,CAAC,CAAC;IACb;EACF,CAAC,MACC,QAAQ9Z,CAAC,CAACoW,GAAG;IACX;IACA,KAAK,OAAO;IACZ,KAAK,KAAK;IACV,KAAK,UAAU;MAAE;QACf,IAAInW,CAAC,GAAGia,EAAE,CAACla,CAAC,CAAC;QACbC,CAAC,IAAI,IAAI,KAAKF,CAAC,CAACuN,MAAM,IAAI,IAAI,KAAKvN,CAAC,CAACuN,MAAM,GAAG,EAAE,CAAC,EAAEvN,CAAC,CAACuN,MAAM,CAACxF,IAAI,CAAC7H,CAAC,CAAC,CAAC;QACpE;MACF;IACA,KAAK,YAAY;MAAE;QACjB,IAAIA,CAAC,GAAGka,EAAE,CAACna,CAAC,CAAC;QACbC,CAAC,IAAI,IAAI,KAAKF,CAAC,CAACka,UAAU,GAAGha,CAAC,CAAC;QAC/B;MACF;IACA,KAAK,SAAS;MAAE;QACd,IAAIA,CAAC,GAAGma,EAAE,CAACpa,CAAC,CAAC;QACbC,CAAC,IAAI,IAAI,KAAKF,CAAC,CAACoR,OAAO,GAAGlR,CAAC,CAAC;QAC5B;MACF;IACA;MACE;EACJ;EACN,OAAOF,CAAC;AACV;AACAR,CAAC,CAACwa,EAAE,EAAE,kBAAkB,CAAC;AACzB,SAASM,EAAEA,CAAC7a,CAAC,EAAE;EACb,OAAOA,CAAC,CAACmT,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC;AAChC;AACApT,CAAC,CAAC8a,EAAE,EAAE,oBAAoB,CAAC;AAC3B,SAASH,EAAEA,CAAC1a,CAAC,EAAE;EACb,IAAI,CAACA,CAAC,CAAC4H,IAAI,IAAI5H,CAAC,CAAC4H,IAAI,KAAK,GAAG,EAC3B,OAAO,IAAI;EACb,IAAI3H,CAAC,GAAG6a,EAAE,CAAC9a,CAAC,CAACyB,IAAI,CAAC;EAClB,OAAO;IACLmG,IAAI,EAAE5H,CAAC,CAAC4H,IAAI;IACZnG,IAAI,EAAExB,CAAC;IACP+V,WAAW,EAAE+E,EAAE,CAAC/a,CAAC,CAACgW,WAAW,CAAC;IAC9BgF,aAAa,EAAE,eAAgBjb,CAAC,CAAC,MAAM8a,EAAE,CAAC7a,CAAC,CAAC4H,IAAI,CAAC,EAAE,eAAe,CAAC;IACnEqT,WAAW,EAAE,eAAgBlb,CAAC,CAAC,MAAME,CAAC,GAAGib,EAAE,CAACjb,CAAC,CAAC,GAAG,IAAI,EAAE,aAAa;EACtE,CAAC;AACH;AACAF,CAAC,CAAC2a,EAAE,EAAE,cAAc,CAAC;AACrB,SAASC,EAAEA,CAAC3a,CAAC,EAAE;EACb,OAAOA,CAAC,CAAC4H,IAAI,GAAGuT,EAAE,CAACnb,CAAC,CAAC4H,IAAI,EAAE5H,CAAC,CAACgW,WAAW,CAAC,GAAG,IAAI;AAClD;AACAjW,CAAC,CAAC4a,EAAE,EAAE,mBAAmB,CAAC;AAC1B,SAASQ,EAAEA,CAACnb,CAAC,EAAEC,CAAC,EAAE;EAChB,IAAIM,CAAC,GAAGP,CAAC,KAAK,EAAE,GAAGC,CAAC,GAAG,GAAGD,CAAC,IAAIC,CAAC,EAAE;EAClC,OAAO8a,EAAE,CAACxa,CAAC,CAAC;AACd;AACAR,CAAC,CAACob,EAAE,EAAE,wBAAwB,CAAC;AAC/B,SAASJ,EAAEA,CAAC/a,CAAC,EAAE;EACb,IAAIC,CAAC,GAAGD,CAAC,CAACmT,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC,CAACpP,IAAI,CAAC,CAAC;EACpC,OAAO9D,CAAC,KAAK,EAAE,GAAG,IAAI,GAAGA,CAAC;AAC5B;AACAF,CAAC,CAACgb,EAAE,EAAE,sBAAsB,CAAC;AAC7B,SAASH,EAAEA,CAAC5a,CAAC,EAAE;EACb,IAAIC,CAAC,GAAG6a,EAAE,CAAC9a,CAAC,CAACyB,IAAI,CAAC;EAClB,OAAOxB,CAAC,GAAG;IACTwB,IAAI,EAAExB,CAAC;IACP+V,WAAW,EAAEmF,EAAE,CAACnb,CAAC,CAAC4H,IAAI,EAAE5H,CAAC,CAACgW,WAAW,CAAC;IACtCiF,WAAW,EAAE,eAAgBlb,CAAC,CAAC,MAAMmb,EAAE,CAACjb,CAAC,CAAC,EAAE,aAAa;EAC3D,CAAC,GAAG,IAAI;AACV;AACAF,CAAC,CAAC6a,EAAE,EAAE,gBAAgB,CAAC;AACvB,IAAIQ,CAAC,GAAG,CAAC,CAAC,EAAEpB,CAAC,CAACtH,cAAc,EAAE,CAAC;EAAE2I,EAAE,GAAGD,CAAC,CAAC7L,eAAe;AACvD6L,CAAC,CAACxM,YAAY,GAAG,MAAM,KAAK;AAC5BwM,CAAC,CAAC7L,eAAe,GAAG,CAACvP,CAAC,EAAEC,CAAC,KAAK,IAAIob,EAAE,CAACrb,CAAC,EAAEC,CAAC,CAAC,GAAG;AAC7Cmb,CAAC,CAAC5L,iBAAiB,GAAG,CAACxP,CAAC,EAAEC,CAAC,KAAKA,CAAC,CAACD,CAAC,CAAC0E,OAAO,CAAC;AAC5C0W,CAAC,CAAC/L,iBAAiB,GAAG,CAACrP,CAAC,EAAEC,CAAC,KAAKA,CAAC,CAACD,CAAC,CAAC0E,OAAO,CAAC;AAC5C0W,CAAC,CAACjM,oBAAoB,GAAG,CAACnP,CAAC,EAAEC,CAAC,KAAKA,CAAC,CAACD,CAAC,CAAC0E,OAAO,CAAC;AAC/C0W,CAAC,CAACxL,cAAc,GAAG,CAAC5P,CAAC,EAAEC,CAAC,KAAKD,CAAC,CAACiI,QAAQ,CAACuC,GAAG,CAACvK,CAAC,CAAC,CAACkL,IAAI,CAAC,GAAG,CAAC;AACxD,SAAS2P,EAAEA,CAAC9a,CAAC,EAAE;EACb,IAAI;IACF,OAAO,CAAC,CAAC,EAAEga,CAAC,CAACzT,KAAK,EAAEvG,CAAC,EAAE,YAAY,CAAC;EACtC,CAAC,CAAC,MAAM;IACN,OAAO,IAAI;EACb;AACF;AACAD,CAAC,CAAC+a,EAAE,EAAE,aAAa,CAAC;AACpB,SAASI,EAAEA,CAAClb,CAAC,EAAE;EACb,OAAO,CAAC,CAAC,EAAEga,CAAC,CAACrH,SAAS,EAAEyI,CAAC,EAAEpb,CAAC,CAAC;AAC/B;AACAD,CAAC,CAACmb,EAAE,EAAE,iBAAiB,CAAC;;AAExB;AACA,IAAII,EAAE,GAAG,EAAE;EAAEC,EAAE,GAAG,EAAE;AACpB,SAASC,EAAEA,CAACxb,CAAC,EAAE;EACb,OAAOA,CAAC,CAACyC,MAAM,GAAG,EAAE;AACtB;AACA1C,CAAC,CAACyb,EAAE,EAAE,yBAAyB,CAAC;AAChC,SAASC,EAAEA,CAACzb,CAAC,EAAE;EACb,OAAOA,CAAC,CAACyC,MAAM,GAAG,EAAE;AACtB;AACA1C,CAAC,CAAC0b,EAAE,EAAE,iCAAiC,CAAC;AACxC,SAASC,CAACA,CAAC1b,CAAC,EAAEC,CAAC,EAAE;EACf,OAAOD,CAAC,KAAKC,CAAC,GAAG;IAAE0b,OAAO,EAAE3b;EAAE,CAAC,GAAG;IAAE2b,OAAO,EAAE3b,CAAC;IAAE4b,MAAM,EAAE3b;EAAE,CAAC;AAC7D;AACAF,CAAC,CAAC2b,CAAC,EAAE,oBAAoB,CAAC;AAC1B,IAAIG,EAAE,GAAG,eAAgB9b,CAAC,CAAEC,CAAC,IAAKA,CAAC,CAACmT,OAAO,CAAC,SAAS,EAAE,KAAK,CAAC,EAAE,mBAAmB,CAAC;;AAEnF;AACA,SAAS2I,EAAEA,CAAC9b,CAAC,EAAEC,CAAC,EAAE;EAChB,IAAID,CAAC,IAAI,IAAI,EAAE;IACb,IAAI;MAAEE,KAAK,EAAEK;IAAE,CAAC,GAAGP,CAAC;IACpB,IAAI,CAACyV,CAAC,CAAClV,CAAC,CAAC,EACP,OAAOkb,EAAE,CAAClb,CAAC,CAAC,GAAGmb,CAAC,CAACzb,CAAC,EAAE2H,IAAI,EAAErH,CAAC,CAAC,GAAGmb,CAAC,CAACnb,CAAC,CAAC;EACvC;EACA,OAAO,IAAI;AACb;AACAR,CAAC,CAAC+b,EAAE,EAAE,oBAAoB,CAAC;;AAE3B;AACA,SAASC,EAAEA,CAAC;EAAEnU,IAAI,EAAE5H,CAAC;EAAEE,KAAK,EAAED,CAAC;EAAEgI,QAAQ,EAAE1H,CAAC;EAAEmT,GAAG,EAAElT;AAAE,CAAC,EAAE;EACtD,OAAOP,CAAC,KAAKM,CAAC,IAAI,IAAI,GAAGA,CAAC,CAACiK,GAAG,CAACuR,EAAE,CAAC,CAAC5Q,IAAI,CAAC,KAAK,CAAC,GAAG3K,CAAC,IAAIR,CAAC,CAAC;AAC1D;AACAD,CAAC,CAACgc,EAAE,EAAE,sBAAsB,CAAC;AAC7B,SAASC,EAAEA,CAAC;EAAEpU,IAAI,EAAE5H,CAAC;EAAE0T,GAAG,EAAEzT,CAAC;EAAEgI,QAAQ,EAAE1H;AAAE,CAAC,EAAE;EAC5C,OAAOA,CAAC,IAAI,IAAI,GAAGmb,CAAC,CAACnb,CAAC,CAACiK,GAAG,CAACuR,EAAE,CAAC,CAAC5Q,IAAI,CAAC,KAAK,CAAC,CAAC,GAAGlL,CAAC,IAAI,IAAI,GAAGyb,CAAC,CAACzb,CAAC,CAACkT,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC,GAAGuI,CAAC,CAAC1b,CAAC,CAAC;AAC7F;AACAD,CAAC,CAACic,EAAE,EAAE,eAAe,CAAC;AACtB,SAASC,EAAEA,CAAC;EAAExa,IAAI,EAAEzB,CAAC;EAAE0T,GAAG,EAAEzT;AAAE,CAAC,EAAE;EAC/B,OAAOA,CAAC,IAAI,IAAI,GAAGyb,CAAC,CAACzb,CAAC,CAAC,GAAGyb,CAAC,CAAC1b,CAAC,CAAC;AAChC;AACAD,CAAC,CAACkc,EAAE,EAAE,uBAAuB,CAAC;AAC9B,SAASC,EAAEA,CAAC;EAAEza,IAAI,EAAEzB,CAAC;EAAE0T,GAAG,EAAEzT;AAAE,CAAC,EAAE;EAC/B,OAAOA,CAAC,IAAI,IAAI,GAAGub,EAAE,CAACvb,CAAC,CAAC,GAAGyb,CAAC,CAAC1b,CAAC,EAAEC,CAAC,CAAC,GAAGyb,CAAC,CAACzb,CAAC,CAAC,GAAGyb,CAAC,CAAC1b,CAAC,CAAC;AAClD;AACAD,CAAC,CAACmc,EAAE,EAAE,yBAAyB,CAAC;AAChC,SAASC,EAAEA,CAACnc,CAAC,EAAE;EACb,IAAI;IAAEyB,IAAI,EAAExB;EAAE,CAAC,GAAGD,CAAC;EACnB,OAAOC,CAAC,KAAK,QAAQ,GAAGic,EAAE,CAAClc,CAAC,CAAC,GAAGic,EAAE,CAACjc,CAAC,CAAC;AACvC;AACAD,CAAC,CAACoc,EAAE,EAAE,mBAAmB,CAAC;AAC1B,SAASC,EAAEA,CAAC;EAAExU,IAAI,EAAE5H,CAAC;EAAE0T,GAAG,EAAEzT;AAAE,CAAC,EAAE;EAC/B,OAAOA,CAAC,IAAI,IAAI,GAAGub,EAAE,CAACvb,CAAC,CAAC,GAAGyb,CAAC,CAAC1b,CAAC,EAAEC,CAAC,CAAC,GAAGyb,CAAC,CAACzb,CAAC,CAAC,GAAGyb,CAAC,CAAC1b,CAAC,CAAC;AAClD;AACAD,CAAC,CAACqc,EAAE,EAAE,iBAAiB,CAAC;AACxB,SAASC,EAAEA,CAACrc,CAAC,EAAE;EACb,IAAIA,CAAC,IAAI,IAAI,EACX,OAAO,IAAI;EACb,QAAQA,CAAC,CAAC4H,IAAI;IACZ,KAAK,OAAO;MACV,OAAOoU,EAAE,CAAChc,CAAC,CAAC;IACd,KAAK,WAAW;MACd,OAAOmc,EAAE,CAACnc,CAAC,CAAC;IACd;MACE,OAAOoc,EAAE,CAACpc,CAAC,CAAC;EAChB;AACF;AACAD,CAAC,CAACsc,EAAE,EAAE,YAAY,CAAC;;AAEnB;AACA,IAAIC,EAAE,GAAG,eAAgBvc,CAAC,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAK;EACnC,IAAI;IAAE+U,QAAQ,EAAEzU,CAAC;IAAEyV,WAAW,EAAExV,CAAC;IAAE+b,QAAQ,EAAE9b,CAAC;IAAE+b,YAAY,EAAEna;EAAE,CAAC,GAAGpC,CAAC;EACrE,OAAO;IACL2H,IAAI,EAAE5H,CAAC;IACPyB,IAAI,EAAE4a,EAAE,CAAC9b,CAAC,CAAC;IACXgc,QAAQ,EAAE9b,CAAC;IACXuV,WAAW,EAAExV,CAAC;IACdgc,YAAY,EAAEV,EAAE,CAACzZ,CAAC,IAAI,IAAI,EAAE9B,CAAC,IAAI,IAAI;EACvC,CAAC;AACH,CAAC,EAAE,mBAAmB,CAAC;;AAEvB;AACA,SAASkc,EAAEA,CAAC;EAAED,YAAY,EAAExc;AAAE,CAAC,EAAE;EAC/B,IAAIA,CAAC,IAAI,IAAI,EAAE;IACb,IAAI;MAAEE,KAAK,EAAED;IAAE,CAAC,GAAGD,CAAC;IACpB,IAAI,CAACyV,CAAC,CAACxV,CAAC,CAAC,EACP,OAAOyb,CAAC,CAACzb,CAAC,CAAC;EACf;EACA,OAAO,IAAI;AACb;AACAF,CAAC,CAAC0c,EAAE,EAAE,oBAAoB,CAAC;;AAE3B;AACA,SAASC,EAAEA,CAAC;EAAE3H,MAAM,EAAE/U,CAAC;EAAEuc,QAAQ,EAAEtc;AAAE,CAAC,EAAE;EACtC,IAAID,CAAC,IAAI,IAAI,EACX,OAAO,IAAI;EACb,IAAIO,CAAC,GAAGP,CAAC,CAAC4H,IAAI;EACd,OAAO3H,CAAC,KAAKM,CAAC,GAAGA,CAAC,CAAC4S,OAAO,CAAC,cAAc,EAAE,EAAE,CAAC,CAAC,EAAEuI,CAAC,CAChD,CAAC,OAAO,EAAE,QAAQ,EAAE,WAAW,CAAC,CAAC3U,QAAQ,CAAC/G,CAAC,CAAC4H,IAAI,CAAC,GAAG5H,CAAC,CAAC0T,GAAG,GAAGnT,CAC9D,CAAC;AACH;AACAR,CAAC,CAAC2c,EAAE,EAAE,YAAY,CAAC;;AAEnB;AACA,IAAIC,EAAE,GAAG,eAAgB5c,CAAC,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAK;EACnC,IAAI;IAAE+V,WAAW,EAAEzV,CAAC;IAAEgc,QAAQ,EAAE/b;EAAE,CAAC,GAAGP,CAAC;EACvC,OAAO;IACL2H,IAAI,EAAE5H,CAAC;IACPyB,IAAI,EAAEib,EAAE,CAACzc,CAAC,CAAC;IACXsc,QAAQ,EAAE/b,CAAC;IACXwV,WAAW,EAAEzV,CAAC;IACdic,YAAY,EAAEC,EAAE,CAACxc,CAAC;EACpB,CAAC;AACH,CAAC,EAAE,iBAAiB,CAAC;;AAErB;AACA,SAAS2c,EAAEA,CAAC5c,CAAC,EAAE;EACb,OAAOA,CAAC,IAAI,IAAI,GAAG0b,CAAC,CAAC1b,CAAC,CAAC4H,IAAI,CAAC,GAAG,IAAI;AACrC;AACA7H,CAAC,CAAC6c,EAAE,EAAE,YAAY,CAAC;AACnB,SAASC,EAAEA,CAAC7c,CAAC,EAAE;EACb,IAAI;IAAEuU,QAAQ,EAAEtU,CAAC;IAAE6c,IAAI,EAAEvc;EAAE,CAAC,GAAGP,CAAC;EAChC,OAAO,OAAOC,CAAC,GAAG,GAAG,IAAI,OAAOM,CAAC,GAAG,GAAG;AACzC;AACAR,CAAC,CAAC8c,EAAE,EAAE,yBAAyB,CAAC;AAChC,SAASE,EAAEA,CAAC/c,CAAC,EAAE;EACb,OAAOA,CAAC,GAAGA,CAAC,CAAC4H,IAAI,KAAK,QAAQ,GAAG,CAAC,CAAC,GAAG5H,CAAC,CAAC4H,IAAI,KAAK,MAAM,GAAGf,KAAK,CAACC,OAAO,CAAC9G,CAAC,CAACE,KAAK,CAAC,IAAIF,CAAC,CAACE,KAAK,CAACyT,KAAK,CAC/F,CAAC;IAAEzT,KAAK,EAAED;EAAE,CAAC,KAAK,OAAOA,CAAC,IAAI,QAAQ,IAAIA,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,IAAIA,CAAC,CAACA,CAAC,CAACwC,MAAM,GAAG,CAAC,CAAC,KAAK,GAChF,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;AACb;AACA1C,CAAC,CAACgd,EAAE,EAAE,gBAAgB,CAAC;AACvB,SAASC,EAAEA,CAAChd,CAAC,EAAEC,CAAC,EAAE;EAChB,IAAID,CAAC,IAAI,IAAI,EAAE;IACb,IAAI;MAAEE,KAAK,EAAEK;IAAE,CAAC,GAAGP,CAAC;IACpB,IAAI,CAACyV,CAAC,CAAClV,CAAC,CAAC,EACP,OAAOsc,EAAE,CAAC7c,CAAC,CAAC,IAAI+c,EAAE,CAAC9c,CAAC,CAAC,GAAGyb,CAAC,CAAChH,IAAI,CAACjC,SAAS,CAAClS,CAAC,CAAC,CAAC,GAAGmb,CAAC,CAACnb,CAAC,CAAC;EACvD;EACA,OAAO,IAAI;AACb;AACAR,CAAC,CAACid,EAAE,EAAE,oBAAoB,CAAC;AAC3B,SAASC,EAAEA,CAACjd,CAAC,EAAEC,CAAC,EAAEM,CAAC,EAAE;EACnB,IAAI;IAAEyV,WAAW,EAAExV,CAAC;IAAE+b,QAAQ,EAAE9b,CAAC;IAAE+b,YAAY,EAAEna;EAAE,CAAC,GAAG9B,CAAC;EACxD,OAAO;IACLqH,IAAI,EAAE5H,CAAC;IACPyB,IAAI,EAAEmb,EAAE,CAAC3c,CAAC,CAAC;IACXsc,QAAQ,EAAE9b,CAAC;IACXuV,WAAW,EAAExV,CAAC;IACdgc,YAAY,EAAEQ,EAAE,CAAC3a,CAAC,EAAEpC,CAAC;EACvB,CAAC;AACH;AACAF,CAAC,CAACkd,EAAE,EAAE,oBAAoB,CAAC;AAC3B,SAASC,EAAEA,CAACld,CAAC,EAAEC,CAAC,EAAE;EAChB,IAAIA,CAAC,EAAEoa,aAAa,EAAE;IACpB,IAAI;MAAErE,WAAW,EAAEzV,CAAC;MAAEia,aAAa,EAAEha;IAAE,CAAC,GAAGP,CAAC;IAC5CM,CAAC,IAAI,IAAI,KAAKP,CAAC,CAACgW,WAAW,GAAG/V,CAAC,CAAC+V,WAAW,CAAC;IAC5C,IAAIvV,CAAC,GAAG;MACN,GAAGD,CAAC;MACJsN,MAAM,EAAEtN,CAAC,EAAEsN,MAAM,EAAEtD,GAAG,CACnBnI,CAAC,KAAM;QACNuF,IAAI,EAAEvF,CAAC,CAAC2Y,aAAa,CAAC,CAAC;QACvBhF,WAAW,EAAE3T,CAAC,CAAC2T;MACjB,CAAC,CACH;IACF,CAAC;IACD9W,MAAM,CAACie,MAAM,CAAC1c,CAAC,CAAC,CAAC0Y,MAAM,CAACiE,OAAO,CAAC,CAAC3a,MAAM,GAAG,CAAC,KAAKzC,CAAC,CAACqd,SAAS,GAAG5c,CAAC,CAAC;EAClE;EACA,OAAOT,CAAC;AACV;AACAD,CAAC,CAACmd,EAAE,EAAE,kBAAkB,CAAC;AACzB,IAAII,EAAE,GAAG,eAAgBvd,CAAC,CAAC,CAACC,CAAC,EAAEC,CAAC,EAAEM,CAAC,KAAK;IACtC,IAAIC,CAAC,GAAGyc,EAAE,CAACjd,CAAC,EAAEC,CAAC,CAACwB,IAAI,EAAExB,CAAC,CAAC;IACxB,OAAOO,CAAC,CAAC+c,MAAM,GAAGzI,EAAE,CAAC7U,CAAC,CAAC,EAAEid,EAAE,CAAC1c,CAAC,EAAED,CAAC,CAAC;EACnC,CAAC,EAAE,mBAAmB,CAAC;EAAEid,EAAE,GAAG,eAAgBzd,CAAC,CAAC,CAACC,CAAC,EAAEC,CAAC,EAAEM,CAAC,KAAK;IAC3D,IAAIC,CAAC,GAAGmc,EAAE,CAAC3c,CAAC,EAAEC,CAAC,CAAC;IAChB,OAAOO,CAAC,CAAC+c,MAAM,GAAGzI,EAAE,CAAC7U,CAAC,CAAC,EAAEid,EAAE,CAAC1c,CAAC,EAAED,CAAC,CAAC;EACnC,CAAC,EAAE,WAAW,CAAC;EAAEkd,EAAE,GAAG,eAAgB1d,CAAC,CAAC,CAACC,CAAC,EAAEC,CAAC,EAAEM,CAAC,KAAK;IACnD,IAAIC,CAAC,GAAG8b,EAAE,CAACtc,CAAC,EAAEC,CAAC,CAAC;IAChB,OAAOO,CAAC,CAAC+c,MAAM,GAAGzI,EAAE,CAAC7U,CAAC,CAAC,EAAEid,EAAE,CAAC1c,CAAC,EAAED,CAAC,CAAC;EACnC,CAAC,EAAE,aAAa,CAAC;EAAEmd,EAAE,GAAG,eAAgB3d,CAAC,CAAC,CAACC,CAAC,EAAEC,CAAC,EAAEM,CAAC,KAAK;IACrD,IAAIC,CAAC,GAAGyc,EAAE,CAACjd,CAAC,EAAE;MAAE4H,IAAI,EAAE;IAAU,CAAC,EAAE3H,CAAC,CAAC;IACrC,OAAOid,EAAE,CAAC1c,CAAC,EAAED,CAAC,CAAC;EACjB,CAAC,EAAE,gBAAgB,CAAC;EAAEod,EAAE,GAAG,eAAgB5d,CAAC,CAAEC,CAAC,IAAK;IAClD,QAAQA,CAAC;MACP,KAAK,YAAY;QACf,OAAOsd,EAAE;MACX,KAAK,YAAY;QACf,OAAOE,EAAE;MACX,KAAK,MAAM;QACT,OAAOC,EAAE;MACX;QACE,OAAOC,EAAE;IACb;EACF,CAAC,EAAE,mBAAmB,CAAC;;AAEvB;AACA,IAAIE,EAAE,GAAG,eAAgB7d,CAAC,CAAEC,CAAC,IAAKA,CAAC,CAACyB,IAAI,IAAI,IAAI,GAAG,YAAY,GAAGzB,CAAC,CAACgV,QAAQ,IAAI,IAAI,GAAG,MAAM,GAAGhV,CAAC,CAAC+U,MAAM,IAAI,IAAI,GAAG,YAAY,GAAG,SAAS,EAC3I,eAAe,CAAC;EAAE8I,EAAE,GAAG,eAAgB9d,CAAC,CAAEC,CAAC,IAAK;IAC9C,IAAIC,CAAC,GAAG2d,EAAE,CAAC5d,CAAC,CAAC,CAAC,CAAC,CAAC;MAAEO,CAAC,GAAGod,EAAE,CAAC1d,CAAC,CAAC;IAC3B,OAAOD,CAAC,CAACwK,GAAG,CAAEhK,CAAC,IAAK;MAClB,IAAIC,CAAC,GAAGD,CAAC;MACT,OAAOA,CAAC,CAACiB,IAAI,EAAEwG,QAAQ,KAAKxH,CAAC,GAAG;QAC9B,GAAGD,CAAC;QACJiB,IAAI,EAAE;UACJ,GAAGjB,CAAC,CAACiB,IAAI;UACTvB,KAAK,EAAEM,CAAC,CAACiB,IAAI,CAACwG;QAChB;MACF,CAAC,CAAC,EAAE6V,EAAE,CAACrd,CAAC,CAACmH,IAAI,EAAEnH,CAAC,EAAER,CAAC,EAAEM,CAAC,CAAC;IACzB,CAAC,CAAC;EACJ,CAAC,EAAE,8BAA8B,CAAC;EAAEwd,EAAE,GAAG,eAAgBhe,CAAC,CAAEC,CAAC,IAAK;IAChE,IAAIC,CAAC,GAAGf,MAAM,CAAC4U,IAAI,CAAC9T,CAAC,CAAC;MAAEO,CAAC,GAAGqd,EAAE,CAAC5d,CAAC,CAACC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;MAAEO,CAAC,GAAGmd,EAAE,CAACpd,CAAC,CAAC;IAClD,OAAON,CAAC,CAACuK,GAAG,CAAE/J,CAAC,IAAK;MAClB,IAAI4B,CAAC,GAAGrC,CAAC,CAACS,CAAC,CAAC;MACZ,OAAO4B,CAAC,IAAI,IAAI,GAAGyb,EAAE,CAACrd,CAAC,EAAE4B,CAAC,EAAE9B,CAAC,EAAEC,CAAC,CAAC,GAAG,IAAI;IAC1C,CAAC,CAAC,CAAC2Y,MAAM,CAACiE,OAAO,CAAC;EACpB,CAAC,EAAE,+BAA+B,CAAC;EAAEY,EAAE,GAAG,eAAgBje,CAAC,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAK;IACpE,IAAIM,CAAC,GAAGuV,EAAE,CAAC9V,CAAC,EAAEC,CAAC,CAAC;IAChB,OAAO4V,EAAE,CAACtV,CAAC,CAAC,GAAGsG,KAAK,CAACC,OAAO,CAACvG,CAAC,CAAC,GAAGsd,EAAE,CAACtd,CAAC,CAAC,GAAGwd,EAAE,CAACxd,CAAC,CAAC,GAAG,EAAE;EACtD,CAAC,EAAE,uBAAuB,CAAC;AAC3B,SAASud,EAAEA,CAAC9d,CAAC,EAAEC,CAAC,EAAEM,CAAC,EAAEC,CAAC,EAAE;EACtB,IAAIC,CAAC,GAAG2Z,EAAE,CAACna,CAAC,CAAC+V,WAAW,CAAC;EACzB,OAAOvV,CAAC,CAAC4Z,aAAa,IAAI5Z,CAAC,CAAC6Z,MAAM,GAAG,IAAI,GAAG;IAC1C2D,OAAO,EAAEzd,CAAC,CAACR,CAAC,EAAEC,CAAC,EAAEQ,CAAC,CAAC;IACnB4c,SAAS,EAAE5c,CAAC,CAAC+Z,aAAa;IAC1B0D,UAAU,EAAEje,CAAC;IACbke,UAAU,EAAE5d;EACd,CAAC;AACH;AACAR,CAAC,CAAC+d,EAAE,EAAE,aAAa,CAAC;AACpB,SAASM,EAAEA,CAACpe,CAAC,EAAE;EACb,OAAOA,CAAC,IAAI,IAAI,GAAG+V,EAAE,CAAC/V,CAAC,CAAC,GAAG,EAAE;AAC/B;AACAD,CAAC,CAACqe,EAAE,EAAE,6BAA6B,CAAC;;AAEpC;AACA,IAAIC,EAAE,GAAG,eAAgBte,CAAC,CAAC,CAAC,GAAGC,CAAC,KAAK;EACnC,IAAIC,CAAC,GAAG,CAAC,CAAC;IAAEM,CAAC,GAAGP,CAAC,CAACmZ,MAAM,CAACiE,OAAO,CAAC;IAAE5c,CAAC,GAAGD,CAAC,CAACqY,MAAM,CAAC,CAACnY,CAAC,EAAE4B,CAAC,MAAMnD,MAAM,CAACoS,OAAO,CAACjP,CAAC,CAAC,CAACkR,OAAO,CAAC,CAAC,CAAChR,CAAC,EAAEI,CAAC,CAAC,KAAK;MAC/F,IAAIE,CAAC,GAAGpC,CAAC,CAAC8B,CAAC,CAAC;MACZsE,KAAK,CAACC,OAAO,CAACnE,CAAC,CAAC,IAAI,OAAOE,CAAC,GAAG,GAAG,GAAGpC,CAAC,CAAC8B,CAAC,CAAC,GAAGI,CAAC,GAAGiR,CAAC,CAACjR,CAAC,CAAC,IAAIiR,CAAC,CAAC/Q,CAAC,CAAC,GAAG5C,CAAC,CAACsC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,OAAOI,CAAC,GAAG,GAAG,KAAKlC,CAAC,CAAC8B,CAAC,CAAC,GAAGI,CAAC,CAAC;IACzG,CAAC,CAAC,EAAElC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;EACX,OAAOvB,MAAM,CAAC4U,IAAI,CAAC7T,CAAC,CAAC,CAACsT,OAAO,CAAE9S,CAAC,IAAK;IACnC,IAAI4B,CAAC,GAAG9B,CAAC,CAAC4Y,MAAM,CAACiE,OAAO,CAAC,CAAC5S,GAAG,CAAEjI,CAAC,IAAKA,CAAC,CAAC9B,CAAC,CAAC,CAAC,CAAC0Y,MAAM,CAAE5W,CAAC,IAAK,OAAOA,CAAC,GAAG,GAAG,CAAC;IACxEF,CAAC,CAACsR,KAAK,CAAEpR,CAAC,IAAKqR,CAAC,CAACrR,CAAC,CAAC,CAAC,GAAG/B,CAAC,CAACC,CAAC,CAAC,GAAG4d,EAAE,CAAC,GAAGhc,CAAC,CAAC,GAAG7B,CAAC,CAACC,CAAC,CAAC,GAAG4B,CAAC,CAACA,CAAC,CAACI,MAAM,GAAG,CAAC,CAAC;EACjE,CAAC,CAAC,EAAEjC,CAAC;AACP,CAAC,EAAE,mBAAmB,CAAC;;AAEvB;AACA,IAAI8d,EAAE,GAAG,eAAgBve,CAAC,CAAEC,CAAC,IAAK;EAChC,IAAI;MACFue,SAAS,EAAEte,CAAC;MACZue,QAAQ,EAAEje,CAAC;MACXwK,UAAU,EAAE;QAAE0T,IAAI,EAAEje,CAAC,GAAG,CAAC;MAAE;IAC7B,CAAC,GAAGR,CAAC;IAAE;MAAE0e,eAAe,EAAEje;IAAE,CAAC,GAAGD,CAAC;EACjC,IAAI,CAACC,CAAC,IAAI,CAACR,CAAC,EACV,OAAOM,CAAC;EACV,IAAI8B,CAAC,GAAG5B,CAAC,CAACR,CAAC,CAAC;EACZ,OAAOoC,CAAC,GAAGgc,EAAE,CAAChc,CAAC,EAAE9B,CAAC,CAAC,GAAGA,CAAC;AACzB,CAAC,EAAE,iBAAiB,CAAC;;AAErB;AACA,IAAIoe,EAAE,GAAG,gBAAgB;EAAEC,EAAE,GAAG,GAAGD,EAAE,QAAQ;EAAEE,EAAE,GAAG,MAAM;EAAEC,EAAE,GAAG,GAAGH,EAAE,mBAAmB;EAAEI,EAAE,GAAG,eAAgB,CAAEve,CAAC,KAAMA,CAAC,CAACwe,IAAI,GAAG,MAAM,EAAExe,CAAC,CAC3Iye,IAAI,GAAG,MAAM,EAAEze,CAAC,CAAC0e,OAAO,GAAG,SAAS,EAAE1e,CAAC,CAAC,EAAEue,EAAE,IAAI,CAAC,CAAC,CAAC;AACnD,SACEJ,EAAE,IAAIQ,QAAQ,EACd5D,EAAE,IAAI6D,gCAAgC,EACtC9D,EAAE,IAAI+D,uBAAuB,EAC7BT,EAAE,IAAIU,QAAQ,EACdT,EAAE,IAAIU,SAAS,EACfT,EAAE,IAAIU,gBAAgB,EACtBT,EAAE,IAAIU,UAAU,EAChBtK,EAAE,IAAIuK,UAAU,EAChB5K,EAAE,IAAI6K,OAAO,EACbjE,CAAC,IAAIkE,kBAAkB,EACvBtB,EAAE,IAAIuB,eAAe,EACrBzB,EAAE,IAAI0B,2BAA2B,EACjC9B,EAAE,IAAI+B,qBAAqB,EAC3BlC,EAAE,IAAImC,4BAA4B,EAClCjC,EAAE,IAAIkC,6BAA6B,EACnClK,EAAE,IAAImK,oBAAoB,EAC1BpK,EAAE,IAAIqK,gBAAgB,EACtBxK,EAAE,IAAIyK,SAAS,EACf3K,CAAC,IAAI4K,yBAAyB,EAC9B5E,EAAE,IAAI6E,+BAA+B,EACrC9E,EAAE,IAAI+E,uBAAuB,EAC7B1K,EAAE,IAAI2K,oBAAoB,EAC1B3E,EAAE,IAAI4E,iBAAiB,EACvBrG,EAAE,IAAIsG,UAAU,EAChBhL,EAAE,IAAIiL,GAAG","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}